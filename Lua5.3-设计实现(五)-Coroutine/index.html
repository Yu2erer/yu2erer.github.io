<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.jpeg"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.ico"><link rel="mask-icon" href="/images/avatar.jpeg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous"><link rel="stylesheet" href="https://unpkg.com/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"yuerer.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"hide","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":true,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/config.min.js"></script><meta name="description" content="Lua的协程和 Golang的协程不同，它是在同一个主线程上跑的协程，个人感觉用途不是很大，毕竟没有发挥多核的优势，不过还是有不少人认为这是 Lua的一个亮点，可以用来实现异步代码改写为同步代码，减轻人脑负担，然而很多人用的时候，并不了解当 Lua协程调用到C函数而C函数又调用到Lua函数后又执行 yield 的解决方案。本篇主要是来探讨Lua协程的设计。 Lua协程的设计思路试想一下，如果你来设"><meta property="og:type" content="article"><meta property="og:title" content="Lua 5.3 设计实现(五) Coroutine"><meta property="og:url" content="https://yuerer.com/Lua5.3-%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0(%E4%BA%94)-Coroutine/index.html"><meta property="og:site_name" content="Yuerer&#39;s Blog"><meta property="og:description" content="Lua的协程和 Golang的协程不同，它是在同一个主线程上跑的协程，个人感觉用途不是很大，毕竟没有发挥多核的优势，不过还是有不少人认为这是 Lua的一个亮点，可以用来实现异步代码改写为同步代码，减轻人脑负担，然而很多人用的时候，并不了解当 Lua协程调用到C函数而C函数又调用到Lua函数后又执行 yield 的解决方案。本篇主要是来探讨Lua协程的设计。 Lua协程的设计思路试想一下，如果你来设"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2020-12-09T04:20:20.000Z"><meta property="article:modified_time" content="2025-10-21T13:50:52.255Z"><meta property="article:author" content="Yuerer"><meta property="article:tag" content="Lua"><meta property="article:tag" content="Lua虚拟机"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://yuerer.com/Lua5.3-%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0(%E4%BA%94)-Coroutine/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://yuerer.com/Lua5.3-%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0(%E4%BA%94)-Coroutine/","path":"Lua5.3-设计实现(五)-Coroutine/","title":"Lua 5.3 设计实现(五) Coroutine"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Lua 5.3 设计实现(五) Coroutine | Yuerer's Blog</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-129491388-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-129491388-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/third-party/analytics/google-analytics.min.js"></script><link rel="dns-prefetch" href="https://yuerer-comment-xufei-0bea01e6f05-1307930306.ap-shanghai.app.tcloudbase.com"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Yuerer's Blog</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">钰儿的Blog</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Lua%E5%8D%8F%E7%A8%8B%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF"><span class="nav-text">Lua协程的设计思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Coroutine"><span class="nav-text">Coroutine</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#create"><span class="nav-text">create</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#resume"><span class="nav-text">resume</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#yield"><span class="nav-text">yield</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Yuerer" src="/images/avatar.jpeg"><p class="site-author-name" itemprop="name">Yuerer</p><div class="site-description" itemprop="description">钰儿的Blog</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">65</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">16</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">90</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/Yu2erer" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Yu2erer" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:yu2erer#gmail.com" title="E-Mail → mailto:yu2erer#gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://yuerer.com/Lua5.3-%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0(%E4%BA%94)-Coroutine/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpeg"><meta itemprop="name" content="Yuerer"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Yuerer's Blog"><meta itemprop="description" content="钰儿的Blog"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Lua 5.3 设计实现(五) Coroutine | Yuerer's Blog"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Lua 5.3 设计实现(五) Coroutine</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-12-09 12:20:20" itemprop="dateCreated datePublished" datetime="2020-12-09T12:20:20+08:00">2020-12-09</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Lua/" itemprop="url" rel="index"><span itemprop="name">Lua</span></a> </span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Waline：</span> <a title="waline" href="/Lua5.3-%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0(%E4%BA%94)-Coroutine/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/Lua5.3-%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0(%E4%BA%94)-Coroutine/" itemprop="commentCount"></span> </a></span><span class="post-meta-item" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="waline-pageview-count" data-path="/Lua5.3-%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0(%E4%BA%94)-Coroutine/"></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>Lua的协程和 Golang的协程不同，它是在同一个主线程上跑的协程，个人感觉用途不是很大，毕竟没有发挥多核的优势，不过还是有不少人认为这是 Lua的一个亮点，可以用来实现异步代码改写为同步代码，减轻人脑负担，然而很多人用的时候，并不了解当 Lua协程调用到C函数而C函数又调用到Lua函数后又执行 <code>yield</code> 的解决方案。本篇主要是来探讨Lua协程的设计。</p><h2 id="Lua协程的设计思路"><a href="#Lua协程的设计思路" class="headerlink" title="Lua协程的设计思路"></a>Lua协程的设计思路</h2><p>试想一下，如果你来设计一个在同一个主线程上跑，且没有调度的协程，你会怎么做？</p><p>可能你会说这还不简单，我们都已经知道了 <code>CallInfo</code> 这样的结构，只需要创建一个新的Lua栈，将新的 函数设置进其 <code>CallInfo</code> ，当执行到 <code>resume</code> 时，则将 Lua栈 推入，去执行新的指令不就行了？</p><p>如果Lua只在自己的世界里面玩，从来不调用 C函数，那就还好。但问题是Lua会与其宿主语言也就是C语言进行打交道，会调用C的函数，如果这个C函数又调用了Lua Function，而其又调用了 <code>yield</code>，等到它又被 <code>resume</code> 的时候，它就没办法继续执行那尚未执行完成的C函数。</p><p>大致执行流程如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为 lua 的 resume，其实是在C中导出的</span></span><br><span class="line">(<span class="number">1</span>)Lua:resume-&gt;[C:resume]</span><br><span class="line"><span class="comment">// C函数又调用了 lua的函数 因此会执行到 lua_call</span></span><br><span class="line">-&gt;Lua:Function-&gt;[C:Function]-&gt;[C:lua_call]</span><br><span class="line"><span class="comment">// lua的函数被执行到后，又去执行 yield</span></span><br><span class="line">-&gt;(Lua:Function)-&gt;Lua:yield</span><br><span class="line"></span><br><span class="line"><span class="comment">// 某一刻协程又被启动，此时回不到 C:lua_call</span></span><br></pre></td></tr></table></figure><p>一种可行的思路是，将Lua的协程与每一个系统线程绑定，消耗高(不过我觉得这样才能发挥出多线程的优势嘛)。</p><p>Lua采用的方案则是，通过保存C函数和其状态，并标记状态，当 <code>resume</code>时根据已有信息，回到原来未执行完C函数的位置。</p><p>以下的 <code>lua_pcallk</code> 为使用例子，倒数第二个参数为上下文，倒数第一个参数则是该C函数如果被中断后，应该继续执行的事情。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">luaB_pcall</span> <span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line">  luaL_checkany(L, <span class="number">1</span>);</span><br><span class="line">  lua_pushboolean(L, <span class="number">1</span>);  <span class="comment">/* first result if no errors */</span></span><br><span class="line">  lua_insert(L, <span class="number">1</span>);  <span class="comment">/* put it in place */</span></span><br><span class="line">  status = lua_pcallk(L, lua_gettop(L) - <span class="number">2</span>, LUA_MULTRET, <span class="number">0</span>, <span class="number">0</span>, finishpcall);</span><br><span class="line">  <span class="keyword">return</span> finishpcall(L, status, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="Coroutine"><a href="#Coroutine" class="headerlink" title="Coroutine"></a>Coroutine</h2><h3 id="create"><a href="#create" class="headerlink" title="create"></a>create</h3><p>先来看创建操作，调用 <code>lua_newthread</code> 创建一个新协程，这里面的协程的状态信息还是 <code>lua_State</code> ，各个协程之间的公共数据则在 <code>global_State</code> 。</p><p><code>lua_xmove</code> 则是将两个 <code>lua_State</code> 的数据转移。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">LUA_API <span class="type">void</span> </span><br><span class="line"><span class="title function_">lua_xmove</span> <span class="params">(lua_State *from, lua_State *to, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">	....</span><br><span class="line">  from-&gt;top -= n;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    setobj2s(to, to-&gt;top, from-&gt;top + i);</span><br><span class="line">    to-&gt;top++;  <span class="comment">/* stack already checked by previous &#x27;api_check&#x27; */</span></span><br><span class="line">  &#125;</span><br><span class="line">  lua_unlock(to);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">luaB_cocreate</span> <span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">  lua_State *NL;</span><br><span class="line">  luaL_checktype(L, <span class="number">1</span>, LUA_TFUNCTION);</span><br><span class="line">  NL = lua_newthread(L);</span><br><span class="line">  lua_pushvalue(L, <span class="number">1</span>);  <span class="comment">/* move function to top */</span></span><br><span class="line">  lua_xmove(L, NL, <span class="number">1</span>);  <span class="comment">/* move function from L to NL */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="resume"><a href="#resume" class="headerlink" title="resume"></a>resume</h3><p>创建好协程，还需要手动调用 <code>resume</code> 才能执行，主要依托于 <code>auxresume</code>，将参数拷贝到协程中，调用 <code>lua_resume</code> 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">auxresume</span> <span class="params">(lua_State *L, lua_State *co, <span class="type">int</span> narg)</span> &#123;</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line">  <span class="keyword">if</span> (!lua_checkstack(co, narg)) &#123;</span><br><span class="line">    lua_pushliteral(L, <span class="string">&quot;too many arguments to resume&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">/* error flag */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (lua_status(co) == LUA_OK &amp;&amp; lua_gettop(co) == <span class="number">0</span>) &#123;</span><br><span class="line">    lua_pushliteral(L, <span class="string">&quot;cannot resume dead coroutine&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">/* error flag */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  lua_xmove(L, co, narg);</span><br><span class="line">  status = lua_resume(co, L, narg);</span><br><span class="line">  <span class="keyword">if</span> (status == LUA_OK || status == LUA_YIELD) &#123;</span><br><span class="line">    <span class="type">int</span> nres = lua_gettop(co);</span><br><span class="line">    <span class="keyword">if</span> (!lua_checkstack(L, nres + <span class="number">1</span>)) &#123;</span><br><span class="line">      lua_pop(co, nres);  <span class="comment">/* remove results anyway */</span></span><br><span class="line">      lua_pushliteral(L, <span class="string">&quot;too many results to resume&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">/* error flag */</span></span><br><span class="line">    &#125;</span><br><span class="line">    lua_xmove(co, L, nres);  <span class="comment">/* move yielded values */</span></span><br><span class="line">    <span class="keyword">return</span> nres;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    lua_xmove(co, L, <span class="number">1</span>);  <span class="comment">/* move error message */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">/* error flag */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">luaB_coresume</span> <span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">  lua_State *co = getco(L);</span><br><span class="line">  <span class="type">int</span> r;</span><br><span class="line">  r = auxresume(L, co, lua_gettop(L) - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    lua_pushboolean(L, <span class="number">0</span>);</span><br><span class="line">    lua_insert(L, <span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;  <span class="comment">/* return false + error message */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    lua_pushboolean(L, <span class="number">1</span>);</span><br><span class="line">    lua_insert(L, -(r + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>;  <span class="comment">/* return true + &#x27;resume&#x27; returns */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lua_resume 会检查各种条件，包括协程状态，调用层数。</p><p>接下来会将 <code>nny</code> 设置为 0，这个 nny 指的是 <code>number of non-yieldable&quot; calls</code> ，它是用来控制是否允许 <code>yield</code> 的，最终会以保护的形式调用 <code>resume</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">LUA_API <span class="type">int</span> <span class="title function_">lua_resume</span> <span class="params">(lua_State *L, lua_State *from, <span class="type">int</span> nargs)</span> &#123;</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> oldnny = L-&gt;nny;  <span class="comment">/* save &quot;number of non-yieldable&quot; calls */</span></span><br><span class="line">  lua_lock(L);</span><br><span class="line">  <span class="keyword">if</span> (L-&gt;status == LUA_OK) &#123;  <span class="comment">/* may be starting a coroutine */</span></span><br><span class="line">    <span class="keyword">if</span> (L-&gt;ci != &amp;L-&gt;base_ci)  <span class="comment">/* not in base level? */</span></span><br><span class="line">      <span class="keyword">return</span> resume_error(L, <span class="string">&quot;cannot resume non-suspended coroutine&quot;</span>, nargs);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (L-&gt;status != LUA_YIELD)</span><br><span class="line">    <span class="keyword">return</span> resume_error(L, <span class="string">&quot;cannot resume dead coroutine&quot;</span>, nargs);</span><br><span class="line">  L-&gt;nCcalls = (from) ? from-&gt;nCcalls + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (L-&gt;nCcalls &gt;= LUAI_MAXCCALLS)</span><br><span class="line">    <span class="keyword">return</span> resume_error(L, <span class="string">&quot;C stack overflow&quot;</span>, nargs);</span><br><span class="line">  luai_userstateresume(L, nargs);</span><br><span class="line">  L-&gt;nny = <span class="number">0</span>;  <span class="comment">/* allow yields */</span></span><br><span class="line">  api_checknelems(L, (L-&gt;status == LUA_OK) ? nargs + <span class="number">1</span> : nargs);</span><br><span class="line">  status = luaD_rawrunprotected(L, resume, &amp;nargs);</span><br><span class="line">  <span class="keyword">if</span> (status == <span class="number">-1</span>)  <span class="comment">/* error calling &#x27;lua_resume&#x27;? */</span></span><br><span class="line">    status = LUA_ERRRUN;</span><br><span class="line">  <span class="keyword">else</span> &#123;  <span class="comment">/* continue running after recoverable errors */</span></span><br><span class="line">    <span class="keyword">while</span> (errorstatus(status) &amp;&amp; recover(L, status)) &#123;</span><br><span class="line">      <span class="comment">/* unroll continuation */</span></span><br><span class="line">      status = luaD_rawrunprotected(L, unroll, &amp;status);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (errorstatus(status)) &#123;  <span class="comment">/* unrecoverable error? */</span></span><br><span class="line">      L-&gt;status = cast_byte(status);  <span class="comment">/* mark thread as &#x27;dead&#x27; */</span></span><br><span class="line">      seterrorobj(L, status, L-&gt;top);  <span class="comment">/* push error message */</span></span><br><span class="line">      L-&gt;ci-&gt;top = L-&gt;top;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> lua_assert(status == L-&gt;status);  <span class="comment">/* normal end or yield */</span></span><br><span class="line">  &#125;</span><br><span class="line">  L-&gt;nny = oldnny;  <span class="comment">/* restore &#x27;nny&#x27; */</span></span><br><span class="line">  L-&gt;nCcalls--;</span><br><span class="line">  lua_assert(L-&gt;nCcalls == ((from) ? from-&gt;nCcalls : <span class="number">0</span>));</span><br><span class="line">  lua_unlock(L);</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是协程刚开始的时候，那就像是执行一个函数那么简单。相反如果是从 <code>yield</code> 状态切换回来，</p><p>其实这必然是 C函数中过来的，因为 lua调用 <code>yield</code> 其实还是到了C函数这。</p><p>如果在 lua 则继续解析指令即可，这里的 lua 其实是 hook 函数，看起来是 lua 函数 其实还是 C函数，可以看到 之前的堆栈信息存在了 <code>CallInfo-&gt;extra</code>，所以 <code>resume</code> 回来之后，实际上不会有 Lua函数，但是我们要跳过 Lua的指令。</p><p>若是在C中 调用的 lua函数，而lua函数又调用了 <code>yield</code> ，则看看 我们之前保存的继续处理函数和上下文存不存在，再去调用即可（调用的是C函数剩余的部分）。</p><p>执行完之前遗留的工作以后，只是说恢复到了正确的工作，别忘了 lua 中可能还有要执行的任务，因此会调用 <code>unroll</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">resume</span> <span class="params">(lua_State *L, <span class="type">void</span> *ud)</span> &#123;</span><br><span class="line">  <span class="type">int</span> n = *(cast(<span class="type">int</span>*, ud));  <span class="comment">/* number of arguments */</span></span><br><span class="line">  StkId firstArg = L-&gt;top - n;  <span class="comment">/* first argument */</span></span><br><span class="line">  CallInfo *ci = L-&gt;ci;</span><br><span class="line">  <span class="keyword">if</span> (L-&gt;status == LUA_OK) &#123;  <span class="comment">/* starting a coroutine? */</span></span><br><span class="line">    <span class="keyword">if</span> (!luaD_precall(L, firstArg - <span class="number">1</span>, LUA_MULTRET))  <span class="comment">/* Lua function? */</span></span><br><span class="line">      luaV_execute(L);  <span class="comment">/* call it */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;  <span class="comment">/* resuming from previous yield */</span></span><br><span class="line">    lua_assert(L-&gt;status == LUA_YIELD);</span><br><span class="line">    L-&gt;status = LUA_OK;  <span class="comment">/* mark that it is running (again) */</span></span><br><span class="line">    ci-&gt;func = restorestack(L, ci-&gt;extra);</span><br><span class="line">    <span class="keyword">if</span> (isLua(ci))  <span class="comment">/* yielded inside a hook? */</span></span><br><span class="line">      luaV_execute(L);  <span class="comment">/* just continue running Lua code */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">/* &#x27;common&#x27; yield */</span></span><br><span class="line">      <span class="keyword">if</span> (ci-&gt;u.c.k != <span class="literal">NULL</span>) &#123;  <span class="comment">/* does it have a continuation function? */</span></span><br><span class="line">        lua_unlock(L);</span><br><span class="line">        n = (*ci-&gt;u.c.k)(L, LUA_YIELD, ci-&gt;u.c.ctx); <span class="comment">/* call continuation */</span></span><br><span class="line">        lua_lock(L);</span><br><span class="line">        api_checknelems(L, n);</span><br><span class="line">        firstArg = L-&gt;top - n;  <span class="comment">/* yield results come from continuation */</span></span><br><span class="line">      &#125;</span><br><span class="line">      luaD_poscall(L, ci, firstArg, n);  <span class="comment">/* finish &#x27;luaD_precall&#x27; */</span></span><br><span class="line">    &#125;</span><br><span class="line">    unroll(L, <span class="literal">NULL</span>);  <span class="comment">/* run continuation */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>unroll</code> 较为简单，执行接下来的字节码，如果是停在了C函数，则会调用 <code>finishCcall</code> 去执行完剩余的C函数。</p><p><code>adjustresults(L, ci-&gt;nresults);</code> 是因为此时一定停在了 <code>luaD_precall</code> 函数，而这后面就是这一句，因此可以写死，还有一句则是 <code>luaD_poscall</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">finishCcall</span> <span class="params">(lua_State *L, <span class="type">int</span> status)</span> &#123;</span><br><span class="line">  CallInfo *ci = L-&gt;ci;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="comment">/* must have a continuation and must be able to call it */</span></span><br><span class="line">  lua_assert(ci-&gt;u.c.k != <span class="literal">NULL</span> &amp;&amp; L-&gt;nny == <span class="number">0</span>);</span><br><span class="line">  <span class="comment">/* error status can only happen in a protected call */</span></span><br><span class="line">  lua_assert((ci-&gt;callstatus &amp; CIST_YPCALL) || status == LUA_YIELD);</span><br><span class="line">  <span class="keyword">if</span> (ci-&gt;callstatus &amp; CIST_YPCALL) &#123;  <span class="comment">/* was inside a pcall? */</span></span><br><span class="line">    ci-&gt;callstatus &amp;= ~CIST_YPCALL;  <span class="comment">/* continuation is also inside it */</span></span><br><span class="line">    L-&gt;errfunc = ci-&gt;u.c.old_errfunc;  <span class="comment">/* with the same error function */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* finish &#x27;lua_callk&#x27;/&#x27;lua_pcall&#x27;; CIST_YPCALL and &#x27;errfunc&#x27; already</span></span><br><span class="line"><span class="comment">     handled */</span></span><br><span class="line">  adjustresults(L, ci-&gt;nresults);</span><br><span class="line">  lua_unlock(L);</span><br><span class="line">  n = (*ci-&gt;u.c.k)(L, status, ci-&gt;u.c.ctx);  <span class="comment">/* call continuation function */</span></span><br><span class="line">  lua_lock(L);</span><br><span class="line">  api_checknelems(L, n);</span><br><span class="line">  luaD_poscall(L, ci, L-&gt;top - n, n);  <span class="comment">/* finish &#x27;luaD_precall&#x27; */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">unroll</span> <span class="params">(lua_State *L, <span class="type">void</span> *ud)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (ud != <span class="literal">NULL</span>)  <span class="comment">/* error status? */</span></span><br><span class="line">    finishCcall(L, *(<span class="type">int</span> *)ud);  <span class="comment">/* finish &#x27;lua_pcallk&#x27; callee */</span></span><br><span class="line">  <span class="keyword">while</span> (L-&gt;ci != &amp;L-&gt;base_ci) &#123;  <span class="comment">/* something in the stack */</span></span><br><span class="line">    <span class="keyword">if</span> (!isLua(L-&gt;ci))  <span class="comment">/* C function? */</span></span><br><span class="line">      finishCcall(L, LUA_YIELD);  <span class="comment">/* complete its execution */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">/* Lua function */</span></span><br><span class="line">      luaV_finishOp(L);  <span class="comment">/* finish interrupted instruction */</span></span><br><span class="line">      luaV_execute(L);  <span class="comment">/* execute down to higher C &#x27;boundary&#x27; */</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>lua_resume</code> 以保护模式调用 <code>resume</code> 如果出现异常，则会调用 <code>recover</code> 去修复。可以看到 这里是去找 调用 <code>pcall</code> 的 <code>CallInfo</code> 。因为 pcall 确实会抛出异常，然后就会去找 pcall 在哪里，将其还未执行完的事情给完成（指的是 luaD_pcall 异常后应该做的事情）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> CallInfo *<span class="title function_">findpcall</span> <span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">  CallInfo *ci;</span><br><span class="line">  <span class="keyword">for</span> (ci = L-&gt;ci; ci != <span class="literal">NULL</span>; ci = ci-&gt;previous) &#123;  <span class="comment">/* search for a pcall */</span></span><br><span class="line">    <span class="keyword">if</span> (ci-&gt;callstatus &amp; CIST_YPCALL)</span><br><span class="line">      <span class="keyword">return</span> ci;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">/* no pending pcall */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">recover</span> <span class="params">(lua_State *L, <span class="type">int</span> status)</span> &#123;</span><br><span class="line">  StkId oldtop;</span><br><span class="line">  CallInfo *ci = findpcall(L);</span><br><span class="line">  <span class="keyword">if</span> (ci == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">/* no recovery point */</span></span><br><span class="line">  <span class="comment">/* &quot;finish&quot; luaD_pcall */</span></span><br><span class="line">  oldtop = restorestack(L, ci-&gt;extra);</span><br><span class="line">  luaF_close(L, oldtop);</span><br><span class="line">  seterrorobj(L, status, oldtop);</span><br><span class="line">  L-&gt;ci = ci;</span><br><span class="line">  L-&gt;allowhook = getoah(ci-&gt;callstatus);  <span class="comment">/* restore original &#x27;allowhook&#x27; */</span></span><br><span class="line">  L-&gt;nny = <span class="number">0</span>;  <span class="comment">/* should be zero to be yieldable */</span></span><br><span class="line">  luaD_shrinkstack(L);</span><br><span class="line">  L-&gt;errfunc = ci-&gt;u.c.old_errfunc;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">/* continue running the coroutine */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><p>交出CPU资源，给其他协程机会，有了前面的基础，比较好理解，保存了当下次 <code>resume</code> 的时候，应该继续执行的C函数和上下文环境。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">LUA_API <span class="type">int</span> <span class="title function_">lua_yieldk</span> <span class="params">(lua_State *L, <span class="type">int</span> nresults, lua_KContext ctx,</span></span><br><span class="line"><span class="params">                        lua_KFunction k)</span> &#123;</span><br><span class="line">  CallInfo *ci = L-&gt;ci;</span><br><span class="line">  luai_userstateyield(L, nresults);</span><br><span class="line">  lua_lock(L);</span><br><span class="line">  api_checknelems(L, nresults);</span><br><span class="line">  <span class="keyword">if</span> (L-&gt;nny &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (L != G(L)-&gt;mainthread)</span><br><span class="line">      luaG_runerror(L, <span class="string">&quot;attempt to yield across a C-call boundary&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      luaG_runerror(L, <span class="string">&quot;attempt to yield from outside a coroutine&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  L-&gt;status = LUA_YIELD;</span><br><span class="line">  ci-&gt;extra = savestack(L, ci-&gt;func);  <span class="comment">/* save current &#x27;func&#x27; */</span></span><br><span class="line">  <span class="keyword">if</span> (isLua(ci)) &#123;  <span class="comment">/* inside a hook? */</span></span><br><span class="line">    api_check(L, k == <span class="literal">NULL</span>, <span class="string">&quot;hooks cannot continue after yielding&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((ci-&gt;u.c.k = k) != <span class="literal">NULL</span>)  <span class="comment">/* is there a continuation? */</span></span><br><span class="line">      ci-&gt;u.c.ctx = ctx;  <span class="comment">/* save context */</span></span><br><span class="line">    ci-&gt;func = L-&gt;top - nresults - <span class="number">1</span>;  <span class="comment">/* protect stack below results */</span></span><br><span class="line">    luaD_throw(L, LUA_YIELD);</span><br><span class="line">  &#125;</span><br><span class="line">  lua_assert(ci-&gt;callstatus &amp; CIST_HOOKED);  <span class="comment">/* must be inside a hook */</span></span><br><span class="line">  lua_unlock(L);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">/* return to &#x27;luaD_hook&#x27; */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Lua/" rel="tag"># Lua</a> <a href="/tags/Lua%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="tag"># Lua虚拟机</a></div><div class="post-nav"><div class="post-nav-item"><a href="/Lua5.3-%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0(%E5%9B%9B)-Closure%E4%B8%8EUpvalues/" rel="prev" title="Lua 5.3 设计实现(四) Closure与Upvalues"><i class="fa fa-angle-left"></i> Lua 5.3 设计实现(四) Closure与Upvalues</a></div><div class="post-nav-item"><a href="/Lua5.3-%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0(%E5%85%AD)-GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" rel="next" title="Lua 5.3 设计实现(六) GC 垃圾回收">Lua 5.3 设计实现(六) GC 垃圾回收 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Yuerer</span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://unpkg.com/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://unpkg.com/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/comments.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/utils.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/motion.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/sidebar.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/next-boot.min.js"></script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://yuerer-comment-xufei-0bea01e6f05-1307930306.ap-shanghai.app.tcloudbase.com","cssUrl":"https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.css","commentCount":true,"pageview":true,"libUrl":"https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.js","locale":{"placeholder":"有何高见？"},"emoji":["https://unpkg.com/@waline/emojis@1.0.1/qq"],"meta":["nick","mail"],"requiredMeta":[["nick","mail"]],"wordLimit":0,"login":"disable","pageSize":10,"el":"#waline","comment":true,"path":"/Lua5.3-%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0(%E4%BA%94)-Coroutine/"}</script><link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.css"><script>document.addEventListener("page:loaded",()=>{NexT.utils.loadComments(CONFIG.waline.el).then(()=>NexT.utils.getScript(CONFIG.waline.libUrl,{condition:window.Waline})).then(()=>Waline.init(Object.assign({},CONFIG.waline,{el:document.querySelector(CONFIG.waline.el)})))})</script></body></html>