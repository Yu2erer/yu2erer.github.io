<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.jpeg"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.ico"><link rel="mask-icon" href="/images/avatar.jpeg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous"><link rel="stylesheet" href="https://unpkg.com/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"yuerer.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"hide","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":true,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/config.min.js"></script><meta name="description" content="前言本节主要是讲 网络编程中, 常用的I&#x2F;O 多路复用. 全文大概分为以下几点.  为什么需要I&#x2F;O多路复用? I&#x2F;O多路复用的使用场景? 为什么都是与非阻塞I&#x2F;O进行搭配, 而不是与阻塞I&#x2F;O进行搭配呢? select 的 优缺点 及 内核实现 poll 的 优缺点 及 内核实现 epoll 的 优缺点 及 内核实现"><meta property="og:type" content="article"><meta property="og:title" content="Linux网络编程 I&#x2F;O多路复用"><meta property="og:url" content="https://yuerer.com/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/index.html"><meta property="og:site_name" content="Yuerer&#39;s Blog"><meta property="og:description" content="前言本节主要是讲 网络编程中, 常用的I&#x2F;O 多路复用. 全文大概分为以下几点.  为什么需要I&#x2F;O多路复用? I&#x2F;O多路复用的使用场景? 为什么都是与非阻塞I&#x2F;O进行搭配, 而不是与阻塞I&#x2F;O进行搭配呢? select 的 优缺点 及 内核实现 poll 的 优缺点 及 内核实现 epoll 的 优缺点 及 内核实现"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2020-08-23T05:14:20.000Z"><meta property="article:modified_time" content="2025-10-21T13:50:52.253Z"><meta property="article:author" content="Yuerer"><meta property="article:tag" content="Linux"><meta property="article:tag" content="系统编程"><meta property="article:tag" content="网络编程"><meta property="article:tag" content="I&#x2F;O多路复用"><meta property="article:tag" content="epoll"><meta property="article:tag" content="select"><meta property="article:tag" content="poll"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://yuerer.com/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://yuerer.com/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/","path":"Linux网络编程IO多路复用/","title":"Linux网络编程 I/O多路复用"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Linux网络编程 I/O多路复用 | Yuerer's Blog</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-129491388-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-129491388-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/third-party/analytics/google-analytics.min.js"></script><link rel="dns-prefetch" href="https://yuerer-comment-xufei-0bea01e6f05-1307930306.ap-shanghai.app.tcloudbase.com"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Yuerer's Blog</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">钰儿的Blog</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-I-O-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="nav-text">为什么需要 I&#x2F;O 多路复用?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%BB%E5%A1%9EI-O"><span class="nav-text">阻塞I&#x2F;O</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9EI-O"><span class="nav-text">非阻塞I&#x2F;O</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">I&#x2F;O多路复用的使用场景?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%83%BD%E6%98%AF%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9EI-O%E8%BF%9B%E8%A1%8C%E6%90%AD%E9%85%8D-%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%8E%E9%98%BB%E5%A1%9EI-O%E8%BF%9B%E8%A1%8C%E6%90%AD%E9%85%8D%E5%91%A2"><span class="nav-text">为什么都是与非阻塞I&#x2F;O进行搭配, 而不是与阻塞I&#x2F;O进行搭配呢?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#select-%E7%9A%84-%E4%BC%98%E7%BC%BA%E7%82%B9-%E5%8F%8A-%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0"><span class="nav-text">select 的 优缺点 及 内核实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#select-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-text">select 使用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#select-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-text">select 优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#select-%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0"><span class="nav-text">select 内核实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#poll-%E7%9A%84-%E4%BC%98%E7%BC%BA%E7%82%B9-%E5%8F%8A-%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0"><span class="nav-text">poll 的 优缺点 及 内核实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#poll-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-text">poll 使用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#poll-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-text">poll 优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#poll-%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0"><span class="nav-text">poll 内核实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#epoll-%E7%9A%84-%E4%BC%98%E7%BC%BA%E7%82%B9-%E5%8F%8A-%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0"><span class="nav-text">epoll 的 优缺点 及 内核实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-text">epoll 使用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E8%A7%A6%E5%8F%91-%E6%B0%B4%E5%B9%B3%E8%A7%A6%E5%8F%91-%E4%B8%8E-%E8%BE%B9%E7%BC%98%E8%A7%A6%E5%8F%91"><span class="nav-text">条件触发(水平触发) 与 边缘触发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll-%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0"><span class="nav-text">epoll 内核实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#sys-epoll-create"><span class="nav-text">sys_epoll_create()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sys-epoll-ctl"><span class="nav-text">sys_epoll_ctl()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sys-epoll-wait"><span class="nav-text">sys_epoll_wait()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LT-%E4%B8%8E-ET-%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="nav-text">LT 与 ET 是怎么实现的?</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Yuerer" src="/images/avatar.jpeg"><p class="site-author-name" itemprop="name">Yuerer</p><div class="site-description" itemprop="description">钰儿的Blog</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">65</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">16</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">90</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/Yu2erer" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Yu2erer" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:yu2erer#gmail.com" title="E-Mail → mailto:yu2erer#gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://yuerer.com/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpeg"><meta itemprop="name" content="Yuerer"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Yuerer's Blog"><meta itemprop="description" content="钰儿的Blog"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Linux网络编程 I/O多路复用 | Yuerer's Blog"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Linux网络编程 I/O多路复用</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-08-23 13:14:20" itemprop="dateCreated datePublished" datetime="2020-08-23T13:14:20+08:00">2020-08-23</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Linux网络编程</span></a> </span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Waline：</span> <a title="waline" href="/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" itemprop="commentCount"></span> </a></span><span class="post-meta-item" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="waline-pageview-count" data-path="/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本节主要是讲 网络编程中, 常用的I&#x2F;O 多路复用. 全文大概分为以下几点.</p><ol><li>为什么需要I&#x2F;O多路复用?</li><li>I&#x2F;O多路复用的使用场景?</li><li>为什么都是与非阻塞I&#x2F;O进行搭配, 而不是与阻塞I&#x2F;O进行搭配呢?</li><li>select 的 优缺点 及 内核实现</li><li>poll 的 优缺点 及 内核实现</li><li>epoll 的 优缺点 及 内核实现</li></ol><span id="more"></span><h2 id="为什么需要-I-O-多路复用"><a href="#为什么需要-I-O-多路复用" class="headerlink" title="为什么需要 I&#x2F;O 多路复用?"></a>为什么需要 I&#x2F;O 多路复用?</h2><p>首先 I&#x2F;O 模型 最主要分为以下几种</p><ul><li>阻塞I&#x2F;O</li><li>非阻塞I&#x2F;O</li><li>I&#x2F;O 复用</li><li>信号驱动I&#x2F;O</li><li>异步I&#x2F;O</li></ul><p>在这里只谈 阻塞与非阻塞 I&#x2F;O.</p><h3 id="阻塞I-O"><a href="#阻塞I-O" class="headerlink" title="阻塞I&#x2F;O"></a>阻塞I&#x2F;O</h3><p>比如说 Socket send 一段数据给对端机器 如果TCP发送缓冲区不够大, 则会产生阻塞, 产生阻塞之后, 调度器会将CPU资源让给其他进程, 这样对于一个服务器进程来说实在是难以接受, 因此有没有什么办法, 让内核通知我们 缓冲区什么时候足够大了, 再通知我们, 我们这时候再去写入数据到TCP缓冲区呢?</p><p>这就引出了 I&#x2F;O 多路复用, 它就是用来做这类事情, 只要你将描述符给到它们, 当可读或可写为你所关心的事件的时候, 它就会来通知你, 这时候去读就不会阻塞(注意不是一定, 原因会在下面)</p><h3 id="非阻塞I-O"><a href="#非阻塞I-O" class="headerlink" title="非阻塞I&#x2F;O"></a>非阻塞I&#x2F;O</h3><p>那非阻塞I&#x2F;O send 的时候不就不会阻塞了吗? 为什么 非阻塞I&#x2F;O 也要用 I&#x2F;O多路复用呢? 其实原因很简单, 非阻塞I&#x2F;O 你想你调用 send 的函数, 发送出去, 它是不阻塞的, 但是有可能TCP发送缓冲区不够大, 它虽然立即返回结果, 但有可能并没有发送成功, 这个时候你就要想, 我应该在什么时候再试试呢? 不知晓I&#x2F;O多路复用的人 很可能写出以下 伪代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (Socket::send(buf) != succ) &#123;&#125;</span><br></pre></td></tr></table></figure><p>换句话说就是 不停地 while 循环 检测 TCP发送缓冲区是否足以成功发送了, 但是这种做法会引来一个新的问题 那就是, 服务端没办法做其他任何的事情, 它就一直在这傻傻的不停地问.</p><p>这时候 I&#x2F;O多路复用再次出场了, 它通知你这时候可读或可写, 你再去读, 这样就不会一直处于 busy loop 中.</p><h2 id="I-O多路复用的使用场景"><a href="#I-O多路复用的使用场景" class="headerlink" title="I&#x2F;O多路复用的使用场景?"></a>I&#x2F;O多路复用的使用场景?</h2><p>其实从上面举的例子来看, 已经讲清楚了I&#x2F;O多路复用的使用场景, 当你想要高效的知道一个文件描述符是否可读&#x2F;可写的时候, 就可以采用I&#x2F;O多路复用模型.</p><h2 id="为什么都是与非阻塞I-O进行搭配-而不是与阻塞I-O进行搭配呢"><a href="#为什么都是与非阻塞I-O进行搭配-而不是与阻塞I-O进行搭配呢" class="headerlink" title="为什么都是与非阻塞I&#x2F;O进行搭配, 而不是与阻塞I&#x2F;O进行搭配呢?"></a>为什么都是与非阻塞I&#x2F;O进行搭配, 而不是与阻塞I&#x2F;O进行搭配呢?</h2><p>在第一个问题中, 我分别描述了 I&#x2F;O多路复用与非阻塞I&#x2F;O和阻塞I&#x2F;O的搭配使用, 但是有些基础的同学, 可能会想, 为什么我在网络上看到的都是说 I&#x2F;O多路复用与非阻塞I&#x2F;O进行搭配, 几乎没有说到和阻塞I&#x2F;O进行搭配的?</p><p>首先假设 此时 阻塞I&#x2F;O与I&#x2F;O多路复用搭配使用, 内核通知到我们说 这个阻塞 I&#x2F;O 可以读了, 我们就去读, 那这时候就有一个问题, 数据有多大, 我们要读多少次呢? 如果我们只读一次, 那效率又太低了, 如果我们读多次, 你怎么保证下一次读的时候, 一定不会阻塞呢? 要知道I&#x2F;O多路复用只保证你当前读了一次不阻塞, 不代表读多次不阻塞, 如果阻塞了, I&#x2F;O多路复用的机制就完全停住了, 因为程序一直阻塞在读中, 这就回退到了 阻塞I&#x2F;O的版本.</p><p>还有一个问题就是说, 内核通知你去读, 但是有可能被其他线程读走了, 然后你并不知道, 再去读 阻塞了, 这就是惊群现象.</p><p>而与非阻塞I&#x2F;O搭配, 没这么多烦恼, 反正我就一直读 读到返回 EWOULDBLOCK为止就是了, 反正不阻塞, 爱读多少读多少, 就算被别人拿走了, 我也不会阻塞.</p><p>可以看出 与非阻塞I&#x2F;O进行搭配确实可以减轻我们不少的烦恼啊.</p><p>再举两个例子</p><p>accept() 阻塞版 与 I&#x2F;O多路复用搭配, 内核通知我们可以 去建立一个连接, 但是如果服务器这时候很迟钝, 一直等到客户那边发送RST后才去连接, 这时候TCP会将客户的连接从队列中删除, 很明显 之后调用accept() 会发生阻塞.</p><p>connect() 阻塞版, 在调用之后 TCP完成三次握手前, 突然被中断了, 会直接返回 EINTR, 从中断服务例程回来之后, 是应该重新调用 connect() 吗? 显然是不行的 因为握手的过程还在继续, 只不过中途被中断了而已, 重新调用 connect() 如果对方已经接受连接, 则这一次connect会被拒绝, 返回 EADDRINUSE 错误, 只能通过 I&#x2F;O多路复用, 等连接建立成功时, 再返回套接字可写条件.</p><p>题外话, 如果建立连接的过程中被中断的话, 有以下几种做法</p><ol><li>你自己重启被中断的系统调用</li><li>对信号设置 SA_RESTART 属性, 让被中断的系统调用自行恢复</li><li>忽略信号</li></ol><h2 id="select-的-优缺点-及-内核实现"><a href="#select-的-优缺点-及-内核实现" class="headerlink" title="select 的 优缺点 及 内核实现"></a>select 的 优缺点 及 内核实现</h2><p>最多只支持到 1024个描述符, 不够用</p><h3 id="select-使用方法"><a href="#select-使用方法" class="headerlink" title="select 使用方法"></a>select 使用方法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> maxfd, fd_set *readset, fd_set *writeset, fd_set *exceptset, <span class="type">const</span> <span class="keyword">struct</span> timeval *timeout)</span>;</span><br></pre></td></tr></table></figure><ul><li>maxfd: 描述符数量</li><li>readset: 读描述符集合</li><li>writeset: 写描述符集合</li><li>exceptset: 异常描述符集合</li><li>timeout: 如果为NULL 表示一直等, 如果为0则不等立即返回, 如果非0则一直等到超时</li></ul><p>每次调用 select 都要重新覆盖 那三个集合, 因为监听的事件会改变着三个集合中的位, 此外, 每次返回的时候 如果select 不为0, 说明有事件发生, 如果想知道是哪个描述符的事件, 就要通过遍历 三个集合的内容, 来找到那个描述符.</p><h3 id="select-优缺点"><a href="#select-优缺点" class="headerlink" title="select 优缺点"></a>select 优缺点</h3><p>通过以上可知, 优点 实现简单.</p><p>缺点:</p><ol><li>只支持 1024 个文件描述符</li><li>每次都要给内核重新传递三个集合, 用户态拷贝到内核态 开销大</li><li>每次都要遍历三个集合, 才能知道是哪个文件描述符发送了事件, 而且因为是位图, 遍历还是用的线性遍历</li></ol><h3 id="select-内核实现"><a href="#select-内核实现" class="headerlink" title="select 内核实现"></a>select 内核实现</h3><p>就是一个简单的 bitmap</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FD_SETSIZE 1024 <span class="comment">// 可以看出 select 最多支持 1024个描述符</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NFDBITS (8 * sizeof(unsigned long))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __FDSET_LONGS (FD_SETSIZE/NFDBITS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 本质上就是一个 bitmap</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> fds_bits[__FDSET_LONGS];</span><br><span class="line">&#125; fd_set;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按位设置</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FD_SET(fd,fdsetp)	__FD_SET(fd,fdsetp)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FD_CLR(fd,fdsetp)	__FD_CLR(fd,fdsetp)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FD_ISSET(fd,fdsetp)	__FD_ISSET(fd,fdsetp)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FD_ZERO(fdsetp)		__FD_ZERO(fdsetp)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __FD_SET(fd, fdsetp) \</span></span><br><span class="line"><span class="meta">		(((fd_set *)(fdsetp))-&gt;fds_bits[(fd) &gt;&gt; 5] |= (1&lt;&lt;((fd) &amp; 31)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __FD_CLR(fd, fdsetp) \</span></span><br><span class="line"><span class="meta">		(((fd_set *)(fdsetp))-&gt;fds_bits[(fd) &gt;&gt; 5] &amp;= ~(1&lt;&lt;((fd) &amp; 31)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __FD_ISSET(fd, fdsetp) \</span></span><br><span class="line"><span class="meta">		((((fd_set *)(fdsetp))-&gt;fds_bits[(fd) &gt;&gt; 5] &amp; (1&lt;&lt;((fd) &amp; 31))) != 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __FD_ZERO(fdsetp) \</span></span><br><span class="line"><span class="meta">		(memset (fdsetp, 0, sizeof (*(fd_set *)(fdsetp))))</span></span><br></pre></td></tr></table></figure><p>SYSCALL_DEFINE5 ⇒ sys_select() 在这里</p><p>sys_select() 主要是对超时时间做处理, 从用户态copy到内核态, 然后将超时时间 转化为 纳秒</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE5(select, <span class="type">int</span>, n, fd_set __user *, inp, fd_set __user *, outp,</span><br><span class="line">        fd_set __user *, <span class="built_in">exp</span>, <span class="keyword">struct</span> timeval __user *, tvp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">end_time</span>, *<span class="title">to</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tvp) &#123;</span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(&amp;tv, tvp, <span class="keyword">sizeof</span>(tv)))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">        to = &amp;end_time;</span><br><span class="line">        <span class="keyword">if</span> (poll_select_set_timeout(to,</span><br><span class="line">                tv.tv_sec + (tv.tv_usec / USEC_PER_SEC),</span><br><span class="line">                (tv.tv_usec % USEC_PER_SEC) * NSEC_PER_USEC))</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ret = core_sys_select(n, inp, outp, <span class="built_in">exp</span>, to);</span><br><span class="line">    ret = poll_select_copy_remaining(&amp;end_time, tvp, <span class="number">1</span>, ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来调用 core_sys_select()</p><p>创建一个 256位 的数组, 然后获取当前进程的文件描述符表, 主要是做判断 不能让 select 监控的最大 文件描述符超过 该进程的文件描述符的上限, 接下来开辟空间 要开6个bitmap, in, out, ex 和其余三个对应的结果集合, 最后将其清空, 然后从用户态中拷贝到新创建的集合中, 调用 do_select() 去做真正的操作.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">core_sys_select</span><span class="params">(<span class="type">int</span> n, fd_set __user *inp, fd_set __user *outp,</span></span><br><span class="line"><span class="params">                 fd_set __user *<span class="built_in">exp</span>, <span class="keyword">struct</span> timespec *end_time)</span></span><br><span class="line">&#123;</span><br><span class="line">    fd_set_bits fds;</span><br><span class="line">    <span class="type">void</span> *bits;</span><br><span class="line">    <span class="type">int</span> ret, max_fds;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">fdt</span>;</span></span><br><span class="line"></span><br><span class="line">	  <span class="comment">// SELECT_STACK_ALLOC 为 256</span></span><br><span class="line">    <span class="type">long</span> stack_fds[SELECT_STACK_ALLOC/<span class="keyword">sizeof</span>(<span class="type">long</span>)];</span><br><span class="line"></span><br><span class="line">    rcu_read_lock();</span><br><span class="line">		<span class="comment">// 获取该进程的 文件描述符表</span></span><br><span class="line">    fdt = files_fdtable(current-&gt;files);</span><br><span class="line">    max_fds = fdt-&gt;max_fds;</span><br><span class="line">    rcu_read_unlock();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// select 可监控最大为 该进程的文件描述符的上限</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; max_fds)</span><br><span class="line">        n = max_fds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算在位图中表示n需要多少字节, (32 + n - 1 / 32) * 4</span></span><br><span class="line">    size = FDS_BYTES(n); </span><br><span class="line">    bits = stack_fds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6个 bitmap, in out ex, 和 三个对应的结果</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="keyword">sizeof</span>(stack_fds) / <span class="number">6</span>) &#123;</span><br><span class="line">        bits = kmalloc(<span class="number">6</span> * size, GFP_KERNEL);</span><br><span class="line">    &#125;</span><br><span class="line">    fds.in      = bits;</span><br><span class="line">    fds.out     = bits +   size;</span><br><span class="line">    fds.ex      = bits + <span class="number">2</span>*size;</span><br><span class="line">    fds.res_in  = bits + <span class="number">3</span>*size;</span><br><span class="line">    fds.res_out = bits + <span class="number">4</span>*size;</span><br><span class="line">    fds.res_ex  = bits + <span class="number">5</span>*size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把用户态的三个集合拷贝到内核态</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = get_fd_set(n, inp, fds.in)) ||</span><br><span class="line">            (ret = get_fd_set(n, outp, fds.out)) ||</span><br><span class="line">            (ret = get_fd_set(n, <span class="built_in">exp</span>, fds.ex)))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 清空结果集</span></span><br><span class="line">    zero_fd_set(n, fds.res_in);</span><br><span class="line">    zero_fd_set(n, fds.res_out);</span><br><span class="line">    zero_fd_set(n, fds.res_ex);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 真正去做 select 的函数</span></span><br><span class="line">    ret = do_select(n, &amp;fds, end_time);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">        ret = -ERESTARTNOHAND;</span><br><span class="line">        <span class="keyword">if</span> (signal_pending(current))</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将结果集 从内核态 拷贝到 用户态</span></span><br><span class="line">    <span class="keyword">if</span> (set_fd_set(n, inp, fds.res_in) ||</span><br><span class="line">            set_fd_set(n, outp, fds.res_out) ||</span><br><span class="line">            set_fd_set(n, <span class="built_in">exp</span>, fds.res_ex))</span><br><span class="line">        ret = -EFAULT;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">if</span> (bits != stack_fds)</span><br><span class="line">        kfree(bits);</span><br><span class="line">out_nofds:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>do_select()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">do_select</span><span class="params">(<span class="type">int</span> n, fd_set_bits *fds, <span class="keyword">struct</span> timespec *end_time)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ktime_t</span> expire, *to = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> <span class="title">table</span>;</span></span><br><span class="line">    poll_table *wait;</span><br><span class="line">    <span class="type">int</span> retval, i, timed_out = <span class="number">0</span>;</span><br><span class="line">    u64 slack = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    rcu_read_lock();</span><br><span class="line">    retval = max_select_fd(n, fds);</span><br><span class="line">    rcu_read_unlock();</span><br><span class="line">    n = retval;</span><br><span class="line"></span><br><span class="line">    poll_initwait(&amp;table);</span><br><span class="line">    wait = &amp;table.pt;</span><br><span class="line">    <span class="keyword">if</span> (end_time &amp;&amp; !end_time-&gt;tv_sec &amp;&amp; !end_time-&gt;tv_nsec) &#123;</span><br><span class="line">        wait-&gt;_qproc = <span class="literal">NULL</span>;</span><br><span class="line">        timed_out = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (end_time &amp;&amp; !timed_out)</span><br><span class="line">        slack = select_estimate_accuracy(end_time);</span><br><span class="line"></span><br><span class="line">    retval = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> *rinp, *routp, *rexp, *inp, *outp, *<span class="built_in">exp</span>;</span><br><span class="line">        <span class="type">bool</span> can_busy_loop = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        inp = fds-&gt;in; outp = fds-&gt;out; <span class="built_in">exp</span> = fds-&gt;ex;</span><br><span class="line">        rinp = fds-&gt;res_in; routp = fds-&gt;res_out; rexp = fds-&gt;res_ex;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++rinp, ++routp, ++rexp) &#123;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> in, out, ex, all_bits, bit = <span class="number">1</span>, mask, j;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> res_in = <span class="number">0</span>, res_out = <span class="number">0</span>, res_ex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            in = *inp++; out = *outp++; ex = *<span class="built_in">exp</span>++;</span><br><span class="line">            all_bits = in | out | ex;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (all_bits == <span class="number">0</span>) &#123;</span><br><span class="line">                i += BITS_PER_LONG;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; BITS_PER_LONG; ++j, ++i, bit &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt;= n)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (!(bit &amp; all_bits))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                f = fdget(i);</span><br><span class="line">                <span class="keyword">if</span> (f.file) &#123;</span><br><span class="line">                    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">f_op</span>;</span></span><br><span class="line">                    f_op = f.file-&gt;f_op;</span><br><span class="line">                    mask = DEFAULT_POLLMASK;</span><br><span class="line">                    <span class="keyword">if</span> (f_op-&gt;poll) &#123;</span><br><span class="line">                        wait_key_set(wait, in, out, bit, busy_flag);</span><br><span class="line">												<span class="comment">// 调用文件的 poll 操作</span></span><br><span class="line">                        mask = (*f_op-&gt;poll)(f.file, wait); </span><br><span class="line">                    &#125;</span><br><span class="line">                    fdput(f);</span><br><span class="line">                    <span class="comment">// 写入结果</span></span><br><span class="line">                    <span class="keyword">if</span> ((mask &amp; POLLIN_SET) &amp;&amp; (in &amp; bit)) &#123;</span><br><span class="line">                        res_in |= bit;</span><br><span class="line">                        retval++;</span><br><span class="line">                        wait-&gt;_qproc = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ((mask &amp; POLLOUT_SET) &amp;&amp; (out &amp; bit)) &#123;</span><br><span class="line">                        res_out |= bit;</span><br><span class="line">                        retval++;</span><br><span class="line">                        wait-&gt;_qproc = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ((mask &amp; POLLEX_SET) &amp;&amp; (ex &amp; bit)) &#123;</span><br><span class="line">                        res_ex |= bit;</span><br><span class="line">                        retval++;</span><br><span class="line">                        wait-&gt;_qproc = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 当返回值不为零，则停止循环轮询</span></span><br><span class="line">                    <span class="keyword">if</span> (retval) &#123;</span><br><span class="line">                        can_busy_loop = <span class="literal">false</span>; </span><br><span class="line">                        busy_flag = <span class="number">0</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (busy_flag &amp; mask)</span><br><span class="line">                        can_busy_loop = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (res_in)</span><br><span class="line">                *rinp = res_in;</span><br><span class="line">            <span class="keyword">if</span> (res_out)</span><br><span class="line">                *routp = res_out;</span><br><span class="line">            <span class="keyword">if</span> (res_ex)</span><br><span class="line">                *rexp = res_ex;</span><br><span class="line">            cond_resched(); <span class="comment">// 让出 CPU资源</span></span><br><span class="line">        &#125;</span><br><span class="line">        wait-&gt;_qproc = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 文件描述符准备就绪 超时 有信号 则退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (retval || timed_out || signal_pending(current))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (table.error) &#123;</span><br><span class="line">            retval = table.error;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (can_busy_loop &amp;&amp; !need_resched()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!busy_end) &#123;</span><br><span class="line">                busy_end = busy_loop_end_time();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!busy_loop_timeout(busy_end))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        busy_flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (end_time &amp;&amp; !to) &#123;</span><br><span class="line">            expire = timespec_to_ktime(*end_time);</span><br><span class="line">            to = &amp;expire;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!poll_schedule_timeout(&amp;table, TASK_INTERRUPTIBLE,</span><br><span class="line">                         to, slack))</span><br><span class="line">            timed_out = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    poll_freewait(&amp;table);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 do_select 主要遍历 集合, 通过集合中的文件描述符找到文件结构体, 然后调用 poll 函数, 最后将结果写入集合中, 比较蠢, 需要把集合中的全部扫一遍, 效率很低.</p><p>分三层遍历, 第一层死循环直到满足 超时, 文件描述符有监听事件发生, 中断, 第二层循环遍历文件描述符, 第三层遍历 集合中的每一个 bit.</p><ul><li>当有描述符发生所要监控的事件, 则会将其存下来, 返回到用户态</li><li>如果没有发生所要监控的事件, 如果已超时, 或者有待处理的信号, 也会回到用户态</li><li>即没有监控的事件, 又没有超时 或者 没有待处理的信号, 则会让出CPU, 等待被唤醒, 唤醒后再次进入循环</li></ul><p><code>mask = (*f_op-&gt;poll)(f.file, wait);</code></p><p>对于 socket 来说 应该是 sock_poll 会将当前进程 放入等待队列中(但并不是去睡眠), 等到这个 f_op 可读或可写时, 就会唤醒当前进程, 如果一直没人唤醒的话, 就会自己去睡眠, 并设置超时时间, 时间到了之后, 就会重新唤醒去重新遍历 fd.</p><h2 id="poll-的-优缺点-及-内核实现"><a href="#poll-的-优缺点-及-内核实现" class="headerlink" title="poll 的 优缺点 及 内核实现"></a>poll 的 优缺点 及 内核实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>    fd;       <span class="comment">/* file descriptor */</span> <span class="comment">// 如果 &lt; 0 则不监听</span></span><br><span class="line">    <span class="type">short</span>  events;   <span class="comment">/* events to look for */</span></span><br><span class="line">    <span class="type">short</span>  revents;  <span class="comment">/* events returned */</span></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于填写 events</span></span><br><span class="line"><span class="comment">// 可读事件</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLIN     0x0001    <span class="comment">/* any readable data available */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLPRI    0x0002    <span class="comment">/* OOB/Urgent readable data */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLRDNORM 0x0040    <span class="comment">/* non-OOB/URG data available */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLRDBAND 0x0080    <span class="comment">/* OOB/Urgent readable data */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可写事件</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLOUT    0x0004    <span class="comment">/* file descriptor is writeable */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLWRNORM POLLOUT   <span class="comment">/* no write type differentiation */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLWRBAND 0x0100    <span class="comment">/* OOB/Urgent data can be written */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 异常事件 这些异常事件并不需要自己显式的传入, 内核源码中会自动帮我们 | 上去</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLERR    0x0008    <span class="comment">/* 一些错误发送 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLHUP    0x0010    <span class="comment">/* 描述符挂起*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLNVAL   0x0020    <span class="comment">/* 请求的事件无效*/</span></span></span><br></pre></td></tr></table></figure><h3 id="poll-使用方法"><a href="#poll-使用方法" class="headerlink" title="poll 使用方法"></a>poll 使用方法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">unsigned</span> <span class="type">long</span> nfds, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure><ul><li>fds: 监听事件数组</li><li>nfds: fds有多大(突破了select 1024的限制)</li><li>timeout: 超时事件 &lt; 0 则一直等待, 0立即返回, &gt;0 到时再返回</li></ul><h3 id="poll-优缺点"><a href="#poll-优缺点" class="headerlink" title="poll 优缺点"></a>poll 优缺点</h3><p>优点自然是 解决了 select 1024个文件描述符的限制</p><p>缺点和 select 一样</p><ol><li>每次都要从用户态拷贝 pollfd数组到 内核态</li><li>寻找发生事件的描述符也是 和 select 一样 进行遍历, 线性扫描.</li></ol><h3 id="poll-内核实现"><a href="#poll-内核实现" class="headerlink" title="poll 内核实现"></a>poll 内核实现</h3><p>sys_poll()</p><p>可以看到 poll 的系统调用 和 select 类似 都是先设置好超时时间</p><p>然后调用 do_sys_poll()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(poll, <span class="keyword">struct</span> pollfd __user *, ufds, <span class="type">unsigned</span> <span class="type">int</span>, nfds,</span><br><span class="line">        <span class="type">int</span>, timeout_msecs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">end_time</span>, *<span class="title">to</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">		<span class="comment">// 老样子 如果有超时时间 先设置超时</span></span><br><span class="line">    <span class="keyword">if</span> (timeout_msecs &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        to = &amp;end_time;</span><br><span class="line">        poll_select_set_timeout(to, timeout_msecs / MSEC_PER_SEC,</span><br><span class="line">            NSEC_PER_MSEC * (timeout_msecs % MSEC_PER_SEC));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = do_sys_poll(ufds, nfds, to);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret == -EINTR) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">restart_block</span> *<span class="title">restart_block</span>;</span></span><br><span class="line"></span><br><span class="line">        restart_block = &amp;current-&gt;restart_block;</span><br><span class="line">        restart_block-&gt;fn = do_restart_poll;</span><br><span class="line">        restart_block-&gt;poll.ufds = ufds;</span><br><span class="line">        restart_block-&gt;poll.nfds = nfds;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timeout_msecs &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            restart_block-&gt;poll.tv_sec = end_time.tv_sec;</span><br><span class="line">            restart_block-&gt;poll.tv_nsec = end_time.tv_nsec;</span><br><span class="line">            restart_block-&gt;poll.has_timeout = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            restart_block-&gt;poll.has_timeout = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        ret = -ERESTART_RESTARTBLOCK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>do_sys_poll()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">do_sys_poll</span><span class="params">(<span class="keyword">struct</span> pollfd __user *ufds, <span class="type">unsigned</span> <span class="type">int</span> nfds,</span></span><br><span class="line"><span class="params">        <span class="keyword">struct</span> timespec *end_time)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> <span class="title">table</span>;</span></span><br><span class="line">    <span class="type">int</span> err = -EFAULT, fdcount, len, size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建大小为256bit 的数组</span></span><br><span class="line">    <span class="type">long</span> stack_pps[POLL_STACK_ALLOC/<span class="keyword">sizeof</span>(<span class="type">long</span>)];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_list</span> *<span class="title">const</span> <span class="title">head</span> =</span> (<span class="keyword">struct</span> poll_list *)stack_pps;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">poll_list</span> *<span class="title">walk</span> =</span> head;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> todo = nfds;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 上限默认为1024 (ulimit -n)</span></span><br><span class="line">    <span class="keyword">if</span> (nfds &gt; rlimit(RLIMIT_NOFILE))</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    len = <span class="type">min_t</span>(<span class="type">unsigned</span> <span class="type">int</span>, nfds, N_STACK_PPS);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 这个循环 负责将用户态的数据拷贝到内核态</span></span><br><span class="line">		<span class="comment">// 可见 select 和 poll的 性能开销大多用在了 内核和用户态的相互拷贝上</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        walk-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        walk-&gt;len = len;</span><br><span class="line">        <span class="keyword">if</span> (!len)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(walk-&gt;entries, ufds + nfds-todo,</span><br><span class="line">                    <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pollfd) * walk-&gt;len))</span><br><span class="line">            <span class="keyword">goto</span> out_fds;</span><br><span class="line"></span><br><span class="line">        todo -= walk-&gt;len;</span><br><span class="line">        <span class="keyword">if</span> (!todo)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        len = min(todo, POLLFD_PER_PAGE);</span><br><span class="line">        size = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> poll_list) + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pollfd) * len;</span><br><span class="line">        walk = walk-&gt;next = kmalloc(size, GFP_KERNEL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 真正去做 do_poll()</span></span><br><span class="line">    poll_initwait(&amp;table);</span><br><span class="line">    fdcount = do_poll(nfds, head, &amp;table, end_time);</span><br><span class="line">    poll_freewait(&amp;table);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 将结果拷贝回用户态</span></span><br><span class="line">    <span class="keyword">for</span> (walk = head; walk; walk = walk-&gt;next) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> *<span class="title">fds</span> =</span> walk-&gt;entries;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; walk-&gt;len; j++, ufds++)</span><br><span class="line">            <span class="keyword">if</span> (__put_user(fds[j].revents, &amp;ufds-&gt;revents))</span><br><span class="line">                <span class="keyword">goto</span> out_fds;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    err = fdcount;</span><br><span class="line">out_fds:</span><br><span class="line">    walk = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (walk) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">poll_list</span> *<span class="title">pos</span> =</span> walk;</span><br><span class="line">        walk = walk-&gt;next;</span><br><span class="line">        kfree(pos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>do_poll()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_poll</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> nfds,  <span class="keyword">struct</span> poll_list *<span class="built_in">list</span>,</span></span><br><span class="line"><span class="params">           <span class="keyword">struct</span> poll_wqueues *wait, <span class="keyword">struct</span> timespec *end_time)</span></span><br><span class="line">&#123;</span><br><span class="line">    poll_table* pt = &amp;wait-&gt;pt;</span><br><span class="line">    <span class="type">ktime_t</span> expire, *to = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> timed_out = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">    u64 slack = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> busy_flag = net_busy_loop_on() ? POLL_BUSY_LOOP : <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> busy_end = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (end_time &amp;&amp; !end_time-&gt;tv_sec &amp;&amp; !end_time-&gt;tv_nsec) &#123;</span><br><span class="line">        pt-&gt;_qproc = <span class="literal">NULL</span>;</span><br><span class="line">        timed_out = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (end_time &amp;&amp; !timed_out)</span><br><span class="line">        slack = select_estimate_accuracy(end_time);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">poll_list</span> *<span class="title">walk</span>;</span></span><br><span class="line">        <span class="type">bool</span> can_busy_loop = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (walk = <span class="built_in">list</span>; walk != <span class="literal">NULL</span>; walk = walk-&gt;next) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> * <span class="title">pfd</span>, * <span class="title">pfd_end</span>;</span></span><br><span class="line"></span><br><span class="line">            pfd = walk-&gt;entries;</span><br><span class="line">            pfd_end = pfd + walk-&gt;len;</span><br><span class="line">            <span class="keyword">for</span> (; pfd != pfd_end; pfd++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (do_pollfd(pfd, pt, &amp;can_busy_loop,</span><br><span class="line">                          busy_flag)) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    pt-&gt;_qproc = <span class="literal">NULL</span>;</span><br><span class="line">                    busy_flag = <span class="number">0</span>;</span><br><span class="line">                    can_busy_loop = <span class="literal">false</span>; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pt-&gt;_qproc = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (!count) &#123;</span><br><span class="line">            count = wait-&gt;error;</span><br><span class="line">            <span class="keyword">if</span> (signal_pending(current))</span><br><span class="line">                count = -EINTR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count || timed_out)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (can_busy_loop &amp;&amp; !need_resched()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!busy_end) &#123;</span><br><span class="line">                busy_end = busy_loop_end_time();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!busy_loop_timeout(busy_end))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        busy_flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (end_time &amp;&amp; !to) &#123;</span><br><span class="line">            expire = timespec_to_ktime(*end_time);</span><br><span class="line">            to = &amp;expire;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!poll_schedule_timeout(wait, TASK_INTERRUPTIBLE, to, slack))</span><br><span class="line">            timed_out = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 又是通过 fd 找到 file 然后调用 file 的 poll 接口 将当前进程放入睡眠队列, 如果可读/可写</span></span><br><span class="line"><span class="comment">// 就唤醒当前进程, 要注意 这里放入睡眠队列不是说立刻进入睡眠</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">do_pollfd</span><span class="params">(<span class="keyword">struct</span> pollfd *pollfd, </span></span><br><span class="line"><span class="params">                     poll_table *pwait,</span></span><br><span class="line"><span class="params">                     <span class="type">bool</span> *can_busy_poll,</span></span><br><span class="line"><span class="params">                     <span class="type">unsigned</span> <span class="type">int</span> busy_flag)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> mask;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line">    mask = <span class="number">0</span>;</span><br><span class="line">    fd = pollfd-&gt;fd;</span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span> =</span> fdget(fd);</span><br><span class="line">        mask = POLLNVAL;</span><br><span class="line">        <span class="keyword">if</span> (f.file) &#123;</span><br><span class="line">            mask = DEFAULT_POLLMASK;</span><br><span class="line">            <span class="keyword">if</span> (f.file-&gt;f_op-&gt;poll) &#123;</span><br><span class="line">                pwait-&gt;_key = pollfd-&gt;events|POLLERR|POLLHUP;</span><br><span class="line">                pwait-&gt;_key |= busy_flag;</span><br><span class="line">                mask = f.file-&gt;f_op-&gt;poll(f.file, pwait);</span><br><span class="line">                <span class="keyword">if</span> (mask &amp; busy_flag)</span><br><span class="line">                    *can_busy_poll = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mask &amp;= pollfd-&gt;events | POLLERR | POLLHUP;</span><br><span class="line">            fdput(f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pollfd-&gt;revents = mask;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>和 select 类似 来个无限循环, 然后 遍历 用户传进来的数组, 对数组中的文件描述符 进行 poll操作, 一样会将当前进程放入等待队列, 当文件描述符所代表的”文件”可读或者可写就会唤醒等待队列的进程, 最后将其放入 revents, 拷贝回用户态. 如果一直没有 文件可读或者可写, 就和select一样, 开个定时器, 让自己睡过去, 直到超时.</p><p>离开无限循环的条件 1. 有新事件 2. 超时, 3. 有信号发生, 发生中断</p><h2 id="epoll-的-优缺点-及-内核实现"><a href="#epoll-的-优缺点-及-内核实现" class="headerlink" title="epoll 的 优缺点 及 内核实现"></a>epoll 的 优缺点 及 内核实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">     <span class="type">void</span>        *ptr;</span><br><span class="line">     <span class="type">int</span>          fd;</span><br><span class="line">     <span class="type">uint32_t</span>     u32;</span><br><span class="line">     <span class="type">uint64_t</span>     u64;</span><br><span class="line"> &#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">     <span class="type">uint32_t</span>     events;      <span class="comment">/* Epoll events */</span></span><br><span class="line">     <span class="type">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>这里的 events 和 poll的 一样, 此外 epoll_data 中一般只用 fd.</p><h3 id="epoll-使用方法"><a href="#epoll-使用方法" class="headerlink" title="epoll 使用方法"></a>epoll 使用方法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line"><span class="comment">// size 在 Linux 2.6.8 之后没用了, 但是还是要填写一个 大于 0 的数值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create1</span><span class="params">(<span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="comment">// 创建 epollfd 可增加 额外选项</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br></pre></td></tr></table></figure><ul><li>epfd 就是 epoll_create 的返回值</li><li>op 就是 operator 操作<ul><li>EPOLL_CTL_ADD: 向 epoll 注册文件描述符的事件</li><li>EPOLL_CTL_DEL: 向 epoll 删除文件描述符的事件</li><li>EPOLL_CTL_MOD: 修改文件描述符的事件</li></ul></li><li>fd 监听的文件描述符</li><li>event 监听事件类型 和 用户自定义信息(大部分时候只放 fd)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure><ul><li>events: 数组 返回需要处理的I&#x2F;O事件</li><li>maxevents: 可以返回的最大事件值</li><li>timeout -1 不超时, 0 立即返回</li></ul><h3 id="条件触发-水平触发-与-边缘触发"><a href="#条件触发-水平触发-与-边缘触发" class="headerlink" title="条件触发(水平触发) 与 边缘触发"></a>条件触发(水平触发) 与 边缘触发</h3><p>通过设置 event | EPOLLET 设置为 边缘触发, 默认为水平触发.</p><p>用一句话来解释就是 条件触发的话 只要缓冲区有东西 就一直 从 epoll_wait 中提醒, 而边缘触发 只有在第一次 满足条件的时候才触发, 因此 边缘触发的效率比水平触发高, 不过 边缘触发的代码就不是很好写了.</p><p>题外话: select 和 poll 都是水平触发的模式.</p><h3 id="epoll-内核实现"><a href="#epoll-内核实现" class="headerlink" title="epoll 内核实现"></a>epoll 内核实现</h3><h4 id="sys-epoll-create"><a href="#sys-epoll-create" class="headerlink" title="sys_epoll_create()"></a>sys_epoll_create()</h4><p>epoll_create 会创建 匿名文件 和 文件描述符 同时将其绑定起来, 而且会将 该匿名文件 存入 eventpoll 结构体当中, 方便通过 epollfd 来找到 eventpoll 实例.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE1(epoll_create, <span class="type">int</span>, size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="keyword">return</span> sys_epoll_create1(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE1(epoll_create1, <span class="type">int</span>, flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error, fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 eventpoll</span></span><br><span class="line">    error = ep_alloc(&amp;ep);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 找没用过的 fd</span></span><br><span class="line">    fd = get_unused_fd_flags(O_RDWR | (flags &amp; O_CLOEXEC));</span><br><span class="line">	  <span class="comment">// 创建 匿名文件 实例, 会将 eventpoll 存入 file 中的 private_data</span></span><br><span class="line">		<span class="comment">// 方便快速定位 到 eventpoll 对象</span></span><br><span class="line">    file = anon_inode_getfile(<span class="string">&quot;[eventpoll]&quot;</span>, &amp;eventpoll_fops, ep,</span><br><span class="line">                 O_RDWR | (flags &amp; O_CLOEXEC));</span><br><span class="line"></span><br><span class="line">    ep-&gt;file = file;</span><br><span class="line">		<span class="comment">// 将 fd 和 epoll 实例关联</span></span><br><span class="line">    fd_install(fd, file);</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line"></span><br><span class="line">out_free_fd:</span><br><span class="line">    put_unused_fd(fd);</span><br><span class="line">out_free_ep:</span><br><span class="line">    ep_free(ep);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ep_alloc</span><span class="params">(<span class="keyword">struct</span> eventpoll **pep)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line">    user = get_current_user();</span><br><span class="line">    error = -ENOMEM;</span><br><span class="line">    ep = kzalloc(<span class="keyword">sizeof</span>(*ep), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    spin_lock_init(&amp;ep-&gt;lock);</span><br><span class="line">    mutex_init(&amp;ep-&gt;mtx);</span><br><span class="line">    init_waitqueue_head(&amp;ep-&gt;wq); <span class="comment">// 执行 epoll_wait 而等待的进程队列</span></span><br><span class="line">    init_waitqueue_head(&amp;ep-&gt;poll_wait); <span class="comment">// eventloop 文件等待队列(epoll本身就是个文件)</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;ep-&gt;rdllist);</span><br><span class="line">    ep-&gt;rbr = RB_ROOT;</span><br><span class="line">    ep-&gt;ovflist = EP_UNACTIVE_PTR;</span><br><span class="line">    ep-&gt;user = user;</span><br><span class="line">    *pep = ep;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">free_uid:</span><br><span class="line">    free_uid(user);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This structure is stored inside the &quot;private_data&quot; member of the file</span></span><br><span class="line"><span class="comment"> * structure and represents the main data structure for the eventpoll</span></span><br><span class="line"><span class="comment"> * interface.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Protect the access to this structure */</span></span><br><span class="line">    <span class="type">spinlock_t</span> lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mtx</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait queue used by sys_epoll_wait() */</span></span><br><span class="line">    <span class="comment">//这个队列里存放的是执行epoll_wait从而等待的进程队列</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> wq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait queue used by file-&gt;poll() */</span></span><br><span class="line">		<span class="comment">// eventloop 文件等待队列(epoll本身就是个文件)</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> poll_wait;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* List of ready file descriptors */</span></span><br><span class="line">    <span class="comment">// 这里存放的是事件就绪的fd列表 链表的每个元素是下面的epitem</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* RB tree root used to store monitored fd structs */</span></span><br><span class="line">    <span class="comment">// 红黑树 用来查找 fd</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root_cached</span> <span class="title">rbr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This is a single linked list that chains all the &quot;struct epitem&quot; that</span></span><br><span class="line"><span class="comment">     * happened while transferring ready events to userspace w/out</span></span><br><span class="line"><span class="comment">     * holding -&gt;lock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">ovflist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* wakeup_source used when ep_scan_ready_list is running */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">wakeup_source</span> *<span class="title">ws</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The user that created the eventpoll descriptor */</span></span><br><span class="line">		<span class="comment">// 描述 创建 epoll 的用户</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// epoll 实例文件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* used to optimize loop detection check */</span></span><br><span class="line">    <span class="type">int</span> visited;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">visited_list_link</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其实就是 红黑树的 一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rbn</span>;</span> <span class="comment">// RB树节点将此结构链接到eventpoll RB树</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span> <span class="comment">// 用于释放epitem</span></span><br><span class="line">    &#125;;</span><br><span class="line">		<span class="comment">// 将这个eptiem连接到 eventpoll的 rdllist 的 list指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllink</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">next</span>;</span></span><br><span class="line">		<span class="comment">// epoll 监听的fd</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span> <span class="title">ffd</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 一个文件被多个epoll实例监听时的监听数目</span></span><br><span class="line">    <span class="type">int</span> nwait;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">pwqlist</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span>  <span class="comment">// epitem 所属的 eventpoll</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">fllink</span>;</span> <span class="comment">// 链接到file条目列表的列表头</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">wakeup_source</span> __<span class="title">rcu</span> *<span class="title">ws</span>;</span> <span class="comment">// 设置EPOLLWAKEUP时使用的wakeup_source</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span> <span class="comment">// 监控的事件和文件描述符</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    __u32 events;</span><br><span class="line">    __u64 data;</span><br><span class="line">&#125; EPOLL_PACKED;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">&#125; __packed;</span><br></pre></td></tr></table></figure><h4 id="sys-epoll-ctl"><a href="#sys-epoll-ctl" class="headerlink" title="sys_epoll_ctl()"></a>sys_epoll_ctl()</h4><p>先是根据 epollfd 来找到 匿名文件, 即 epoll 实例, 接着获取真正的 文件(fd传进来的), 然后取出 epoll,</p><p>接着 在红黑树中 找这个 fd.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE4(epoll_ctl, <span class="type">int</span>, epfd, <span class="type">int</span>, op, <span class="type">int</span>, fd,</span><br><span class="line">        <span class="keyword">struct</span> epoll_event __user *, event)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line">    <span class="type">int</span> full_check = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>, <span class="title">tf</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epds</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">tep</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    error = -EFAULT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ep_op_has_event(op) &amp;&amp;</span><br><span class="line">        copy_from_user(&amp;epds, event, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> epoll_event)))</span><br><span class="line"></span><br><span class="line">    f = fdget(epfd);</span><br><span class="line">    tf = fdget(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!tf.file-&gt;f_op-&gt;poll)</span><br><span class="line">        <span class="keyword">goto</span> error_tgt_fput;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ep_op_has_event(op))</span><br><span class="line">        ep_take_care_of_epollwakeup(&amp;epds);</span><br><span class="line"></span><br><span class="line">    ep = f.file-&gt;private_data; <span class="comment">// 取出epoll_create过程创建的eventpoll</span></span><br><span class="line"></span><br><span class="line">    mutex_lock_nested(&amp;ep-&gt;mtx, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    epi = ep_find(ep, tf.file, fd); <span class="comment">// 红黑树中 找 该 fd</span></span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="keyword">case</span> EPOLL_CTL_ADD:</span><br><span class="line">        <span class="keyword">if</span> (!epi) &#123;</span><br><span class="line">						<span class="comment">// 快看, 这里会自动 把 POLLERR 和 POLLHUP 带上 因此不需要显式传入</span></span><br><span class="line">            epds.events |= POLLERR | POLLHUP;</span><br><span class="line">            error = ep_insert(ep, &amp;epds, tf.file, fd, full_check);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (full_check)</span><br><span class="line">            clear_tfile_check_list();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> EPOLL_CTL_DEL:</span><br><span class="line">        <span class="keyword">if</span> (epi)</span><br><span class="line">            error = ep_remove(ep, epi);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> EPOLL_CTL_MOD:</span><br><span class="line">        <span class="keyword">if</span> (epi) &#123;</span><br><span class="line">            epds.events |= POLLERR | POLLHUP;</span><br><span class="line">            error = ep_modify(ep, epi, &amp;epds);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_unlock(&amp;ep-&gt;mtx);</span><br><span class="line">    fdput(tf);</span><br><span class="line">    fdput(f);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>epi &#x3D; ep_find(ep, tf.file, fd);</p><p>红黑树的 排序规则 采用 文件地址排序, 如果相同 就按照文件描述符进行排序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span> <span class="comment">// pointer to the target file struct corresponding to the fd</span></span><br><span class="line">  <span class="type">int</span> fd; <span class="comment">// target file descriptor number</span></span><br><span class="line">&#125; __packed;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Compare RB tree keys */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">ep_cmp_ffd</span><span class="params">(<span class="keyword">struct</span> epoll_filefd *p1,</span></span><br><span class="line"><span class="params">                            <span class="keyword">struct</span> epoll_filefd *p2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (p1-&gt;file &gt; p2-&gt;file ? +<span class="number">1</span>:</span><br><span class="line">       (p1-&gt;file &lt; p2-&gt;file ? <span class="number">-1</span> : p1-&gt;fd - p2-&gt;fd));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ep_insert()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ep_insert</span><span class="params">(<span class="keyword">struct</span> eventpoll *ep, <span class="keyword">struct</span> epoll_event *event,</span></span><br><span class="line"><span class="params">             <span class="keyword">struct</span> file *tfile, <span class="type">int</span> fd, <span class="type">int</span> full_check)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error, revents, pwake = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="type">long</span> user_watches;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ep_pqueue</span> <span class="title">epq</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 判断 当前监控的文件值 是否超过了 /proc/sys/fs/epoll/max_user_watches 的预设最大值</span></span><br><span class="line">    user_watches = atomic_long_read(&amp;ep-&gt;user-&gt;epoll_watches);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(user_watches &gt;= max_user_watches))</span><br><span class="line">        <span class="keyword">return</span> -ENOSPC;</span><br><span class="line">    <span class="keyword">if</span> (!(epi = kmem_cache_alloc(epi_cache, GFP_KERNEL)))</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;epi-&gt;rdllink);</span><br><span class="line">    INIT_LIST_HEAD(&amp;epi-&gt;fllink);</span><br><span class="line">    INIT_LIST_HEAD(&amp;epi-&gt;pwqlist);</span><br><span class="line">    epi-&gt;ep = ep;</span><br><span class="line">    ep_set_ffd(&amp;epi-&gt;ffd, tfile, fd); <span class="comment">// 将tfile和fd都赋值给ffd</span></span><br><span class="line">    epi-&gt;event = *event;</span><br><span class="line">    epi-&gt;nwait = <span class="number">0</span>;</span><br><span class="line">    epi-&gt;next = EP_UNACTIVE_PTR;</span><br><span class="line">    <span class="keyword">if</span> (epi-&gt;event.events &amp; EPOLLWAKEUP) &#123;</span><br><span class="line">        error = ep_create_wakeup_source(epi);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        RCU_INIT_POINTER(epi-&gt;ws, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    epq.epi = epi;</span><br><span class="line">    <span class="comment">// 设置轮询的回调函数</span></span><br><span class="line">    init_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc);</span><br><span class="line">		<span class="comment">// ep_ptable_queue_proc -&gt; 会去设置回调函数 ep_poll_callback</span></span><br><span class="line">		<span class="comment">// 当有事件发生的时候 就会调用这个函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行poll方法</span></span><br><span class="line">    revents = ep_item_poll(epi, &amp;epq.pt);</span><br><span class="line"></span><br><span class="line">    spin_lock(&amp;tfile-&gt;f_lock);</span><br><span class="line">    list_add_tail_rcu(&amp;epi-&gt;fllink, &amp;tfile-&gt;f_ep_links);</span><br><span class="line">    spin_unlock(&amp;tfile-&gt;f_lock);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将创建的epi添加到RB树</span></span><br><span class="line">    ep_rbtree_insert(ep, epi); </span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="comment">// 监听事件就绪 并且 epi的就绪队列有数据</span></span><br><span class="line">    <span class="keyword">if</span> ((revents &amp; event-&gt;events) &amp;&amp; !ep_is_linked(&amp;epi-&gt;rdllink)) &#123;</span><br><span class="line">        list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">        ep_pm_stay_awake(epi);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 唤醒调用epoll_wait的进程</span></span><br><span class="line">        <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line">            wake_up_locked(&amp;ep-&gt;wq);</span><br><span class="line">        <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))</span><br><span class="line">            pwake++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line">    atomic_long_inc(&amp;ep-&gt;user-&gt;epoll_watches);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pwake)</span><br><span class="line">        ep_poll_safewake(&amp;ep-&gt;poll_wait); <span class="comment">// 唤醒等待eventpoll文件就绪的进程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ep_poll_callback()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ep_poll_callback</span><span class="params">(<span class="type">wait_queue_t</span> *wait, <span class="type">unsigned</span> mode, <span class="type">int</span> sync, <span class="type">void</span> *key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pwake = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span> =</span> ep_item_from_wait(wait);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span> =</span> epi-&gt;ep;</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(ep-&gt;ovflist != EP_UNACTIVE_PTR)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (epi-&gt;next == EP_UNACTIVE_PTR) &#123;</span><br><span class="line">            epi-&gt;next = ep-&gt;ovflist;</span><br><span class="line">            ep-&gt;ovflist = epi;</span><br><span class="line">            <span class="keyword">if</span> (epi-&gt;ws) &#123;</span><br><span class="line">                __pm_stay_awake(ep-&gt;ws);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件发生 但不在已完成队列 就放进去</span></span><br><span class="line">    <span class="keyword">if</span> (!ep_is_linked(&amp;epi-&gt;rdllink)) &#123;</span><br><span class="line">        <span class="comment">// 将epi就绪事件 插入到ep就绪队列</span></span><br><span class="line">        list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">        ep_pm_stay_awake_rcu(epi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒 eventpoll上的等待进程</span></span><br><span class="line">    <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line">				<span class="comment">// 当队列不为空，则唤醒进程</span></span><br><span class="line">        wake_up_locked(&amp;ep-&gt;wq);</span><br><span class="line">    <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))</span><br><span class="line">        pwake++;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line">    <span class="keyword">if</span> (pwake)</span><br><span class="line">        ep_poll_safewake(&amp;ep-&gt;poll_wait);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)key &amp; POLLFREE) &#123;</span><br><span class="line">        list_del_init(&amp;wait-&gt;task_list);</span><br><span class="line">        smp_store_release(&amp;ep_pwq_from_wait(wait)-&gt;whead, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="sys-epoll-wait"><a href="#sys-epoll-wait" class="headerlink" title="sys_epoll_wait()"></a>sys_epoll_wait()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE4(epoll_wait, <span class="type">int</span>, epfd, <span class="keyword">struct</span> epoll_event __user *, events,</span><br><span class="line">        <span class="type">int</span>, maxevents, <span class="type">int</span>, timeout)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (maxevents &lt;= <span class="number">0</span> || maxevents &gt; EP_MAX_EVENTS)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!access_ok(VERIFY_WRITE, events, maxevents * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> epoll_event)))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">    f = fdget(epfd);  <span class="comment">// 获取 epollfd 对应的文件</span></span><br><span class="line">    ep = f.file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    ****error = ep_poll(ep, events, maxevents, timeout);</span><br><span class="line"></span><br><span class="line">error_fput:</span><br><span class="line">    fdput(f);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ep_poll</span><span class="params">(<span class="keyword">struct</span> eventpoll *ep, <span class="keyword">struct</span> epoll_event __user *events,</span></span><br><span class="line"><span class="params">           <span class="type">int</span> maxevents, <span class="type">long</span> timeout)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, eavail, timed_out = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="type">long</span> slack = <span class="number">0</span>;</span><br><span class="line">    <span class="type">wait_queue_t</span> wait;</span><br><span class="line">    <span class="type">ktime_t</span> expires, *to = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">end_time</span> =</span> ep_set_mstimeout(timeout);</span><br><span class="line">        slack = select_estimate_accuracy(&amp;end_time);</span><br><span class="line">        to = &amp;expires;</span><br><span class="line">        *to = timespec_to_ktime(end_time);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// timeout 等于0为非阻塞 直接跳过去</span></span><br><span class="line">        timed_out = <span class="number">1</span>;</span><br><span class="line">        spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">        <span class="keyword">goto</span> check_events;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">fetch_events:</span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ep_events_available(ep)) &#123;</span><br><span class="line">        <span class="comment">// 没有事件就绪则进入睡眠状态，当事件就绪后可通过ep_poll_callback()来唤醒</span></span><br><span class="line">        <span class="comment">// 将当前进程放入wait等待队列</span></span><br><span class="line">        init_waitqueue_entry(&amp;wait, current);</span><br><span class="line">        <span class="comment">// 将当前进程加入eventpoll等待队列，等待文件就绪、超时或中断信号</span></span><br><span class="line">        __add_wait_queue_exclusive(&amp;ep-&gt;wq, &amp;wait);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">						<span class="comment">// 有就绪事件 或者 超时 或者有信号 则退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (ep_events_available(ep) || timed_out)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line">                res = -EINTR;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line">            <span class="comment">// 让出 CPU 进入睡眠</span></span><br><span class="line">            <span class="keyword">if</span> (!freezable_schedule_hrtimeout_range(to, slack,</span><br><span class="line">                                HRTIMER_MODE_ABS))</span><br><span class="line">                timed_out = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">// 被唤醒 将当前进程从等待队列中删除</span></span><br><span class="line">        __remove_wait_queue(&amp;ep-&gt;wq, &amp;wait);</span><br><span class="line">				<span class="comment">// 设置当前进程状态</span></span><br><span class="line">        set_current_state(TASK_RUNNING);</span><br><span class="line">    &#125;</span><br><span class="line">check_events:</span><br><span class="line">    eavail = ep_events_available(ep);</span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将就绪事件传到 用户态</span></span><br><span class="line">    <span class="keyword">if</span> (!res &amp;&amp; eavail &amp;&amp;</span><br><span class="line">        !(res = ep_send_events(ep, events, maxevents)) &amp;&amp; !timed_out)</span><br><span class="line">        <span class="keyword">goto</span> fetch_events;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ep_send_events() 还会在里面再次检测是否真的就绪, 因为很有可能在窗口时间(就是处理的过程中) 被用户处理掉.</p><h3 id="LT-与-ET-是怎么实现的"><a href="#LT-与-ET-是怎么实现的" class="headerlink" title="LT 与 ET 是怎么实现的?"></a>LT 与 ET 是怎么实现的?</h3><p>其实很简单, 如果是 LT 的话, 每次 处理完 都将 epoll_item 重新加入 eventpoll 就绪队列中, 这样就能再次被重新处理.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过以上洗礼, 我们可以得出结论, epoll 效率比 select 或者 poll 高的原因是, 因为, 它内部采用了红黑树 来存储 事件, 这样就不需要每次都从 用户态拷贝到内核态 节约了一层的性能开销.</p><p>此外, 红黑树能用来快速搜索 fd, fd 又直接关联 eventpoll 对象, 可以直接将 fd加入到 eventpoll的就绪队列中, 不用像 select 或者 poll 一样, 发生了事件, 傻傻的去遍历 到底是哪个 fd 发生了事件.</p><p>同时, 返回给用户的事件的方式又有很大改善, select 和 poll 一股脑全反回去, 你还要自己进行遍历, 筛选掉很多没用的事件, 而 epoll 则不同, 它直接给你发生了事件的, 没发生事件的不给你, 省的你去遍历, 以上三层, 奠定了 epoll 在 I&#x2F;O多路复用中的地位.</p></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Linux/" rel="tag"># Linux</a> <a href="/tags/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" rel="tag"># 系统编程</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" rel="tag"># 网络编程</a> <a href="/tags/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" rel="tag"># I/O多路复用</a> <a href="/tags/epoll/" rel="tag"># epoll</a> <a href="/tags/select/" rel="tag"># select</a> <a href="/tags/poll/" rel="tag"># poll</a></div><div class="post-nav"><div class="post-nav-item"><a href="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B(%E4%B8%80)%E4%B9%8B%E6%97%B6%E9%97%B4%E7%BC%96%E7%A8%8B/" rel="prev" title="Linux系统编程(一) 之时间编程"><i class="fa fa-angle-left"></i> Linux系统编程(一) 之时间编程</a></div><div class="post-nav-item"><a href="/SkipList-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%9C%A8%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/" rel="next" title="SkipList 原理及在游戏排行榜中的应用">SkipList 原理及在游戏排行榜中的应用 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Yuerer</span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://unpkg.com/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://unpkg.com/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/comments.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/utils.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/motion.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/sidebar.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/next-boot.min.js"></script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://yuerer-comment-xufei-0bea01e6f05-1307930306.ap-shanghai.app.tcloudbase.com","cssUrl":"https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.css","commentCount":true,"pageview":true,"libUrl":"https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.js","locale":{"placeholder":"有何高见？"},"emoji":["https://unpkg.com/@waline/emojis@1.0.1/qq"],"meta":["nick","mail"],"requiredMeta":[["nick","mail"]],"wordLimit":0,"login":"disable","pageSize":10,"el":"#waline","comment":true,"path":"/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"}</script><link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.css"><script>document.addEventListener("page:loaded",()=>{NexT.utils.loadComments(CONFIG.waline.el).then(()=>NexT.utils.getScript(CONFIG.waline.libUrl,{condition:window.Waline})).then(()=>Waline.init(Object.assign({},CONFIG.waline,{el:document.querySelector(CONFIG.waline.el)})))})</script></body></html>