<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.jpeg"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.ico"><link rel="mask-icon" href="/images/avatar.jpeg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous"><link rel="stylesheet" href="https://unpkg.com/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"yuerer.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"hide","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":true,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/config.min.js"></script><meta name="description" content="x86 特权级 (Privilege Levels) RING 0(内核)  RING 1(服务)  RING 2(服务)  RING 3(应用程序)  当前操作系统 一般只用到了 RING 0 和 RING 3 比如 Linux在访问数据段 页表 进入中断服务例程 (ISRs) CPU 会检查特权级 x86 特权级检查失败会提示 General Protection Fault 一般保护错误"><meta property="og:type" content="article"><meta property="og:title" content="操作系统 uCore Lab 2"><meta property="og:url" content="https://yuerer.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-uCore-Lab-2/index.html"><meta property="og:site_name" content="Yuerer&#39;s Blog"><meta property="og:description" content="x86 特权级 (Privilege Levels) RING 0(内核)  RING 1(服务)  RING 2(服务)  RING 3(应用程序)  当前操作系统 一般只用到了 RING 0 和 RING 3 比如 Linux在访问数据段 页表 进入中断服务例程 (ISRs) CPU 会检查特权级 x86 特权级检查失败会提示 General Protection Fault 一般保护错误"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://yuerer.com/images/segmentregister.png"><meta property="og:image" content="https://yuerer.com/images/segmentdescriptor.png"><meta property="og:image" content="https://yuerer.com/images/interruptgate.png"><meta property="og:image" content="https://yuerer.com/images/ring0toring3.png"><meta property="og:image" content="https://yuerer.com/images/ring3toring0.png"><meta property="og:image" content="https://yuerer.com/images/tss.png"><meta property="og:image" content="https://yuerer.com/images/segment_based.png"><meta property="og:image" content="https://yuerer.com/images/coarsepagetable.png"><meta property="og:image" content="https://yuerer.com/images/pagetableentries.png"><meta property="og:image" content="https://yuerer.com/images/lab2_ex.2.png"><meta property="og:image" content="https://yuerer.com/images/lab2_ex.3.png"><meta property="og:image" content="https://yuerer.com/images/lab2_finish.png"><meta property="article:published_time" content="2018-11-19T06:24:20.000Z"><meta property="article:modified_time" content="2025-10-21T13:50:52.268Z"><meta property="article:author" content="Yuerer"><meta property="article:tag" content="内存分配"><meta property="article:tag" content="操作系统"><meta property="article:tag" content="uCore"><meta property="article:tag" content="Lab"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://yuerer.com/images/segmentregister.png"><link rel="canonical" href="https://yuerer.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-uCore-Lab-2/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://yuerer.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-uCore-Lab-2/","path":"操作系统-uCore-Lab-2/","title":"操作系统 uCore Lab 2"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>操作系统 uCore Lab 2 | Yuerer's Blog</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-129491388-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-129491388-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/third-party/analytics/google-analytics.min.js"></script><link rel="dns-prefetch" href="https://yuerer-comment-xufei-0bea01e6f05-1307930306.ap-shanghai.app.tcloudbase.com"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Yuerer's Blog</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">钰儿的Blog</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#x86-%E7%89%B9%E6%9D%83%E7%BA%A7-Privilege-Levels"><span class="nav-text">x86 特权级 (Privilege Levels)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#x86-%E7%89%B9%E6%9D%83%E7%BA%A7%E6%A3%80%E6%9F%A5%E5%A4%B1%E8%B4%A5"><span class="nav-text">x86 特权级检查失败</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#x86-%E7%89%B9%E6%9D%83%E7%BA%A7%E6%A3%80%E6%9F%A5"><span class="nav-text">x86 特权级检查</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#x86-%E9%80%9A%E8%BF%87%E4%B8%AD%E6%96%AD%E5%88%87%E6%8D%A2%E7%89%B9%E6%9D%83%E7%BA%A7"><span class="nav-text">x86 通过中断切换特权级</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#RING-0-to-RING-3"><span class="nav-text">RING 0 to RING 3</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RING-3-to-RING-0"><span class="nav-text">RING 3 to RING 0</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TSS-%E4%BB%BB%E5%8A%A1%E7%8A%B6%E6%80%81%E6%AE%B5-Task-State-Segment"><span class="nav-text">TSS 任务状态段 (Task State Segment)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#x86-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8D%95%E5%85%83-MMU"><span class="nav-text">x86 内存管理单元 MMU</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AE%B5%E6%9C%BA%E5%88%B6"><span class="nav-text">段机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%B5%E6%9C%BA%E5%88%B6"><span class="nav-text">页机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%BC%80%E5%90%AF%E9%A1%B5%E6%9C%BA%E5%88%B6"><span class="nav-text">如何开启页机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AE%B5%E6%9C%BA%E5%88%B6%E5%92%8C%E9%A1%B5%E6%9C%BA%E5%88%B6%E9%83%BD%E8%83%BD%E4%BD%9C%E4%B8%BA%E6%98%A0%E5%B0%84%E6%9C%BA%E5%88%B6-%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9"><span class="nav-text">段机制和页机制都能作为映射机制 应该如何选择?</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80-%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80-%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80-%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80-%E6%9C%89%E6%95%88%E5%9C%B0%E5%9D%80-%E5%8C%BA%E5%88%AB"><span class="nav-text">线性地址 虚拟地址 逻辑地址 物理地址 有效地址 区别</span></a></li></ol></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#Ucore-Lab-2"><span class="nav-text">Ucore Lab 2</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%83%E4%B9%A00-%E5%A1%AB%E5%86%99%E5%B7%B2%E6%9C%89%E5%AE%9E%E9%AA%8C"><span class="nav-text">练习0: 填写已有实验</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E"><span class="nav-text">补充说明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#int-0x15-0xE820-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E6%8E%A2%E6%B5%8B"><span class="nav-text">int 0x15 0xE820 物理内存探测</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E6%89%A7%E8%A1%8C%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E5%9B%9B%E9%98%B6%E6%AE%B5"><span class="nav-text">系统执行中的地址映射四阶段</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%83%E4%B9%A01-%E5%AE%9E%E7%8E%B0-first-fit-%E8%BF%9E%E7%BB%AD%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="nav-text">练习1: 实现 first-fit 连续物理内存分配算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%83%E4%B9%A02%EF%BC%9A%E5%AE%9E%E7%8E%B0%E5%AF%BB%E6%89%BE%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%AF%B9%E5%BA%94%E7%9A%84%E9%A1%B5%E8%A1%A8%E9%A1%B9"><span class="nav-text">练习2：实现寻找虚拟地址对应的页表项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%83%E4%B9%A03%EF%BC%9A%E9%87%8A%E6%94%BE%E6%9F%90%E8%99%9A%E5%9C%B0%E5%9D%80%E6%89%80%E5%9C%A8%E7%9A%84%E9%A1%B5%E5%B9%B6%E5%8F%96%E6%B6%88%E5%AF%B9%E5%BA%94%E4%BA%8C%E7%BA%A7%E9%A1%B5%E8%A1%A8%E9%A1%B9%E7%9A%84%E6%98%A0%E5%B0%84"><span class="nav-text">练习3：释放某虚地址所在的页并取消对应二级页表项的映射</span></a></li></ol></li></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Yuerer" src="/images/avatar.jpeg"><p class="site-author-name" itemprop="name">Yuerer</p><div class="site-description" itemprop="description">钰儿的Blog</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">65</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">16</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">90</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/Yu2erer" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Yu2erer" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:yu2erer#gmail.com" title="E-Mail → mailto:yu2erer#gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://yuerer.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-uCore-Lab-2/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpeg"><meta itemprop="name" content="Yuerer"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Yuerer's Blog"><meta itemprop="description" content="钰儿的Blog"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="操作系统 uCore Lab 2 | Yuerer's Blog"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">操作系统 uCore Lab 2</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-11-19 14:24:20" itemprop="dateCreated datePublished" datetime="2018-11-19T14:24:20+08:00">2018-11-19</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a> </span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Waline：</span> <a title="waline" href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-uCore-Lab-2/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-uCore-Lab-2/" itemprop="commentCount"></span> </a></span><span class="post-meta-item" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="waline-pageview-count" data-path="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-uCore-Lab-2/"></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h3 id="x86-特权级-Privilege-Levels"><a href="#x86-特权级-Privilege-Levels" class="headerlink" title="x86 特权级 (Privilege Levels)"></a>x86 特权级 (Privilege Levels)</h3><ul><li>RING 0(内核)</li><li>RING 1(服务)</li><li>RING 2(服务)</li><li>RING 3(应用程序)</li></ul><p>当前操作系统 一般只用到了 RING 0 和 RING 3 比如 Linux<br>在访问数据段 页表 进入中断服务例程 (ISRs) CPU 会检查特权级</p><h4 id="x86-特权级检查失败"><a href="#x86-特权级检查失败" class="headerlink" title="x86 特权级检查失败"></a>x86 特权级检查失败</h4><p>会提示 General Protection Fault 一般保护错误</p><span id="more"></span><h4 id="x86-特权级检查"><a href="#x86-特权级检查" class="headerlink" title="x86 特权级检查"></a>x86 特权级检查</h4><p>RPL 请求特权级 DS ES GS FS 数据段</p><p>CPL 当前特权级 存在于 CS &#x2F; SS 的低2位</p><p><img data-src="/images/segmentregister.png"></p><p>DPL 段或者门的特权级</p><p><img data-src="/images/segmentdescriptor.png"></p><p>访问门时 CPL &lt;&#x3D; DPL[门] &amp;&amp; CPL &gt;&#x3D; DPL[段]<br>访问段时 MAX(CPL, RPL) &lt;&#x3D; DPL[段]</p><h4 id="x86-通过中断切换特权级"><a href="#x86-通过中断切换特权级" class="headerlink" title="x86 通过中断切换特权级"></a>x86 通过中断切换特权级</h4><p>首先在中断描述符表里 建立好 中断门 来实现中断切换特权级</p><p><img data-src="/images/interruptgate.png"></p><h5 id="RING-0-to-RING-3"><a href="#RING-0-to-RING-3" class="headerlink" title="RING 0 to RING 3"></a>RING 0 to RING 3</h5><p>当 ring 0 内核态发生中断的时候 首先因为发生中断的时候还是在 ring 0 所以不会将 ss esp 压入堆栈中 只会压入 Eflags cs eip 和 中断错误码</p><p>因此 为了实现从 ring 0 到 ring 3 的特权级转换 将其 ss 改成特权级3的栈 cs 改为用户代码段 最后通过 IRET 将这些信息 POP 出栈 此时 运行环境就进入了用户态中了</p><p><img data-src="/images/ring0toring3.png"></p><h5 id="RING-3-to-RING-0"><a href="#RING-3-to-RING-0" class="headerlink" title="RING 3 to RING 0"></a>RING 3 to RING 0</h5><p>当 ring 3 用户态发生中断时 会将 ss esp 压入堆栈中 这是为了 跳出中断的时候 还能返回到这个用户态中 但是我们是为了实现 从 ring 3 到 ring 0 的特权级转换<br>因此 ss esp 是不需要的 将它们给去掉 同时将 cs 改为 内核态代码段 最后 还是 通过 IRET 将这些信息 POP 出栈 就回到了 ring 0 内核态中</p><p><img data-src="/images/ring3toring0.png"></p><h5 id="TSS-任务状态段-Task-State-Segment"><a href="#TSS-任务状态段-Task-State-Segment" class="headerlink" title="TSS 任务状态段 (Task State Segment)"></a>TSS 任务状态段 (Task State Segment)</h5><p>TSS 的位置 可以从 全局描述符表 中的 任务状态描述符 (Task State Descriptor) 中找到</p><p>因为 IDT 中断描述符表 中的 中断门 有 代码段选择子 可以用它作为索引从 GDT 全局描述符表中 找到实际的代码段的内存地址 但是 ss 和 esp 是不存在于 中断门中的<br>它们 存在于 TSS 中. TR(Task Register) 寄存器会缓存 TSS 从而实现 任务的切换</p><p><img data-src="/images/tss.png"></p><p>tss 在里面 只会保存 ring 0 ~ ring 2 的 ss 和 esp 之所以不保存 ring 3 的 ss 和 esp 是因为 CPU 默认只支持 从低特权级跳到高特权级 而 ring 3 是最低的特权级 不会有其他的特权级跳过去了 因此 不保存 ring 3 的 ss 和 esp</p><h4 id="x86-内存管理单元-MMU"><a href="#x86-内存管理单元-MMU" class="headerlink" title="x86 内存管理单元 MMU"></a>x86 内存管理单元 MMU</h4><h5 id="段机制"><a href="#段机制" class="headerlink" title="段机制"></a>段机制</h5><p>首先通过段选择子作为索引 在 GDT 全局描述符表中找到 段描述符 若没启动页机制的话 那么现在就找到 线性地址</p><p><img data-src="/images/segment_based.png"></p><p>GDT 存在于内存当中 因为它所占空间比较大 但是由于内存比较慢 每次去访问 段表的时候 耗费比较大 因此 硬件会将 GDT 中的描述信息(Base Address, Limit…) 放在 CPU 来加快段的映射过程</p><h5 id="页机制"><a href="#页机制" class="headerlink" title="页机制"></a>页机制</h5><ol><li>线性地址 的 高十位 + cr3 中的 PDE 页目标表的地址 找到 PTE 页表的 物理地址</li><li>PTE 页表物理地址+ 线性地址中间 10位 找到 物理页基址</li><li>物理页基址 加上 线性地址的 低 12位 找到物理地址</li></ol><p><img data-src="/images/coarsepagetable.png"></p><p>页目录表项和页表项的高20位为物理页表地址&#x2F;物理页地址 之所以只用到 20 位 是因为页是以 4K 为单位 地址都是 4K的倍数 后面12位都为 0 所以 可以将多余的 12 位用作属性位</p><ul><li>AVL CPU 不理会这个属性 可以不管 (有可能在32位系统使用大过 4G内存的时候 用到这几位)</li><li>G Global 全局位 表示是否将虚拟地址与物理地址的转换结果缓存到 TLB 中</li><li>D Dirty 脏页位 当 CPU 对这个页进行写操作时 会置 1</li><li>PAT Page Attribute Table 页属性表位 置 0</li><li>A Accessed 访问位 若为 1 则 说明 CPU 访问过了 CPU 会定时清 0 记录被置 1 的频率 当内存不足时 会将 使用频率较低的页面换出到外存 同时将 P位 置 0 下次访问 该页时 会引起 Pagefault 异常 中断处理程序再将此页换上</li><li>PCD Page-level Cache Disable 页级高速缓存位 置 0 即可 读的时候 高速缓存是否有效 若有效则直接从高速缓存中读出 若无效的话 则必须实实在在的从 I&#x2F;O 端口去读数据</li><li>PWT Page-level Write-Through 页级通写位 控制是先写到高速缓存里再慢慢回写到内存里 还是 直接慢慢写到内存里</li><li>US User&#x2F;Superviosr 普通用户&#x2F;超级用户位</li><li>RW Read&#x2F;Write 读写位</li><li>P Present 存在位 (虚拟页式存储的关键位 若为 0 则发起缺页异常)</li></ul><p><img data-src="/images/pagetableentries.png"></p><h5 id="如何开启页机制"><a href="#如何开启页机制" class="headerlink" title="如何开启页机制"></a>如何开启页机制</h5><ol><li>准备好页目录表和页表</li><li>页目录表物理地址 写入 cr3 寄存器</li><li>cr0 最高位 PG位 置 1</li></ol><h5 id="段机制和页机制都能作为映射机制-应该如何选择"><a href="#段机制和页机制都能作为映射机制-应该如何选择" class="headerlink" title="段机制和页机制都能作为映射机制 应该如何选择?"></a>段机制和页机制都能作为映射机制 应该如何选择?</h5><p>选择页机制有助于硬件机制对其进行有效的处理</p><p>使用段机制的安全保护手段 来保护系统的安全 但是弱化了 段机制的映射 使用页机制的映射</p><p>段机制和页机制结合成段页式的存储管理 从而 既能便于程序的共享和保护 又能高效率利用存储空间</p><h4 id="线性地址-虚拟地址-逻辑地址-物理地址-有效地址-区别"><a href="#线性地址-虚拟地址-逻辑地址-物理地址-有效地址-区别" class="headerlink" title="线性地址 虚拟地址 逻辑地址 物理地址 有效地址 区别"></a>线性地址 虚拟地址 逻辑地址 物理地址 有效地址 区别</h4><ul><li>保护模式 段基址+段偏移 &#x3D; 线性地址 若不开分页 &#x3D;&#x3D; 物理地址</li><li>实模式&#x2F;保护模式 段偏移 &#x3D; 有效地址 也称 逻辑地址</li><li>开启分页后 线性地址 &#x3D;&#x3D; 虚拟地址</li></ul><h2 id="Ucore-Lab-2"><a href="#Ucore-Lab-2" class="headerlink" title="Ucore Lab 2"></a>Ucore Lab 2</h2><h3 id="练习0-填写已有实验"><a href="#练习0-填写已有实验" class="headerlink" title="练习0: 填写已有实验"></a>练习0: 填写已有实验</h3><p>本实验依赖实验1。请把你做的实验1的代码填入本实验中代码中有“LAB1”的注释相应部分。提示：可采用diff和patch工具进行半自动的合并（merge），也可用一些图形化的比较&#x2F;merge工具来手动合并，比如meld，eclipse中的diff&#x2F;merge工具，understand中的diff&#x2F;merge工具等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">其实 就 kdebug.c init.c(Lab 1 Challenge 可以不管) trap.c 这三个文件自己复制粘贴下完事</span><br></pre></td></tr></table></figure><h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><h4 id="int-0x15-0xE820-物理内存探测"><a href="#int-0x15-0xE820-物理内存探测" class="headerlink" title="int 0x15 0xE820 物理内存探测"></a>int 0x15 0xE820 物理内存探测</h4><p>首先 Lab 2 我们知道是要实现连续物理内存的分配 那么就要知道 我们的物理内存有多少<br>Linux 采用 实模式下 int 0x15 中断来探测 物理内存的大小 它 和 ucore 不同的是 Linux 通过三种不同的方法来获取 物理内存大小 分别是<br>(E820h E801h 88h) 功能依次减弱 当一种方法不能使用时 则采用更弱的一种方法去获取 而 ucore 直接采用最强大的 E820h 方法 来获取物理内存</p><p>下面是通过中断将物理内存信息 存放到 0x8000 的代码实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">e820map</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> nr_map;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> addr;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> size;</span><br><span class="line">        <span class="type">long</span> type;</span><br><span class="line">    &#125; <span class="built_in">map</span>[E820MAX];</span><br><span class="line">&#125;;</span><br><span class="line">probe_memory:</span><br><span class="line"><span class="comment">//对0x8000处的32位单元清零,即给位于0x8000处的</span></span><br><span class="line"><span class="comment">//struct e820map的成员变量nr_map清零</span></span><br><span class="line">                  movl $<span class="number">0</span>, <span class="number">0x8000</span></span><br><span class="line">                  xorl %ebx, %ebx</span><br><span class="line"><span class="comment">//表示设置调用INT 15h BIOS中断后，BIOS返回的映射地址描述符的起始地址</span></span><br><span class="line">                  movw $<span class="number">0x8004</span>, %di</span><br><span class="line">start_probe:</span><br><span class="line">                  movl $<span class="number">0xE820</span>, %eax <span class="comment">// INT 15的中断调用参数</span></span><br><span class="line"><span class="comment">//设置地址范围描述符的大小为20字节，其大小等于struct e820map的成员变量map的大小</span></span><br><span class="line">                  movl $<span class="number">20</span>, %ecx</span><br><span class="line"><span class="comment">//设置edx为534D4150h (即4个ASCII字符“SMAP”)，这是一个约定</span></span><br><span class="line">                  movl $SMAP, %edx</span><br><span class="line"><span class="comment">//调用int 0x15中断，要求BIOS返回一个用地址范围描述符表示的内存段信息</span></span><br><span class="line">                  <span class="type">int</span> $<span class="number">0x15</span></span><br><span class="line"><span class="comment">//如果eflags的CF位为0，则表示还有内存段需要探测</span></span><br><span class="line">                  jnc cont</span><br><span class="line"><span class="comment">//探测有问题，结束探测</span></span><br><span class="line">                  movw $<span class="number">12345</span>, <span class="number">0x8000</span> <span class="comment">// 12345 这个数是给 ucore 检测错误用的</span></span><br><span class="line">                  jmp finish_probe</span><br><span class="line">cont:</span><br><span class="line"><span class="comment">//设置下一个BIOS返回的映射地址描述符的起始地址</span></span><br><span class="line">                  addw $<span class="number">20</span>, %di</span><br><span class="line"><span class="comment">//递增struct e820map的成员变量nr_map</span></span><br><span class="line">                  incl <span class="number">0x8000</span></span><br><span class="line"><span class="comment">//如果INT0x15返回的ebx为零，表示探测结束，否则继续探测</span></span><br><span class="line">                  cmpl $<span class="number">0</span>, %ebx</span><br><span class="line">                  jnz start_probe</span><br><span class="line">finish_probe:</span><br></pre></td></tr></table></figure><h4 id="系统执行中的地址映射四阶段"><a href="#系统执行中的地址映射四阶段" class="headerlink" title="系统执行中的地址映射四阶段"></a>系统执行中的地址映射四阶段</h4><p>第一阶段 bootloader 阶段 也就是此时 kernel 还没有载入 从bootloader的start函数（在boot&#x2F;bootasm.S中）到执行ucore kernel的kern_\entry函数之前 和 Lab 1一样</p><p><code>virt addr = linear addr = phy addr</code></p><p>第二阶段 从kern_\entry函数开始，到执行enable_page函数（在kern&#x2F;mm&#x2F;pmm.c中）之前再次更新了段映射，还没有启动页映射机制 而 Lab 2 通过 ld 工具将 ucore 起始内核虚拟地址设置为了 0xC0100000 但其实际 物理内存地址仍是 0x100000(换句话说就是 我链接的 ucore的内核虚拟地址 是假设开了分页后的特意算好的地址 但是我进入内核的时候 还没有开好分页 所以只能从段机制上做文章 也就是让段的起始地址 从 -0xc0000000开始) 为了使ucore正确运行 映射关系应为</p><p><code>virt addr - 0xC0000000 = linear addr = phy addr</code></p><p>第三阶段 从enable_page函数开始，到执行gdt_init函数（在kern&#x2F;mm&#x2F;pmm.c中）之前，启动了页映射机制 然而之前第二阶段的段机制还没有修改<br>此时的映射关系为</p><p><code>virt addr = linear addr + 0xC0000000 = phy addr + 2 * 0xC0000000</code></p><p>这肯定是错的 我们想要的 映射 应该是</p><p><code>virt addr = linear addr + 0xC0000000 = phy addr + 0xC0000000</code></p><p>ucore 采用一个小技巧 就是建立临时的页映射 线性地址 0xC0000000<del>0xC0400000(4MB) 映射到物理地址 0x00000000</del>0x00400000(4MB) 按照我们想要的映射关系映射 4MB 之外的内存地址 依然保留错误的映射关系 但也足够了 因为 ucore 的内核大小也就 3MB</p><p>第四阶段 可喜可贺 从gdt_init函数开始 此时重设了 GDT 的段起始地址 又改回了 0 然后再将第三阶段的临时 映射关系给取消了 终于得到了想要的 映射关系</p><p><code>virt addr = linear addr = phy addr + 0xC0000000</code></p><h3 id="练习1-实现-first-fit-连续物理内存分配算法"><a href="#练习1-实现-first-fit-连续物理内存分配算法" class="headerlink" title="练习1: 实现 first-fit 连续物理内存分配算法"></a>练习1: 实现 first-fit 连续物理内存分配算法</h3><p>在实现first fit 内存分配算法的回收函数时，要考虑地址连续的空闲块之间的合并操作。提示:在建立空闲页块链表时，需要按照空闲页块起始地址来排序，形成一个有序的链表。可能会修改default_pmm.c中的default_init，default_init_memmap，default_alloc_pages， default_free_pages等相关函数。请仔细查看和理解default_pmm.c中的注释。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> &#123;</span></span><br><span class="line">    <span class="comment">// 页帧的 引用计数</span></span><br><span class="line">    <span class="type">int</span> ref;</span><br><span class="line">    <span class="comment">// 页帧的状态 Reserve 表示是否被内核保留 另一个是 表示是否 可分配</span></span><br><span class="line">    <span class="type">uint32_t</span> flags;</span><br><span class="line">    <span class="comment">// 记录连续空闲页块的数量 只在第一块进行设置</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> property;</span><br><span class="line">    <span class="comment">// 用于将所有的页帧串在一个双向链表中 这个地方很有趣 直接将 Page 这个结构体加入链表中会有点浪费空间 因此在 Page 中设置一个链表的结点 将其结点加入到链表中 还原的方法是将 链表中的 page_link 的地址 减去它所在的结构体中的偏移 就得到了 Page 的起始地址</span></span><br><span class="line">    <span class="type">list_entry_t</span> page_link;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化空闲页块链表</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">default_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    list_init(&amp;free_list);</span><br><span class="line">    nr_free = <span class="number">0</span>; <span class="comment">// 空闲页块一开始是0个</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化n个空闲页块</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">default_init_memmap</span><span class="params">(<span class="keyword">struct</span> Page *base, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">    assert(n &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> =</span> base;</span><br><span class="line">    <span class="keyword">for</span> (; p != base + n; p ++) &#123;</span><br><span class="line">        assert(PageReserved(p)); <span class="comment">// 看看这个页是不是被内核保留的</span></span><br><span class="line">        p-&gt;flags = p-&gt;property = <span class="number">0</span>;</span><br><span class="line">        set_page_ref(p, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    base-&gt;property = n; <span class="comment">// 头一个空闲页块 要设置数量</span></span><br><span class="line">    SetPageProperty(base);</span><br><span class="line">    nr_free += n;</span><br><span class="line">    <span class="comment">// 初始化玩每个空闲页后 将其要插入到链表每次都插入到节点前面 因为是按地址排序</span></span><br><span class="line">    list_add_before(&amp;free_list, &amp;(base-&gt;page_link));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 分配n个页块</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> Page * <span class="title function_">default_alloc_pages</span><span class="params">(<span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">    assert(n &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (n &gt; nr_free) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">list_entry_t</span> *le = &amp;free_list;</span><br><span class="line">    <span class="comment">// 查找 n 个或以上 空闲页块 若找到 则判断是否大过 n 则将其拆分 并将拆分后的剩下的空闲页块加回到链表中</span></span><br><span class="line">    <span class="keyword">while</span> ((le = list_next(le)) != &amp;free_list) &#123;</span><br><span class="line">        <span class="comment">// 此处 le2page 就是将 le 的地址 - page_link 在 Page 的偏移 从而找到 Page 的地址</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> =</span> le2page(le, page_link);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;property &gt;= n) &#123;</span><br><span class="line">            page = p;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (page != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (page-&gt;property &gt; n) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> =</span> page + n;</span><br><span class="line">            p-&gt;property = page-&gt;property - n;</span><br><span class="line">            SetPageProperty(p);</span><br><span class="line">            <span class="comment">// 将多出来的插入到 被分配掉的页块 后面</span></span><br><span class="line">            list_add(&amp;(page-&gt;page_link), &amp;(p-&gt;page_link));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后在空闲页链表中删除掉原来的空闲页</span></span><br><span class="line">        list_del(&amp;(page-&gt;page_link));</span><br><span class="line">        nr_free -= n;</span><br><span class="line">        ClearPageProperty(page);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放掉 n 个 页块</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">default_free_pages</span><span class="params">(<span class="keyword">struct</span> Page *base, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">    assert(n &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> =</span> base;</span><br><span class="line">    <span class="keyword">for</span> (; p != base + n; p ++) &#123;</span><br><span class="line">        assert(!PageReserved(p) &amp;&amp; !PageProperty(p));</span><br><span class="line">        p-&gt;flags = <span class="number">0</span>;</span><br><span class="line">        set_page_ref(p, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    base-&gt;property = n;</span><br><span class="line">    SetPageProperty(base);</span><br><span class="line">    <span class="type">list_entry_t</span> *le = list_next(&amp;free_list);</span><br><span class="line">    <span class="comment">// 合并到合适的页块中</span></span><br><span class="line">    <span class="keyword">while</span> (le != &amp;free_list) &#123;</span><br><span class="line">        p = le2page(le, page_link);</span><br><span class="line">        le = list_next(le);</span><br><span class="line">        <span class="keyword">if</span> (base + base-&gt;property == p) &#123;</span><br><span class="line">            base-&gt;property += p-&gt;property;</span><br><span class="line">            ClearPageProperty(p);</span><br><span class="line">            list_del(&amp;(p-&gt;page_link));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p + p-&gt;property == base) &#123;</span><br><span class="line">            p-&gt;property += base-&gt;property;</span><br><span class="line">            ClearPageProperty(base);</span><br><span class="line">            base = p;</span><br><span class="line">            list_del(&amp;(p-&gt;page_link));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nr_free += n;</span><br><span class="line">    le = list_next(&amp;free_list);</span><br><span class="line">    <span class="comment">// 将合并好的合适的页块添加回空闲页块链表</span></span><br><span class="line">    <span class="keyword">while</span> (le != &amp;free_list) &#123;</span><br><span class="line">        p = le2page(le, page_link);</span><br><span class="line">        <span class="keyword">if</span> (base + base-&gt;property &lt;= p) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        le = list_next(le);</span><br><span class="line">    &#125;</span><br><span class="line">    list_add_before(le, &amp;(base-&gt;page_link));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请在实验报告中简要说明你的设计实现过程。请回答如下问题：</p><ul><li>你的first fit算法是否有进一步的改进空间</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以像 Buddy System 用树来管理空闲页块 搜索的时间复杂度 为 O(logn)</span><br></pre></td></tr></table></figure><h3 id="练习2：实现寻找虚拟地址对应的页表项"><a href="#练习2：实现寻找虚拟地址对应的页表项" class="headerlink" title="练习2：实现寻找虚拟地址对应的页表项"></a>练习2：实现寻找虚拟地址对应的页表项</h3><p>通过设置页表和对应的页表项，可建立虚拟内存地址和物理内存地址的对应关系。其中的get_pte函数是设置页表项环节中的一个重要步骤。此函数找到一个虚地址对应的二级页表项的内核虚地址，如果此二级页表项不存在，则分配一个包含此项的二级页表。本练习需要补全get_pte函数 in kern&#x2F;mm&#x2F;pmm.c，实现其功能。请仔细查看和理解get_pte函数中的注释。get_pte函数的调用关系图如下所示：</p><p><img data-src="/images/lab2_ex.2.png"></p><p>这道题和下面一道题比较简单<br>原理就是 给我一个虚拟地址 然后我根据这个虚拟地址 的 高 10 位 找到 页目录表 中的 PDE项 前20位是页表项 (二级页表)的线性地址 后 12位 为属性 然后 判断一下 PDE 是否存在(就是判断 P位) 不存在 则 获取一个物理页 然后将这个物理页的线性地址写入到 PDE 中 最后返回 PTE 项<br>换句话说 就是 根据 给的 虚拟地址 构造一个 PTE 项 跟着注释来很容易就解决了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pte_t</span> *<span class="title function_">get_pte</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">uintptr_t</span> la, <span class="type">bool</span> create)</span> &#123;</span><br><span class="line">    <span class="type">pde_t</span> *pdep = &amp;pgdir[PDX(la)]; <span class="comment">// 找到 PDE 这里的 pgdir 可以看做是 页目录表的基址</span></span><br><span class="line">    <span class="keyword">if</span> (!(*pdep &amp; PTE_P)) &#123;         <span class="comment">// 看看 PDE 指向的页表 是否存在</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span>* <span class="title">page</span> =</span> alloc_page(); <span class="comment">// 不存在就申请一页物理页</span></span><br><span class="line">        <span class="comment">/* 这里说多几句 通过 default_alloc_pages() 分配的页 的地址 并不是真正的页分配的地址</span></span><br><span class="line"><span class="comment">            实际上只是 Page 这个结构体所在的地址而已 故而需要 通过使用 page2pa() 将 Page 这个结构体</span></span><br><span class="line"><span class="comment">            的地址 转换成真正的物理页地址的线性地址 然后需要注意的是 无论是 * 或是 memset 都是对虚拟地址进行操作的</span></span><br><span class="line"><span class="comment">            所以需要将 真正的物理页地址再转换成 内核虚拟地址</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        <span class="keyword">if</span> (!create || page == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        set_page_ref(page, <span class="number">1</span>);</span><br><span class="line">        <span class="type">uintptr_t</span> pa = page2pa(page);</span><br><span class="line">        <span class="built_in">memset</span>(KADDR(pa), <span class="number">0</span>, PGSIZE); <span class="comment">// 将这一页清空 此时将 线性地址转换为内核虚拟地址</span></span><br><span class="line">        *pdep = pa | PTE_U | PTE_W | PTE_P; <span class="comment">// 设置 PDE 权限</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;((<span class="type">pte_t</span> *)KADDR(PDE_ADDR(*pdep)))[PTX(la)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请在实验报告中简要说明你的设计实现过程。请回答如下问题：</p><ul><li>请描述页目录项（Page Directory Entry）和页表项（Page Table Entry）中每个组成部分的含义以及对ucore而言的潜在用处。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PDE 和 PTE 的组成部分含义在上面</span><br></pre></td></tr></table></figure><ul><li>如果ucore执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">进行换页操作 首先 CPU 将产生页访问异常的线性地址 放到 cr2 寄存器中 </span><br><span class="line">然后就是和普通的中断一样 保护现场 将寄存器的值压入栈中 </span><br><span class="line">然后压入 error_code 中断服务例程将外存的数据换到内存中来 </span><br><span class="line">最后 退出中断 回到进入中断前的状态</span><br></pre></td></tr></table></figure><h3 id="练习3：释放某虚地址所在的页并取消对应二级页表项的映射"><a href="#练习3：释放某虚地址所在的页并取消对应二级页表项的映射" class="headerlink" title="练习3：释放某虚地址所在的页并取消对应二级页表项的映射"></a>练习3：释放某虚地址所在的页并取消对应二级页表项的映射</h3><p>当释放一个包含某虚地址的物理内存页时，需要让对应此物理内存页的管理数据结构Page做相关的清除处理，使得此物理内存页成为空闲；另外还需把表示虚地址与物理地址对应关系的二级页表项清除。请仔细查看和理解page_remove_pte函数中的注释。为此，需要补全在 kern&#x2F;mm&#x2F;pmm.c中的page_remove_pte函数。page_remove_pte函数的调用关系图如下所示：</p><p><img data-src="/images/lab2_ex.3.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">page_remove_pte</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">uintptr_t</span> la, <span class="type">pte_t</span> *ptep)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((*ptep &amp; PTE_P)) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> =</span> pte2page(*ptep);</span><br><span class="line">        <span class="keyword">if</span> (page_ref_dec(page) == <span class="number">0</span>) &#123; <span class="comment">// 若引用计数减一后为0 则释放该物理页</span></span><br><span class="line">            free_page(page);</span><br><span class="line">        &#125;</span><br><span class="line">        *ptep = <span class="number">0</span>; <span class="comment">// 清空 PTE</span></span><br><span class="line">        tlb_invalidate(pgdir, la); <span class="comment">// 刷新 tlb</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后测试一下是不是都通过了</p><p><img data-src="/images/lab2_finish.png" alt="lab2_finish"></p><p>请在实验报告中简要说明你的设计实现过程。请回答如下问题：</p><ul><li>数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？</li><li>如果希望虚拟地址与物理地址相等，则需要如何修改lab2，完成此事？ 鼓励通过编程来具体完成这个问题</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有 比如 PG_reserved 这个表示的这个页是否被内核保留 与 页表项的 PTE_U 这个参数有关系</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kern/mm/memlayout.h</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERNBASE 0x0 改成0x0 完事</span></span><br><span class="line">修改虚拟地址基址 减去一个 <span class="number">0xC0000000</span> 就等于物理地址了</span><br></pre></td></tr></table></figure><p>Challenge 以后看看有没有时间做吧 这个 Lab 2 还是在机房里面阅读的…</p></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/" rel="tag"># 内存分配</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"># 操作系统</a> <a href="/tags/uCore/" rel="tag"># uCore</a> <a href="/tags/Lab/" rel="tag"># Lab</a></div><div class="post-nav"><div class="post-nav-item"><a href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/" rel="prev" title="操作系统之 物理内存管理 非连续内存分配"><i class="fa fa-angle-left"></i> 操作系统之 物理内存管理 非连续内存分配</a></div><div class="post-nav-item"><a href="/%E5%BE%AE%E4%BF%A1%E6%91%87%E4%B8%80%E6%91%87%E7%AD%BE%E5%88%B0-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" rel="next" title="微信摇一摇签到 解决方案">微信摇一摇签到 解决方案 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Yuerer</span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://unpkg.com/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://unpkg.com/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/comments.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/utils.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/motion.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/sidebar.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/next-boot.min.js"></script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://yuerer-comment-xufei-0bea01e6f05-1307930306.ap-shanghai.app.tcloudbase.com","cssUrl":"https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.css","commentCount":true,"pageview":true,"libUrl":"https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.js","locale":{"placeholder":"有何高见？"},"emoji":["https://unpkg.com/@waline/emojis@1.0.1/qq"],"meta":["nick","mail"],"requiredMeta":[["nick","mail"]],"wordLimit":0,"login":"disable","pageSize":10,"el":"#waline","comment":true,"path":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-uCore-Lab-2/"}</script><link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.css"><script>document.addEventListener("page:loaded",()=>{NexT.utils.loadComments(CONFIG.waline.el).then(()=>NexT.utils.getScript(CONFIG.waline.libUrl,{condition:window.Waline})).then(()=>Waline.init(Object.assign({},CONFIG.waline,{el:document.querySelector(CONFIG.waline.el)})))})</script></body></html>