<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.jpeg"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.ico"><link rel="mask-icon" href="/images/avatar.jpeg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous"><link rel="stylesheet" href="https://unpkg.com/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"yuerer.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"hide","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":true,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/config.min.js"></script><meta name="description" content="近期在压测服务器的过程中发现内存随着用户数增加而暴涨，用户数减少内存却没有释放回内核，一开始怀疑是内存泄漏，后面上了工具排查，最终定位到是 glibc 的内存管理并没有将内存释放给OS，为了解决这个问题，对 ptmalloc2 进行了剖析。 本篇中，不谈论  brk 和 mmap 系统调用的使用方法，默认环境为 Linux-x86-64，讨论的 ptmalloc2 的版本为 glibc 2.17"><meta property="og:type" content="article"><meta property="og:title" content="ptmalloc2 内存管理"><meta property="og:url" content="https://yuerer.com/ptmalloc2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/index.html"><meta property="og:site_name" content="Yuerer&#39;s Blog"><meta property="og:description" content="近期在压测服务器的过程中发现内存随着用户数增加而暴涨，用户数减少内存却没有释放回内核，一开始怀疑是内存泄漏，后面上了工具排查，最终定位到是 glibc 的内存管理并没有将内存释放给OS，为了解决这个问题，对 ptmalloc2 进行了剖析。 本篇中，不谈论  brk 和 mmap 系统调用的使用方法，默认环境为 Linux-x86-64，讨论的 ptmalloc2 的版本为 glibc 2.17"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://yuerer.com/images/chunk.png"><meta property="og:image" content="https://yuerer.com/images/largebin.png"><meta property="article:published_time" content="2021-02-28T02:45:20.000Z"><meta property="article:modified_time" content="2025-10-21T13:50:52.265Z"><meta property="article:author" content="Yuerer"><meta property="article:tag" content="glibc"><meta property="article:tag" content="内存分配"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://yuerer.com/images/chunk.png"><link rel="canonical" href="https://yuerer.com/ptmalloc2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://yuerer.com/ptmalloc2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","path":"ptmalloc2-内存管理/","title":"ptmalloc2 内存管理"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>ptmalloc2 内存管理 | Yuerer's Blog</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-129491388-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-129491388-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/third-party/analytics/google-analytics.min.js"></script><link rel="dns-prefetch" href="https://yuerer-comment-xufei-0bea01e6f05-1307930306.ap-shanghai.app.tcloudbase.com"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Yuerer's Blog</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">钰儿的Blog</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#chunk"><span class="nav-text">chunk</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bin"><span class="nav-text">bin</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fast-bins"><span class="nav-text">fast bins</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unsorted-bin"><span class="nav-text">unsorted bin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#small-bins"><span class="nav-text">small bins</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#large-bins"><span class="nav-text">large bins</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#malloc-par"><span class="nav-text">malloc_par</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#malloc-state"><span class="nav-text">malloc_state</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-text">内存分配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#int-malloc"><span class="nav-text">_int_malloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sysmalloc"><span class="nav-text">sysmalloc</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE"><span class="nav-text">内存释放</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#libc-free"><span class="nav-text">__libc_free</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#int-free"><span class="nav-text">_int_free</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E7%BB%86%E8%8A%82"><span class="nav-text">其他细节</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E8%AF%AD"><span class="nav-text">结语</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Yuerer" src="/images/avatar.jpeg"><p class="site-author-name" itemprop="name">Yuerer</p><div class="site-description" itemprop="description">钰儿的Blog</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">65</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">16</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">90</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/Yu2erer" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Yu2erer" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:yu2erer#gmail.com" title="E-Mail → mailto:yu2erer#gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://yuerer.com/ptmalloc2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpeg"><meta itemprop="name" content="Yuerer"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Yuerer's Blog"><meta itemprop="description" content="钰儿的Blog"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="ptmalloc2 内存管理 | Yuerer's Blog"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">ptmalloc2 内存管理</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-02-28 10:45:20" itemprop="dateCreated datePublished" datetime="2021-02-28T10:45:20+08:00">2021-02-28</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/" itemprop="url" rel="index"><span itemprop="name">内存分配</span></a> </span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Waline：</span> <a title="waline" href="/ptmalloc2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/ptmalloc2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" itemprop="commentCount"></span> </a></span><span class="post-meta-item" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="waline-pageview-count" data-path="/ptmalloc2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>近期在压测服务器的过程中发现内存随着用户数增加而暴涨，用户数减少内存却没有释放回内核，一开始怀疑是内存泄漏，后面上了工具排查，最终定位到是 <code>glibc</code> 的内存管理并没有将内存释放给OS，为了解决这个问题，对 <code>ptmalloc2</code> 进行了剖析。</p><p>本篇中，不谈论 <code>brk</code> 和 <code>mmap</code> 系统调用的使用方法，默认环境为 <code>Linux-x86-64</code>，讨论的 <code>ptmalloc2</code> 的版本为 <code>glibc 2.17</code> 的版本。</p><h2 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h2><p><code>ptmalloc2</code> 分配给用户的内存都以 chunk 来表示，可以理解为 chunk 为分配释放内存的载体。</p><p><img data-src="/images/chunk.png" alt="chunk"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> INTERNAL_SIZE_T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTERNAL_SIZE_T size_t</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The corresponding word size */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_SZ                (sizeof(INTERNAL_SIZE_T))</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"><span class="comment">// -----------------------------------------------------------------------</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>chunk 由以上几部分组成， <code>INTERNAL_SIZE_T</code> 为 <code>size_t</code> 为了屏蔽平台之间的差异，这里只谈论64位平台，为8字节。</p><ol><li><code>prev_size</code> 代表着上一个 chunk 的大小，是否有效取决于 <code>size</code> 的属性位 <code>P</code>。</li><li><code>size</code> 代表当前 chunk 的大小和属性，其中低3位为属性位 <code>[A|M|P]</code>。</li><li>当这个 chunk 为空闲时，则会使用 <code>fd, bk</code> 将其加入链表中管理。</li><li>同上， <code>fd_nextsize bk_nextsize</code> 只用在 <code>large bin</code> 中，表示 上&#x2F;下一个大小的指针，加快链表遍历。</li></ol><span id="more"></span><p>从上可以得出以下结论：</p><ol><li>当前一个 chunk 非空闲时， <code>prev_size</code> 无意义，可以被前一个 chunk 所利用。</li><li><code>size</code> 的低3位为属性位，说明 <code>size</code> 一定是 8 的倍数，<code>A</code> 为是否为非主分配区，1是0否，<code>M</code> 为是否从 <code>mmap</code> 中获取， <code>P</code> 为前一个 chunk 是否被使用。</li><li>分配区分两种，主分配区与非主分配区们。</li><li>当 chunk 非空闲时，<code>fd bk，fd_nextsize bk_nextsize</code> 都无意义，因此返回给用户的可用内存应为 <code>size</code> 之后。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* size field is or&#x27;ed with PREV_INUSE when previous adjacent chunk in use */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV_INUSE 0x1</span></span><br><span class="line"><span class="comment">/* extract inuse bit of previous chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prev_inuse(p)       ((p)-&gt;size &amp; PREV_INUSE)</span></span><br><span class="line"><span class="comment">/* size field is or&#x27;ed with IS_MMAPPED if the chunk was obtained with mmap() */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_MMAPPED 0x2</span></span><br><span class="line"><span class="comment">/* check for mmap()&#x27;ed chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;size &amp; IS_MMAPPED)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* size field is or&#x27;ed with NON_MAIN_ARENA if the chunk was obtained</span></span><br><span class="line"><span class="comment">   from a non-main arena.  This is only set immediately before handing</span></span><br><span class="line"><span class="comment">   the chunk to the user, if necessary.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NON_MAIN_ARENA 0x4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* check for chunk from non-main arena */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_non_main_arena(p) ((p)-&gt;size &amp; NON_MAIN_ARENA)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">mchunkptr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk2mem(p)   ((void*)((char*)(p) + 2*SIZE_SZ))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The smallest possible chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_CHUNK_SIZE        (offsetof(struct malloc_chunk, fd_nextsize))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC_ALIGN_MASK      (MALLOC_ALIGNMENT - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINSIZE  \</span></span><br><span class="line"><span class="meta">  (unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> request2size(req)                                         \</span></span><br><span class="line"><span class="meta">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span></span><br><span class="line"><span class="meta">   MINSIZE :                                                      \</span></span><br><span class="line"><span class="meta">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span></span><br></pre></td></tr></table></figure><p><code>mem</code> 为用户真正可用的内存起始地址，可以看出 最小的 chunk 应该至少 <code>4*8 = 32字节</code>，因为 <code>fd_nextsize 和 bk_nextsize</code> 只有在 large chunk 才用的上。</p><p><code>request2size</code> 将用户申请的内存大小转化为 需要分配的 chunk 大小，用户请求大小 <code>(req + prev_size + size) = req + 16B</code>，但是由于内存复用的关系，可以从下一个 chunk 中借用 <code>prev_size</code> 的空间（反正对于下一个 chunk 来说，前一个 chunk 已经被使用了，知道前一个 chunk 的大小也没有意义），因此应为 <code>req + prev_size + size - prev_size(next chunk) = req + 8B</code>，同时 <code>req + 8B</code> 不应小于 <code>MINSIZE</code> 所以二者取最大，为 <code>max(req + 8B, 32B)</code>。</p><h2 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h2><p><code>bin</code> 可以理解桶，存放着 <code>chunk</code> ，在 <code>ptmalloc</code> 的世界中存在四种 bin。</p><ul><li>fast bins</li><li>unsorted bin</li><li>small bins</li><li>large bins</li></ul><p><code>fast bins</code> 是小内存块的缓存，当小内存块被回收时，会先放入 <code>fast bins</code>，当下次分配小内存时，就会优先从 <code>fast bins</code> 中找，节约时间。</p><p><code>unsorted bin</code> 只有一个，回收的 <code>chunk</code> 若大于 <code>fast bins</code> 的阈值即 <code>global_max_fast</code>，则放入 <code>unsorted bin</code> 。</p><p><code>small bins</code> 顾名思义，就是 <code>ptmalloc</code> 觉得小的 chunk，就放进去，呈等差数列的形式递增，每个 bin 的 chunk 均为同一大小，通过 <code>fd, bk</code> 链接 chunk 链表。</p><p><code>large bins</code> 同上，不过每个 bin 中的 chunk 有大小排序，大的在前，小的在后，通过 <code>fd_nextsize, bk_nextsize</code> 快速找到上&#x2F;下 一个大小节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NBINS             128</span></span><br></pre></td></tr></table></figure><p><code>bins</code> 共有 <code>small bins</code> 有 62 个， <code>large bins</code> 有 63个， <code>unsorted bin</code> 为 1个，总共为 <code>62+63+1 = 126 个</code>，其中 bin[0] 和 bin[127] 不用，因此 bins 总数为 128 个。要注意 <code>fast bins</code> 并不放入同一数组。</p><h3 id="fast-bins"><a href="#fast-bins" class="headerlink" title="fast bins"></a>fast bins</h3><p><code>fast bins</code> 小内存块的缓存，大小小于 <code>DEFAULT_MXFAST</code> 的 chunk 分配与回收都会在 <code>fast bins</code> 中先查找，在64位上为 <code>128字节</code>，这个参数可以通过 <code>mallopt</code> 函数进行修改，最大值为 <code>160B</code>。一共有 <code>9</code> 个，<code>bin[0] 和 bin[1]</code> 没有用上，剩余 7 个 为 small bins 的小 7 个。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEFAULT_MXFAST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_MXFAST     (64 * SIZE_SZ / 4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">mfastbinptr</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* offset 2 to use otherwise unindexable first 2 bins */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fastbin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((((unsigned int)(sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The maximum fastbin request size we support */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_FAST_SIZE     (80 * SIZE_SZ / 4)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NFASTBINS  (fastbin_index(request2size(MAX_FAST_SIZE))+1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FASTBIN_CONSOLIDATION_THRESHOLD  (65536UL)</span></span><br></pre></td></tr></table></figure><p><code>FASTBIN_CONSOLIDATION_THRESHOLD</code> 表示当回收的 <code>chunk</code> 与相邻的 <code>chunk</code> 合并后大于该值 <code>64k</code>，则合并 <code>fast bins</code> 中所有的 <code>chunk</code> 放回到 <code>unsorted bin</code></p><h3 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h3><p><code>unsorted bin</code> 只有一个， <code>fast bins</code> 合并后的 <code>chunk</code> 会先放到这里，从名字可以看出这里面的 <code>chunk</code> 没有排序。如果从这里面分配不到合适的 <code>chunk</code> 就会将其放到正确的 <code>small bins</code> 或者 <code>large bins</code> 中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> unsorted_chunks(M)          (bin_at(M, 1))</span></span><br></pre></td></tr></table></figure><h3 id="small-bins"><a href="#small-bins" class="headerlink" title="small bins"></a>small bins</h3><p><code>small bins</code> 在64位平台上，共有62个bin，最小的 <code>chunk</code> 为 <code>32字节</code>，等差数列的公差为 <code>16B</code> (SMALLBIN_WIDTH)，最大为 <code>1008B</code> 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NSMALLBINS         64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALLBIN_WIDTH    MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> in_smallbin_range(sz)  \</span></span><br><span class="line"><span class="meta">  ((unsigned long)(sz) &lt; (unsigned long)MIN_LARGE_SIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> smallbin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((SMALLBIN_WIDTH == 16 ? (((unsigned)(sz)) &gt;&gt; 4) : (((unsigned)(sz)) &gt;&gt; 3)) \</span></span><br><span class="line"><span class="meta">   + SMALLBIN_CORRECTION)</span></span><br></pre></td></tr></table></figure><p>将数值带进 <code>smallbin_index</code> 会发现最小的 <code>chunk</code> 是在 <code>bin[2]</code> 上，这是因为为了编程的方便， <code>small bins</code> 从2开始，可以形成 <code>chunk size = 2 * size_t * index</code> 的等差数列，<code>bin[1]</code> 则用来存 <code>unsorted bin</code> 而 <code>bin[0]</code> 为空。</p><p>每个 <code>bin</code> 中的 <code>chunk</code> 大小相同，通过双向链表链接起来。</p><h3 id="large-bins"><a href="#large-bins" class="headerlink" title="large bins"></a>large bins</h3><p><code>large bins</code> 则接在 <code>small bins</code> 之后，<code>MIN_LARGE_SIZE</code> 可以看到最小的 <code>large chunk</code> 为 <code>1024B</code> 。共有63个。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_32(sz)                                                \</span></span><br><span class="line"><span class="meta">(((((unsigned long)(sz)) &gt;&gt;  6) <span class="string">&lt;= 38)?  56 + (((unsigned long)(sz)) &gt;</span>&gt;  6): \</span></span><br><span class="line"><span class="meta"> ((((unsigned long)(sz)) &gt;&gt;  9) <span class="string">&lt;= 20)?  91 + (((unsigned long)(sz)) &gt;</span>&gt;  9): \</span></span><br><span class="line"><span class="meta"> ((((unsigned long)(sz)) &gt;&gt; 12) <span class="string">&lt;= 10)? 110 + (((unsigned long)(sz)) &gt;</span>&gt; 12): \</span></span><br><span class="line"><span class="meta"> ((((unsigned long)(sz)) &gt;&gt; 15) <span class="string">&lt;=  4)? 119 + (((unsigned long)(sz)) &gt;</span>&gt; 15): \</span></span><br><span class="line"><span class="meta"> ((((unsigned long)(sz)) &gt;&gt; 18) <span class="string">&lt;=  2)? 124 + (((unsigned long)(sz)) &gt;</span>&gt; 18): \</span></span><br><span class="line"><span class="meta">					126)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_32_big(sz)                                            \</span></span><br><span class="line"><span class="meta">(((((unsigned long)(sz)) &gt;&gt;  6) <span class="string">&lt;= 45)?  49 + (((unsigned long)(sz)) &gt;</span>&gt;  6): \</span></span><br><span class="line"><span class="meta"> ((((unsigned long)(sz)) &gt;&gt;  9) <span class="string">&lt;= 20)?  91 + (((unsigned long)(sz)) &gt;</span>&gt;  9): \</span></span><br><span class="line"><span class="meta"> ((((unsigned long)(sz)) &gt;&gt; 12) <span class="string">&lt;= 10)? 110 + (((unsigned long)(sz)) &gt;</span>&gt; 12): \</span></span><br><span class="line"><span class="meta"> ((((unsigned long)(sz)) &gt;&gt; 15) <span class="string">&lt;=  4)? 119 + (((unsigned long)(sz)) &gt;</span>&gt; 15): \</span></span><br><span class="line"><span class="meta"> ((((unsigned long)(sz)) &gt;&gt; 18) <span class="string">&lt;=  2)? 124 + (((unsigned long)(sz)) &gt;</span>&gt; 18): \</span></span><br><span class="line"><span class="meta">                                        126)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_64(sz)                                                \</span></span><br><span class="line"><span class="meta">(((((unsigned long)(sz)) &gt;&gt;  6) <span class="string">&lt;= 48)?  48 + (((unsigned long)(sz)) &gt;</span>&gt;  6): \</span></span><br><span class="line"><span class="meta"> ((((unsigned long)(sz)) &gt;&gt;  9) <span class="string">&lt;= 20)?  91 + (((unsigned long)(sz)) &gt;</span>&gt;  9): \</span></span><br><span class="line"><span class="meta"> ((((unsigned long)(sz)) &gt;&gt; 12) <span class="string">&lt;= 10)? 110 + (((unsigned long)(sz)) &gt;</span>&gt; 12): \</span></span><br><span class="line"><span class="meta"> ((((unsigned long)(sz)) &gt;&gt; 15) <span class="string">&lt;=  4)? 119 + (((unsigned long)(sz)) &gt;</span>&gt; 15): \</span></span><br><span class="line"><span class="meta"> ((((unsigned long)(sz)) &gt;&gt; 18) <span class="string">&lt;=  2)? 124 + (((unsigned long)(sz)) &gt;</span>&gt; 18): \</span></span><br><span class="line"><span class="meta">					126)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index(sz) \</span></span><br><span class="line"><span class="meta">  (SIZE_SZ == 8 ? largebin_index_64 (sz)                                     \</span></span><br><span class="line"><span class="meta">   : MALLOC_ALIGNMENT == 16 ? largebin_index_32_big (sz)                     \</span></span><br><span class="line"><span class="meta">   : largebin_index_32 (sz))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bin_index(sz) \</span></span><br><span class="line"><span class="meta"> ((in_smallbin_range(sz)) ? smallbin_index(sz) : largebin_index(sz))</span></span><br></pre></td></tr></table></figure><p><code>large bins</code> 中的每个 <code>bin</code> 里的 <code>chunk</code> 大小为一个区间，从大到小排序，通过双向链表链接，同时为了加快遍历的过程，通过 <code>fd_nextsize, bk_nextsize</code> 将前后不同大小的对象链接起来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">mbinptr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* addressing -- note that bin_at(0) does not exist */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bin_at(m, i) \</span></span><br><span class="line"><span class="meta">  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))			      \</span></span><br><span class="line"><span class="meta">	     - offsetof (struct malloc_chunk, fd))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* analog of ++bin */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> next_bin(b)  ((mbinptr)((char*)(b) + (sizeof(mchunkptr)&lt;&lt;1)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reminders about list directionality within bins */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> first(b)     ((b)-&gt;fd)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> last(b)      ((b)-&gt;bk)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(P, BK, FD) &#123;                                            \</span></span><br><span class="line"><span class="meta">  FD = P-&gt;fd;                                                          \</span></span><br><span class="line"><span class="meta">  BK = P-&gt;bk;                                                          \</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))                \</span></span><br><span class="line"><span class="meta">    malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P); \</span></span><br><span class="line"><span class="meta">  <span class="keyword">else</span> &#123;                                                               \</span></span><br><span class="line"><span class="meta">    FD-&gt;bk = BK;                                                       \</span></span><br><span class="line"><span class="meta">    BK-&gt;fd = FD;                                                       \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (!in_smallbin_range (P-&gt;size)				       \</span></span><br><span class="line"><span class="meta">	&amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123;	       \</span></span><br><span class="line"><span class="meta">      assert (P-&gt;fd_nextsize-&gt;bk_nextsize == P);		       \</span></span><br><span class="line"><span class="meta">      assert (P-&gt;bk_nextsize-&gt;fd_nextsize == P);		       \</span></span><br><span class="line"><span class="meta">      <span class="keyword">if</span> (FD-&gt;fd_nextsize == NULL) &#123;				       \</span></span><br><span class="line"><span class="meta">	<span class="keyword">if</span> (P-&gt;fd_nextsize == P)				       \</span></span><br><span class="line"><span class="meta">	  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;		       \</span></span><br><span class="line"><span class="meta">	<span class="keyword">else</span> &#123;							       \</span></span><br><span class="line"><span class="meta">	  FD-&gt;fd_nextsize = P-&gt;fd_nextsize;			       \</span></span><br><span class="line"><span class="meta">	  FD-&gt;bk_nextsize = P-&gt;bk_nextsize;			       \</span></span><br><span class="line"><span class="meta">	  P-&gt;fd_nextsize-&gt;bk_nextsize = FD;			       \</span></span><br><span class="line"><span class="meta">	  P-&gt;bk_nextsize-&gt;fd_nextsize = FD;			       \</span></span><br><span class="line"><span class="meta">	&#125;							       \</span></span><br><span class="line"><span class="meta">      &#125;	<span class="keyword">else</span> &#123;							       \</span></span><br><span class="line"><span class="meta">	P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;		       \</span></span><br><span class="line"><span class="meta">	P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;		       \</span></span><br><span class="line"><span class="meta">      &#125;								       \</span></span><br><span class="line"><span class="meta">    &#125;								       \</span></span><br><span class="line"><span class="meta">  &#125;                                                                    \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><p>一些辅助宏，可能会好奇为什么有那么多个 对 <code>malloc_chunk*</code> 的 <code>typedef struct</code>，其实就是 <code>ptmalloc</code> 把内存从不同的角度看待的意思，类似 C++ 的 <code>union</code> 。</p><h2 id="malloc-par"><a href="#malloc-par" class="headerlink" title="malloc_par"></a>malloc_par</h2><p><code>malloc_par</code> 可以理解为一个全局的参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_par</span> &#123;</span></span><br><span class="line">  <span class="comment">/* Tunable parameters */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span>    trim_threshold;</span><br><span class="line">  INTERNAL_SIZE_T  top_pad;</span><br><span class="line">  INTERNAL_SIZE_T  mmap_threshold;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD</span></span><br><span class="line">  INTERNAL_SIZE_T  arena_test;</span><br><span class="line">  INTERNAL_SIZE_T  arena_max;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory map support */</span></span><br><span class="line">  <span class="type">int</span>              n_mmaps;</span><br><span class="line">  <span class="type">int</span>              n_mmaps_max;</span><br><span class="line">  <span class="type">int</span>              max_n_mmaps;</span><br><span class="line">  <span class="comment">/* the mmap_threshold is dynamic, until the user sets</span></span><br><span class="line"><span class="comment">     it manually, at which point we need to disable any</span></span><br><span class="line"><span class="comment">     dynamic behavior. */</span></span><br><span class="line">  <span class="type">int</span>              no_dyn_threshold;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Statistics */</span></span><br><span class="line">  INTERNAL_SIZE_T  mmapped_mem;</span><br><span class="line">  <span class="comment">/*INTERNAL_SIZE_T  sbrked_mem;*/</span></span><br><span class="line">  <span class="comment">/*INTERNAL_SIZE_T  max_sbrked_mem;*/</span></span><br><span class="line">  INTERNAL_SIZE_T  max_mmapped_mem;</span><br><span class="line">  INTERNAL_SIZE_T  max_total_mem; <span class="comment">/* only kept for NO_THREADS */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First address handed out by MORECORE/sbrk.  */</span></span><br><span class="line">  <span class="type">char</span>*            sbrk_base;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中较为重要的参数有：</p><ul><li>trim_threshold，mmap 的收缩阈值 默认128KB</li><li>mmap_threshold，mmap 分配阈值 默认128KB</li><li>n_mmaps_max，mmap 分配内存块的最大数</li><li>no_dyn_threshold，是否关闭动态调整分配阈值 默认开启</li></ul><p>以上任一项的修改，都会关闭 动态调整分配阈值，之所以有这个机制，是为了减少 <code>mmap</code> 的次数，因为 <code>mmap</code> 的效率远远低于 <code>brk</code>。更多细节建议阅读 <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man3/mallopt.3.html">mallopt(3) — Linux manual page</a>。</p><p>但是使用 <code>mmap</code> 分配的内存有一个好处，当释放的时候可以直接还回给内核，而且当虚拟内存空间有洞时，只能用 <code>mmap</code> 进行分配，在本次服务器压测的过程中，通过修改以下配置达到释放内存的目的，但是强烈不建议使用， <code>mmap</code> 分配的内存以页为单位，哪怕你申请 <code>1B</code>，都会变成向内核申请一块页大小的内存块，仅适合用于排查内存不释放究竟位于 <code>ptmalloc2</code> 的哪个地方。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">mallopt(M_MMAP_THRESHOLD, <span class="number">0</span>);</span><br><span class="line">mallopt(M_MMAP_MAX, <span class="number">1e9</span>);</span><br></pre></td></tr></table></figure><h2 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h2><p>前面提到过，申请出来的 <code>chunk</code> 可能来自三个地方。</p><ol><li>mmap 直接申请</li><li>主分配区分配</li><li>非主分配区分配</li></ol><p><code>malloc_state</code> 就是用来管理分配区的。非主分配区的出现主要是为了缓解多线程的场景下，减少锁争用的情况，一般情况是一个线程对应一个非主分配区，尽管是这样还是会进行加锁，因此性能不佳，分配区达到CPU核心数时，则会停止创建非主分配区，转而进行复用，复用也很简单，轮询判断是否可以加锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FASTCHUNKS_BIT        (1U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> have_fastchunks(M)     (((M)-&gt;flags &amp;  FASTCHUNKS_BIT) == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_fastchunks(M)    catomic_or (&amp;(M)-&gt;flags, FASTCHUNKS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_fastchunks(M)      catomic_and (&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NONCONTIGUOUS_BIT     (2U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> contiguous(M)          (((M)-&gt;flags &amp;  NONCONTIGUOUS_BIT) == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> noncontiguous(M)       (((M)-&gt;flags &amp;  NONCONTIGUOUS_BIT) != 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_noncontiguous(M)   ((M)-&gt;flags |=  NONCONTIGUOUS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_contiguous(M)      ((M)-&gt;flags &amp;= ~NONCONTIGUOUS_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> &#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  <span class="type">mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr      fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr        top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr        last_remainder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr        bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>     binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD</span></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>mutex，为了支持多线程</li><li>flags，bit0 表示是否有 fast bin chunk，bit1 表示是否能返回连续的虚拟地址空间，显然只有主分配区才能做到，因为在未达到 mmap阈值 时，只有主分配区是用 <code>brk</code> 进行分配，而非主分配区都是采用 <code>mmap</code> 。但也有一种情况，主分配区用 <code>mmap</code> ，静态链接 <code>glibc</code> 的时候，就会禁用 <code>brk</code> ，我想是担心出现洞。</li><li>fastbinY，就是存储 fast bins 的数组，NFASTBINS 为 10。</li><li>top，top chunk 前面一系列的 bin 分配不到内存，就从 top chunk 里拿，释放回内核也是从 top chunk 开始释放，即从高地址开始释放 类似于 stack。</li><li>last_remainder，分配区若上次分配 small chunk 且还有剩余，则存入这个指针。</li><li>bins，即 unsorted bin + small bins + large bins &#x3D; 1 + 62 + 63 &#x3D; 125，bin[0] 和 bin[127] 没有用，但是 bins 的大小为 254，这主要是为了节约内存，可以理解为它只是用数组来申请内存，然后将其转化为双向链表的结构体。</li><li>binmap，标识 bit 指向的 bin 是否有空闲 chunk。</li><li>next，链接分配区。</li><li>system_mem，当前分配区已分配内存大小，可通过 <code>malloc_stats(3)</code> 进行查看。</li></ul><p><img data-src="/images/largebin.png" alt="largebin"></p><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>本节先通过文字描述一遍内存分配流程，再进行代码分析。malloc glibc 内部名字为 <code>__libc_malloc</code></p><ol><li>ptmalloc 是否没有初始化或者有钩子函数，调用指定函数(如果使用 其他malloc，就在此处返回了)。</li><li>查找合适的分配区，加锁,，调用 <code>_int_malloc</code> 在分配区中分配内存，如果分配失败，则解锁分配区并换一个分配区，如果分配区的数量少于CPU核心数，则默认是新建一个非主分配区，并调用 <code>mmap</code> 分配一块大内存并设置好 top chunk。</li><li>进入 <code>_int_malloc</code> 逻辑。</li><li>chunk_size ≤ <code>128B</code>，是则在 fast bins 中查找并返回，否则下一步。</li><li>若 chunk_size &lt; <code>1008B</code> 则在 small bins 进行分配，优先用 <code>last_remainder</code>，从尾节点先分配，头结点还回，使每一个 <code>chunk</code> 都有机会被用上，成功则返回，否则下一步。</li><li>若到这一步要么是 还没找到合适的内存，或者是 chunk_size 是一个 大的请求，则先遍历 fast bins，将相邻的 chunk 进行合并，放入到 unsorted bin 中，从 unstorted bin 中进行查找，一边找一边将其放入正确的 bins 中，同时在 binmap中进行标记。如果找到则返回给用户，若 <code>unsorted bin</code> 只有一个 chunk，且 该 chunk 为 last remainder chunk，且我们需要的是一个 small bin chunk，则将其切分，剩余部分依然不动，此步骤最多尝试 <code>MAX_ITERS（10000）</code>次，防止因为 unsored bin 的 chunk 过多而影响分配效率。</li><li>最后还是找不到，那就在 <code>large bins</code> 中按照最佳匹配的原则，从更大的 bins 中进行查找，查找方式是通过遍历 <code>binmap</code>，找一个合适的 <code>chunk</code>，并将其切分，成功则返回，否则下一步。</li><li>只好从 <code>top chunk</code> 进行切分了（回收的时候也是从 <code>top chunk</code> 进行切分，埋下了长周期的内存无法回收导致内存暴涨的伏笔），不成功下一步。</li><li>又开始打 <code>fast bins</code> 的注意了，主要是 <code>fast bins</code> 回收的时候没有加锁，而是采用 <code>lock-free</code> 方式(Compareand-Swap)回收，因此有可能里面已经有 chunk 了，这时候又开始合并，放入 unsorted bin，但是却是从 small bins 或从 large bins 中再去查找，这主要是因为，在第 5,6 步的时候，如果在 small bins 中找不到合适的 chunk，就合并 fast bins 到 unsorted bin，然后放回到指定的 small bins 和 large bins 中，但是并没有再去扫描一下相应的 bins，这里相当于再补上一刀。</li><li>山穷水尽了，调用 <code>sysmalloc</code> 向内核申请内存了，先看看是否超过 mmap 分配的阈值，若没超过，主分配区采用 <code>brk</code> 扩充 top chunk 大小(若静态链接 <code>brk</code> 会被禁用，此时采用 <code>mmap</code> ），非主分配区则默认用 <code>mmap</code> 进行扩充，超过就更不用讲了，直接 <code>mmap</code> 分配给用户，释放也是直接释放即可。</li><li>分配成功。解锁分配区并返回。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> arena_get(ptr, size) do &#123; \</span></span><br><span class="line"><span class="meta">  arena_lookup(ptr); \</span></span><br><span class="line"><span class="meta">  arena_lock(ptr, size); \</span></span><br><span class="line"><span class="meta">&#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arena_lookup(ptr) do &#123; \</span></span><br><span class="line"><span class="meta">  void *vptr = NULL; \</span></span><br><span class="line"><span class="meta">  ptr = (mstate)tsd_getspecific(arena_key, vptr); \</span></span><br><span class="line"><span class="meta">&#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> arena_lock(ptr, size) do &#123; \</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(ptr) \</span></span><br><span class="line"><span class="meta">    (void)mutex_lock(&amp;ptr-&gt;mutex); \</span></span><br><span class="line"><span class="meta">  <span class="keyword">else</span> \</span></span><br><span class="line"><span class="meta">    ptr = arena_get2(ptr, (size), NULL); \</span></span><br><span class="line"><span class="meta">&#125; while(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> arena_lock(ptr, size) do &#123; \</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(ptr &amp;&amp; !mutex_trylock(&amp;ptr-&gt;mutex)) &#123; \</span></span><br><span class="line"><span class="meta">    THREAD_STAT(++(ptr-&gt;stat_lock_direct)); \</span></span><br><span class="line"><span class="meta">  &#125; <span class="keyword">else</span> \</span></span><br><span class="line"><span class="meta">    ptr = arena_get2(ptr, (size), NULL); \</span></span><br><span class="line"><span class="meta">&#125; while(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> mstate</span><br><span class="line">internal_function</span><br><span class="line"><span class="title function_">arena_get2</span><span class="params">(mstate a_tsd, <span class="type">size_t</span> size, mstate avoid_arena)</span></span><br><span class="line">&#123;</span><br><span class="line">  mstate a;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD</span></span><br><span class="line">  <span class="type">static</span> <span class="type">size_t</span> narenas_limit;</span><br><span class="line"></span><br><span class="line">  a = get_free_list ();</span><br><span class="line">  <span class="keyword">if</span> (a == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Nothing immediately available, so generate a new arena.  */</span></span><br><span class="line">      <span class="keyword">if</span> (narenas_limit == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">if</span> (mp_.arena_max != <span class="number">0</span>)</span><br><span class="line">	    narenas_limit = mp_.arena_max;</span><br><span class="line">	  <span class="keyword">else</span> <span class="keyword">if</span> (narenas &gt; mp_.arena_test)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="type">int</span> n  = __get_nprocs ();</span><br><span class="line"></span><br><span class="line">	      <span class="keyword">if</span> (n &gt;= <span class="number">1</span>)</span><br><span class="line">		narenas_limit = NARENAS_FROM_NCORES (n);</span><br><span class="line">	      <span class="keyword">else</span></span><br><span class="line">		<span class="comment">/* We have no information about the system.  Assume two</span></span><br><span class="line"><span class="comment">		   cores.  */</span></span><br><span class="line">		narenas_limit = NARENAS_FROM_NCORES (<span class="number">2</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    repeat:;</span><br><span class="line">      <span class="type">size_t</span> n = narenas;</span><br><span class="line">      <span class="comment">/* NB: the following depends on the fact that (size_t)0 - 1 is a</span></span><br><span class="line"><span class="comment">	 very large number and that the underflow is OK.  If arena_max</span></span><br><span class="line"><span class="comment">	 is set the value of arena_test is irrelevant.  If arena_test</span></span><br><span class="line"><span class="comment">	 is set but narenas is not yet larger or equal to arena_test</span></span><br><span class="line"><span class="comment">	 narenas_limit is 0.  There is no possibility for narenas to</span></span><br><span class="line"><span class="comment">	 be too big for the test to always fail since there is not</span></span><br><span class="line"><span class="comment">	 enough address space to create that many arenas.  */</span></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (n &lt;= narenas_limit - <span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">if</span> (catomic_compare_and_exchange_bool_acq (&amp;narenas, n + <span class="number">1</span>, n))</span><br><span class="line">	    <span class="keyword">goto</span> repeat;</span><br><span class="line">	  a = _int_new_arena (size);</span><br><span class="line">	  <span class="keyword">if</span> (__builtin_expect (a == <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">	    catomic_decrement (&amp;narenas);</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	a = reused_arena (avoid_arena);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="keyword">if</span>(!a_tsd)</span><br><span class="line">    a = a_tsd = &amp;main_arena;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    a = a_tsd-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(!a) &#123;</span><br><span class="line">      <span class="comment">/* This can only happen while initializing the new arena. */</span></span><br><span class="line">      (<span class="type">void</span>)mutex_lock(&amp;main_arena.mutex);</span><br><span class="line">      THREAD_STAT(++(main_arena.stat_lock_wait));</span><br><span class="line">      <span class="keyword">return</span> &amp;main_arena;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the global, circularly linked list for available arenas. */</span></span><br><span class="line">  <span class="type">bool</span> retried = <span class="literal">false</span>;</span><br><span class="line"> repeat:</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!mutex_trylock(&amp;a-&gt;mutex)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (retried)</span><br><span class="line">	(<span class="type">void</span>)mutex_unlock(&amp;list_lock);</span><br><span class="line">      THREAD_STAT(++(a-&gt;stat_lock_loop));</span><br><span class="line">      tsd_setspecific(arena_key, (<span class="type">void</span> *)a);</span><br><span class="line">      <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    a = a-&gt;next;</span><br><span class="line">  &#125; <span class="keyword">while</span>(a != a_tsd);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If not even the list_lock can be obtained, try again.  This can</span></span><br><span class="line"><span class="comment">     happen during `atfork&#x27;, or for example on systems where thread</span></span><br><span class="line"><span class="comment">     creation makes it temporarily impossible to obtain _any_</span></span><br><span class="line"><span class="comment">     locks. */</span></span><br><span class="line">  <span class="keyword">if</span>(!retried &amp;&amp; mutex_trylock(&amp;list_lock)) &#123;</span><br><span class="line">    <span class="comment">/* We will block to not run in a busy loop.  */</span></span><br><span class="line">    (<span class="type">void</span>)mutex_lock(&amp;list_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Since we blocked there might be an arena available now.  */</span></span><br><span class="line">    retried = <span class="literal">true</span>;</span><br><span class="line">    a = a_tsd;</span><br><span class="line">    <span class="keyword">goto</span> repeat;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Nothing immediately available, so generate a new arena.  */</span></span><br><span class="line">  a = _int_new_arena(size);</span><br><span class="line">  (<span class="type">void</span>)mutex_unlock(&amp;list_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 分配区是绑定在线程的，但并不代表每个线程独占一个分配区，因此都要加锁，导致性能无论在单线程还是多线程上都不佳。同时 分配区的数量取决于 CPU核心数，若获取不到则默认为 8。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>*</span><br><span class="line">__libc_malloc(<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim;</span><br><span class="line"></span><br><span class="line">  <span class="type">__malloc_ptr_t</span> (*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">__malloc_ptr_t</span>)</span><br><span class="line">    = force_reg (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  arena_lookup(ar_ptr);</span><br><span class="line"></span><br><span class="line">  arena_lock(ar_ptr, bytes);</span><br><span class="line">  <span class="keyword">if</span>(!ar_ptr)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  victim = _int_malloc(ar_ptr, bytes);</span><br><span class="line">  <span class="keyword">if</span>(!victim) &#123;</span><br><span class="line">    ar_ptr = arena_get_retry(ar_ptr, bytes);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(ar_ptr != <span class="literal">NULL</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">      victim = _int_malloc(ar_ptr, bytes);</span><br><span class="line">      (<span class="type">void</span>)mutex_unlock(&amp;ar_ptr-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">    (<span class="type">void</span>)mutex_unlock(&amp;ar_ptr-&gt;mutex);</span><br><span class="line">  assert(!victim || chunk_is_mmapped(mem2chunk(victim)) ||</span><br><span class="line">	 ar_ptr == arena_for_chunk(mem2chunk(victim)));</span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="int-malloc"><a href="#int-malloc" class="headerlink" title="_int_malloc"></a>_int_malloc</h3><p><code>_int_malloc</code> 可以说是 <code>ptmalloc2</code> 中最重要的函数之一，它可以说是 <code>ptmalloc2</code> 内存分配策略的实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span>*</span><br><span class="line">_int_malloc(mstate av, <span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T nb;               <span class="comment">/* normalized request size */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>    idx;              <span class="comment">/* associated bin index */</span></span><br><span class="line">  mbinptr         bin;              <span class="comment">/* associated bin */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr       victim;           <span class="comment">/* inspected/selected chunk */</span></span><br><span class="line">  INTERNAL_SIZE_T size;             <span class="comment">/* its size */</span></span><br><span class="line">  <span class="type">int</span>             victim_index;     <span class="comment">/* its bin index */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr       remainder;        <span class="comment">/* remainder from a split */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span>   remainder_size;   <span class="comment">/* its size */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>    block;            <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>    bit;              <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>    <span class="built_in">map</span>;              <span class="comment">/* current word of binmap */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr       fwd;              <span class="comment">/* misc temp for linking */</span></span><br><span class="line">  mchunkptr       bck;              <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *errstr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Convert request size to internal form by adding SIZE_SZ bytes</span></span><br><span class="line"><span class="comment">    overhead plus possibly more to obtain necessary alignment and/or</span></span><br><span class="line"><span class="comment">    to obtain a size of at least MINSIZE, the smallest allocatable</span></span><br><span class="line"><span class="comment">    size. Also, checked_request2size traps (returning 0) request sizes</span></span><br><span class="line"><span class="comment">    that are so large that they wrap around zero when padded and</span></span><br><span class="line"><span class="comment">    aligned.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  checked_request2size(bytes, nb);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If the size qualifies as a fastbin, first check corresponding bin.</span></span><br><span class="line"><span class="comment">    This code is safe to execute even if av is not yet initialized, so we</span></span><br><span class="line"><span class="comment">    can try it without checking, which saves some time on this fast path.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(nb) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>)(get_max_fast ())) &#123;</span><br><span class="line">    idx = fastbin_index(nb);</span><br><span class="line">    mfastbinptr* fb = &amp;fastbin (av, idx);</span><br><span class="line">    mchunkptr pp = *fb;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">	victim = pp;</span><br><span class="line">	<span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">	  <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))</span><br><span class="line">	   != victim);</span><br><span class="line">    <span class="keyword">if</span> (victim != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))</span><br><span class="line">	&#123;</span><br><span class="line">	  errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">	errout:</span><br><span class="line">	  malloc_printerr (check_action, errstr, chunk2mem (victim));</span><br><span class="line">	  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">      check_remalloced_chunk(av, victim, nb);</span><br><span class="line">      <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">	alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>以上为内存分配的第 4 步 <code>fast bins</code>，这里采用了 CAS 操作，换句话说 回收 <code>fast bins</code> 不需要加锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range(nb)) &#123;</span><br><span class="line">    idx = smallbin_index(nb);</span><br><span class="line">    bin = bin_at(av,idx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( (victim = last(bin)) != bin) &#123;</span><br><span class="line">      <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">	malloc_consolidate(av);</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">	bck = victim-&gt;bk;</span><br><span class="line">	<span class="keyword">if</span> (__builtin_expect (bck-&gt;fd != victim, <span class="number">0</span>))</span><br><span class="line">	  &#123;</span><br><span class="line">	    errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">	    <span class="keyword">goto</span> errout;</span><br><span class="line">	  &#125;</span><br><span class="line">	set_inuse_bit_at_offset(victim, nb);</span><br><span class="line">	bin-&gt;bk = bck;</span><br><span class="line">	bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">	  victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">	check_malloced_chunk(av, victim, nb);</span><br><span class="line">	<span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">	<span class="keyword">if</span> (__builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">	  alloc_perturb (p, bytes);</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>内存分配第五步 <code>small bins</code> 至此结束。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    idx = largebin_index(nb);</span><br><span class="line">    <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">      malloc_consolidate(av);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Process recently freed or remaindered chunks, taking one only if</span></span><br><span class="line"><span class="comment">    it is exact fit, or, if this a small request, the chunk is remainder from</span></span><br><span class="line"><span class="comment">    the most recent non-exact fit.  Place other traversed chunks in</span></span><br><span class="line"><span class="comment">    bins.  Note that this step is the only place in any routine where</span></span><br><span class="line"><span class="comment">    chunks are placed in bins.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The outer loop here is needed because we might not realize until</span></span><br><span class="line"><span class="comment">    near the end of malloc that we should have consolidated, so must</span></span><br><span class="line"><span class="comment">    do so and retry. This happens at most once, and only when we would</span></span><br><span class="line"><span class="comment">    otherwise need to expand memory to service a &quot;small&quot; request.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> iters = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( (victim = unsorted_chunks(av)-&gt;bk) != unsorted_chunks(av)) &#123;</span><br><span class="line">      bck = victim-&gt;bk;</span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">	  || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">	malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">			 chunk2mem (victim));</span><br><span class="line">      size = chunksize(victim);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">	 If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">	 only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">	 runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">	 exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">	 no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range(nb) &amp;&amp;</span><br><span class="line">	  bck == unsorted_chunks(av) &amp;&amp;</span><br><span class="line">	  victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">	  (<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>)(nb + MINSIZE)) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* split and reattach remainder */</span></span><br><span class="line">	remainder_size = size - nb;</span><br><span class="line">	remainder = chunk_at_offset(victim, nb);</span><br><span class="line">	unsorted_chunks(av)-&gt;bk = unsorted_chunks(av)-&gt;fd = remainder;</span><br><span class="line">	av-&gt;last_remainder = remainder;</span><br><span class="line">	remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks(av);</span><br><span class="line">	<span class="keyword">if</span> (!in_smallbin_range(remainder_size))</span><br><span class="line">	  &#123;</span><br><span class="line">	    remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">	    remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	set_head(victim, nb | PREV_INUSE |</span><br><span class="line">		 (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">	set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">	set_foot(remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">	check_malloced_chunk(av, victim, nb);</span><br><span class="line">	<span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">	<span class="keyword">if</span> (__builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">	  alloc_perturb (p, bytes);</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">      unsorted_chunks(av)-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = unsorted_chunks(av);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (size == nb) &#123;</span><br><span class="line">	set_inuse_bit_at_offset(victim, size);</span><br><span class="line">	<span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">	  victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">	check_malloced_chunk(av, victim, nb);</span><br><span class="line">	<span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">	<span class="keyword">if</span> (__builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">	  alloc_perturb (p, bytes);</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range(size)) &#123;</span><br><span class="line">	victim_index = smallbin_index(size);</span><br><span class="line">	bck = bin_at(av, victim_index);</span><br><span class="line">	fwd = bck-&gt;fd;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">	victim_index = largebin_index(size);</span><br><span class="line">	bck = bin_at(av, victim_index);</span><br><span class="line">	fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">	<span class="keyword">if</span> (fwd != bck) &#123;</span><br><span class="line">	  <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">	  size |= PREV_INUSE;</span><br><span class="line">	  <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">	  assert((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">	  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>)(bck-&gt;bk-&gt;size)) &#123;</span><br><span class="line">	    fwd = bck;</span><br><span class="line">	    bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">	    victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">	    victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">	    fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">	  &#125;</span><br><span class="line">	  <span class="keyword">else</span> &#123;</span><br><span class="line">	    assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">	    <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; fwd-&gt;size)</span><br><span class="line">	      &#123;</span><br><span class="line">		fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">		assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">	      &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size)</span><br><span class="line">	      <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">	      fwd = fwd-&gt;fd;</span><br><span class="line">	    <span class="keyword">else</span></span><br><span class="line">	      &#123;</span><br><span class="line">		victim-&gt;fd_nextsize = fwd;</span><br><span class="line">		victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">		fwd-&gt;bk_nextsize = victim;</span><br><span class="line">		victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">	      &#125;</span><br><span class="line">	    bck = fwd-&gt;bk;</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">	  victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      mark_bin(av, victim_index);</span><br><span class="line">      victim-&gt;bk = bck;</span><br><span class="line">      victim-&gt;fd = fwd;</span><br><span class="line">      fwd-&gt;bk = victim;</span><br><span class="line">      bck-&gt;fd = victim;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ITERS	10000</span></span><br><span class="line">      <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>第六步至此结束，到这要么是 <code>small bins</code> 不满足 或者 本身请求就是一个 大请求，因此先整合 <code>fast bins</code> 的 chunk，将其放入 <code>unsorted bin</code> 中，一边又从 <code>unsorted bin</code> 中查找，顺便放入正确的 bins 中，如果碰巧就找到了 那就返回就完事了，同时还会设置 <code>binmap</code>，方便之后搜索。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      If a large request, scan through the chunks of current bin in</span></span><br><span class="line"><span class="comment">      sorted order to find smallest that fits.  Use the skip list for this.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range(nb)) &#123;</span><br><span class="line">      bin = bin_at(av, idx);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">      <span class="keyword">if</span> ((victim = first(bin)) != bin &amp;&amp;</span><br><span class="line">	  (<span class="type">unsigned</span> <span class="type">long</span>)(victim-&gt;size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb)) &#123;</span><br><span class="line"></span><br><span class="line">	victim = victim-&gt;bk_nextsize;</span><br><span class="line">	<span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>)(size = chunksize(victim)) &lt;</span><br><span class="line">		(<span class="type">unsigned</span> <span class="type">long</span>)(nb)))</span><br><span class="line">	  victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">	   list does not have to be rerouted.  */</span></span><br><span class="line">	<span class="keyword">if</span> (victim != last(bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</span><br><span class="line">	  victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">	remainder_size = size - nb;</span><br><span class="line">	unlink(victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Exhaust */</span></span><br><span class="line">	<span class="keyword">if</span> (remainder_size &lt; MINSIZE)  &#123;</span><br><span class="line">	  set_inuse_bit_at_offset(victim, size);</span><br><span class="line">	  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">	    victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* Split */</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">	  remainder = chunk_at_offset(victim, nb);</span><br><span class="line">	  <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">	     have to perform a complete insert here.  */</span></span><br><span class="line">	  bck = unsorted_chunks(av);</span><br><span class="line">	  fwd = bck-&gt;fd;</span><br><span class="line">	  <span class="keyword">if</span> (__builtin_expect (fwd-&gt;bk != bck, <span class="number">0</span>))</span><br><span class="line">	    &#123;</span><br><span class="line">	      errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">	      <span class="keyword">goto</span> errout;</span><br><span class="line">	    &#125;</span><br><span class="line">	  remainder-&gt;bk = bck;</span><br><span class="line">	  remainder-&gt;fd = fwd;</span><br><span class="line">	  bck-&gt;fd = remainder;</span><br><span class="line">	  fwd-&gt;bk = remainder;</span><br><span class="line">	  <span class="keyword">if</span> (!in_smallbin_range(remainder_size))</span><br><span class="line">	    &#123;</span><br><span class="line">	      remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">	      remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	  set_head(victim, nb | PREV_INUSE |</span><br><span class="line">		   (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">	  set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">	  set_foot(remainder, remainder_size);</span><br><span class="line">	&#125;</span><br><span class="line">	check_malloced_chunk(av, victim, nb);</span><br><span class="line">	<span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">	<span class="keyword">if</span> (__builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">	  alloc_perturb (p, bytes);</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Search for a chunk by scanning bins, starting with next largest</span></span><br><span class="line"><span class="comment">      bin. This search is strictly by best-fit; i.e., the smallest</span></span><br><span class="line"><span class="comment">      (with ties going to approximately the least recently used) chunk</span></span><br><span class="line"><span class="comment">      that fits is selected.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      The bitmap avoids needing to check that most blocks are nonempty.</span></span><br><span class="line"><span class="comment">      The particular case of skipping all bins during warm-up phases</span></span><br><span class="line"><span class="comment">      when no chunks have been returned yet is faster than it might look.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    ++idx;</span><br><span class="line">    bin = bin_at(av,idx);</span><br><span class="line">    block = idx2block(idx);</span><br><span class="line">    <span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">    bit = idx2bit(idx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line">      <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">	  <span class="keyword">if</span> (++block &gt;= BINMAPSIZE)  <span class="comment">/* out of bins */</span></span><br><span class="line">	    <span class="keyword">goto</span> use_top;</span><br><span class="line">	&#125; <span class="keyword">while</span> ( (<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	bin = bin_at(av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">	bit = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line">      <span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">	bin = next_bin(bin);</span><br><span class="line">	bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">	assert(bit != <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line">      victim = last(bin);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line">      <span class="keyword">if</span> (victim == bin) &#123;</span><br><span class="line">	av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">	bin = next_bin(bin);</span><br><span class="line">	bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">	size = chunksize(victim);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">	assert((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb));</span><br><span class="line"></span><br><span class="line">	remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* unlink */</span></span><br><span class="line">	unlink(victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Exhaust */</span></span><br><span class="line">	<span class="keyword">if</span> (remainder_size &lt; MINSIZE) &#123;</span><br><span class="line">	  set_inuse_bit_at_offset(victim, size);</span><br><span class="line">	  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">	    victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Split */</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">	  remainder = chunk_at_offset(victim, nb);</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">	     have to perform a complete insert here.  */</span></span><br><span class="line">	  bck = unsorted_chunks(av);</span><br><span class="line">	  fwd = bck-&gt;fd;</span><br><span class="line">	  <span class="keyword">if</span> (__builtin_expect (fwd-&gt;bk != bck, <span class="number">0</span>))</span><br><span class="line">	    &#123;</span><br><span class="line">	      errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;</span><br><span class="line">	      <span class="keyword">goto</span> errout;</span><br><span class="line">	    &#125;</span><br><span class="line">	  remainder-&gt;bk = bck;</span><br><span class="line">	  remainder-&gt;fd = fwd;</span><br><span class="line">	  bck-&gt;fd = remainder;</span><br><span class="line">	  fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">	  <span class="keyword">if</span> (in_smallbin_range(nb))</span><br><span class="line">	    av-&gt;last_remainder = remainder;</span><br><span class="line">	  <span class="keyword">if</span> (!in_smallbin_range(remainder_size))</span><br><span class="line">	    &#123;</span><br><span class="line">	      remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">	      remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	  set_head(victim, nb | PREV_INUSE |</span><br><span class="line">		   (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">	  set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">	  set_foot(remainder, remainder_size);</span><br><span class="line">	&#125;</span><br><span class="line">	check_malloced_chunk(av, victim, nb);</span><br><span class="line">	<span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">	<span class="keyword">if</span> (__builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">	  alloc_perturb (p, bytes);</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>第七步主要是从更大的 <code>bins</code> 中进行查找，然后进行切分，如果切分后剩余的内存太小则一起送给用户，还有很多的话，则将其插入到 <code>unsorted bin</code> ，分配的是小内存则还会将其剩余部分保存到 <code>last_remainder</code> 供下次优先分配。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">use_top:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">      (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">      search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">      less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">      be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">      limitations).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">      MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">      exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">      reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">      to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    victim = av-&gt;top;</span><br><span class="line">    size = chunksize(victim);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb + MINSIZE)) &#123;</span><br><span class="line">      remainder_size = size - nb;</span><br><span class="line">      remainder = chunk_at_offset(victim, nb);</span><br><span class="line">      av-&gt;top = remainder;</span><br><span class="line">      set_head(victim, nb | PREV_INUSE |</span><br><span class="line">	       (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">      set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">      check_malloced_chunk(av, victim, nb);</span><br><span class="line">      <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">	alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>第八步，从 <code>top chunk</code> 中进行切分，回收也是从 <code>top chunk</code> 从高往低释放回给内核，因此如果后分配的没有释放，会导致先分配的已释放都没办法还回给内核。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">       here for all block sizes.  */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks(av)) &#123;</span><br><span class="line">      malloc_consolidate(av);</span><br><span class="line">      <span class="comment">/* restore original bin index */</span></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range(nb))</span><br><span class="line">	idx = smallbin_index(nb);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	idx = largebin_index(nb);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>第九步，<code>fast bins</code>，因为 <code>fast bins</code> 的回收是不需要锁的，有可能回收了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">       Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="type">void</span> *p = sysmalloc(nb, av);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span> &amp;&amp; __builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">	alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第十步，一滴也没有了，通过 <code>sysmalloc</code> 从内核申请内存。</p><h3 id="sysmalloc"><a href="#sysmalloc" class="headerlink" title="sysmalloc"></a>sysmalloc</h3><p>主分配区用 <code>brk</code> 申请一块内存进行内存分配，若是静态链接 <code>glibc</code> 则只能用 <code>mmap</code> 防止有洞。非主分配区则只能用 <code>mmap</code> 。还会先看看所需内存是否大于 <code>mmap</code> 的阈值，大过就直接采用 <code>mmap</code> 返回。但是 <code>mmap</code> 的效率不高，在内核中属于串行运作，因此 <code>ptmalloc2</code> 会动态调整这个阈值（默认为 <code>128KB</code>，最大可达 <code>32MB</code>）换句话说你要想百分百用 <code>mmap</code> 申请内存，那请你申请大于 <code>32MB</code> 的内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span>* <span class="title function_">sysmalloc</span><span class="params">(INTERNAL_SIZE_T nb, mstate av)</span></span><br><span class="line">&#123;</span><br><span class="line">  mchunkptr       old_top;        <span class="comment">/* incoming value of av-&gt;top */</span></span><br><span class="line">  INTERNAL_SIZE_T old_size;       <span class="comment">/* its size */</span></span><br><span class="line">  <span class="type">char</span>*           old_end;        <span class="comment">/* its end address */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">long</span>            size;           <span class="comment">/* arg to first MORECORE or mmap call */</span></span><br><span class="line">  <span class="type">char</span>*           brk;            <span class="comment">/* return value from MORECORE */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">long</span>            correction;     <span class="comment">/* arg to 2nd MORECORE call */</span></span><br><span class="line">  <span class="type">char</span>*           snd_brk;        <span class="comment">/* 2nd return val */</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T front_misalign; <span class="comment">/* unusable bytes at front of new space */</span></span><br><span class="line">  INTERNAL_SIZE_T end_misalign;   <span class="comment">/* partial page left at end of new space */</span></span><br><span class="line">  <span class="type">char</span>*           aligned_brk;    <span class="comment">/* aligned offset into brk */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr       p;              <span class="comment">/* the allocated/returned chunk */</span></span><br><span class="line">  mchunkptr       remainder;      <span class="comment">/* remainder from allocation */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span>   remainder_size; <span class="comment">/* its size */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span>   sum;            <span class="comment">/* for updating stats */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span>          pagemask  = GLRO(dl_pagesize) - <span class="number">1</span>;</span><br><span class="line">  <span class="type">bool</span>            tried_mmap = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If have mmap, and the request size meets the mmap threshold, and</span></span><br><span class="line"><span class="comment">    the system supports mmap, and there are few enough currently</span></span><br><span class="line"><span class="comment">    allocated mmapped regions, try to directly map this request</span></span><br><span class="line"><span class="comment">    rather than expanding top.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(nb) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(mp_.mmap_threshold) &amp;&amp;</span><br><span class="line">      (mp_.n_mmaps &lt; mp_.n_mmaps_max)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* mm;             <span class="comment">/* return value from mmap call*/</span></span><br><span class="line"></span><br><span class="line">  try_mmap:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Round up size to nearest page.  For mmapped chunks, the overhead</span></span><br><span class="line"><span class="comment">      is one SIZE_SZ unit larger than for normal chunks, because there</span></span><br><span class="line"><span class="comment">      is no following chunk whose prev_size field could be used.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      See the front_misalign handling below, for glibc there is no</span></span><br><span class="line"><span class="comment">      need for further alignments unless we have have high alignment.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">      size = (nb + SIZE_SZ + pagemask) &amp; ~pagemask;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      size = (nb + SIZE_SZ + MALLOC_ALIGN_MASK + pagemask) &amp; ~pagemask;</span><br><span class="line">    tried_mmap = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don&#x27;t try if size wraps around 0 */</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>)(nb)) &#123;</span><br><span class="line"></span><br><span class="line">      mm = (<span class="type">char</span>*)(MMAP(<span class="number">0</span>, size, PROT_READ|PROT_WRITE, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (mm != MAP_FAILED) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	  The offset to the start of the mmapped region is stored</span></span><br><span class="line"><span class="comment">	  in the prev_size field of the chunk. This allows us to adjust</span></span><br><span class="line"><span class="comment">	  returned start address to meet alignment requirements here</span></span><br><span class="line"><span class="comment">	  and in memalign(), and still be able to compute proper</span></span><br><span class="line"><span class="comment">	  address argument for later munmap in free() and realloc().</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">	  &#123;</span><br><span class="line">	    <span class="comment">/* For glibc, chunk2mem increases the address by 2*SIZE_SZ and</span></span><br><span class="line"><span class="comment">	       MALLOC_ALIGN_MASK is 2*SIZE_SZ-1.  Each mmap&#x27;ed area is page</span></span><br><span class="line"><span class="comment">	       aligned and therefore definitely MALLOC_ALIGN_MASK-aligned.  */</span></span><br><span class="line">	    assert (((INTERNAL_SIZE_T)chunk2mem(mm) &amp; MALLOC_ALIGN_MASK) == <span class="number">0</span>);</span><br><span class="line">	    front_misalign = <span class="number">0</span>;</span><br><span class="line">	  &#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	  front_misalign = (INTERNAL_SIZE_T)chunk2mem(mm) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">	<span class="keyword">if</span> (front_misalign &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	  correction = MALLOC_ALIGNMENT - front_misalign;</span><br><span class="line">	  p = (mchunkptr)(mm + correction);</span><br><span class="line">	  p-&gt;prev_size = correction;</span><br><span class="line">	  set_head(p, (size - correction) |IS_MMAPPED);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	  &#123;</span><br><span class="line">	    p = (mchunkptr)mm;</span><br><span class="line">	    set_head(p, size|IS_MMAPPED);</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* update statistics */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (++mp_.n_mmaps &gt; mp_.max_n_mmaps)</span><br><span class="line">	  mp_.max_n_mmaps = mp_.n_mmaps;</span><br><span class="line"></span><br><span class="line">	sum = mp_.mmapped_mem += size;</span><br><span class="line">	<span class="keyword">if</span> (sum &gt; (<span class="type">unsigned</span> <span class="type">long</span>)(mp_.max_mmapped_mem))</span><br><span class="line">	  mp_.max_mmapped_mem = sum;</span><br><span class="line"></span><br><span class="line">	check_chunk(av, p);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> chunk2mem(p);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Record incoming configuration of top */</span></span><br><span class="line"></span><br><span class="line">  old_top  = av-&gt;top;</span><br><span class="line">  old_size = chunksize(old_top);</span><br><span class="line">  old_end  = (<span class="type">char</span>*)(chunk_at_offset(old_top, old_size));</span><br><span class="line"></span><br><span class="line">  brk = snd_brk = (<span class="type">char</span>*)(MORECORE_FAILURE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If not the first time through, we require old_size to be</span></span><br><span class="line"><span class="comment">     at least MINSIZE and to have prev_inuse set.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  assert((old_top == initial_top(av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">	 ((<span class="type">unsigned</span> <span class="type">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">	  prev_inuse(old_top) &amp;&amp;</span><br><span class="line">	  ((<span class="type">unsigned</span> <span class="type">long</span>)old_end &amp; pagemask) == <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Precondition: not enough current space to satisfy nb request */</span></span><br><span class="line">  assert((<span class="type">unsigned</span> <span class="type">long</span>)(old_size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>)(nb + MINSIZE));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (av != &amp;main_arena) &#123;</span><br><span class="line"></span><br><span class="line">    heap_info *old_heap, *heap;</span><br><span class="line">    <span class="type">size_t</span> old_heap_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* First try to extend the current heap. */</span></span><br><span class="line">    old_heap = heap_for_ptr(old_top);</span><br><span class="line">    old_heap_size = old_heap-&gt;size;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">long</span>) (MINSIZE + nb - old_size) &gt; <span class="number">0</span></span><br><span class="line">	&amp;&amp; grow_heap(old_heap, MINSIZE + nb - old_size) == <span class="number">0</span>) &#123;</span><br><span class="line">      av-&gt;system_mem += old_heap-&gt;size - old_heap_size;</span><br><span class="line">      arena_mem += old_heap-&gt;size - old_heap_size;</span><br><span class="line">      set_head(old_top, (((<span class="type">char</span> *)old_heap + old_heap-&gt;size) - (<span class="type">char</span> *)old_top)</span><br><span class="line">	       | PREV_INUSE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((heap = new_heap(nb + (MINSIZE + <span class="keyword">sizeof</span>(*heap)), mp_.top_pad))) &#123;</span><br><span class="line">      <span class="comment">/* Use a newly allocated heap.  */</span></span><br><span class="line">      heap-&gt;ar_ptr = av;</span><br><span class="line">      heap-&gt;prev = old_heap;</span><br><span class="line">      av-&gt;system_mem += heap-&gt;size;</span><br><span class="line">      arena_mem += heap-&gt;size;</span><br><span class="line">      <span class="comment">/* Set up the new top.  */</span></span><br><span class="line">      top(av) = chunk_at_offset(heap, <span class="keyword">sizeof</span>(*heap));</span><br><span class="line">      set_head(top(av), (heap-&gt;size - <span class="keyword">sizeof</span>(*heap)) | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Setup fencepost and free the old top chunk with a multiple of</span></span><br><span class="line"><span class="comment">	 MALLOC_ALIGNMENT in size. */</span></span><br><span class="line">      <span class="comment">/* The fencepost takes at least MINSIZE bytes, because it might</span></span><br><span class="line"><span class="comment">	 become the top chunk again later.  Note that a footer is set</span></span><br><span class="line"><span class="comment">	 up, too, although the chunk is marked in use. */</span></span><br><span class="line">      old_size = (old_size - MINSIZE) &amp; ~MALLOC_ALIGN_MASK;</span><br><span class="line">      set_head(chunk_at_offset(old_top, old_size + <span class="number">2</span>*SIZE_SZ), <span class="number">0</span>|PREV_INUSE);</span><br><span class="line">      <span class="keyword">if</span> (old_size &gt;= MINSIZE) &#123;</span><br><span class="line">	set_head(chunk_at_offset(old_top, old_size), (<span class="number">2</span>*SIZE_SZ)|PREV_INUSE);</span><br><span class="line">	set_foot(chunk_at_offset(old_top, old_size), (<span class="number">2</span>*SIZE_SZ));</span><br><span class="line">	set_head(old_top, old_size|PREV_INUSE|NON_MAIN_ARENA);</span><br><span class="line">	_int_free(av, old_top, <span class="number">1</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	set_head(old_top, (old_size + <span class="number">2</span>*SIZE_SZ)|PREV_INUSE);</span><br><span class="line">	set_foot(old_top, (old_size + <span class="number">2</span>*SIZE_SZ));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!tried_mmap)</span><br><span class="line">      <span class="comment">/* We can at least try to use to mmap memory.  */</span></span><br><span class="line">      <span class="keyword">goto</span> try_mmap;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">/* av == main_arena */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Request enough space for nb + pad + overhead */</span></span><br><span class="line"></span><br><span class="line">  size = nb + mp_.top_pad + MINSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If contiguous, we can subtract out existing space that we hope to</span></span><br><span class="line"><span class="comment">    combine with new space. We add it back later only if</span></span><br><span class="line"><span class="comment">    we don&#x27;t actually get contiguous space.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (contiguous(av))</span><br><span class="line">    size -= old_size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Round to a multiple of page size.</span></span><br><span class="line"><span class="comment">    If MORECORE is not contiguous, this ensures that we only call it</span></span><br><span class="line"><span class="comment">    with whole-page arguments.  And if MORECORE is contiguous and</span></span><br><span class="line"><span class="comment">    this is not first time through, this preserves page-alignment of</span></span><br><span class="line"><span class="comment">    previous calls. Otherwise, we correct to page-align below.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  size = (size + pagemask) &amp; ~pagemask;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Don&#x27;t try to call MORECORE if argument is so big as to appear</span></span><br><span class="line"><span class="comment">    negative. Note that since mmap takes size_t arg, it may succeed</span></span><br><span class="line"><span class="comment">    below even if we cannot call MORECORE.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (size &gt; <span class="number">0</span>)</span><br><span class="line">    brk = (<span class="type">char</span>*)(MORECORE(size));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (brk != (<span class="type">char</span>*)(MORECORE_FAILURE)) &#123;</span><br><span class="line">    <span class="comment">/* Call the `morecore&#x27; hook if necessary.  */</span></span><br><span class="line">    <span class="type">void</span> (*hook) (<span class="type">void</span>) = force_reg (__after_morecore_hook);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">      (*hook) ();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If have mmap, try using it as a backup when MORECORE fails or</span></span><br><span class="line"><span class="comment">    cannot be used. This is worth doing on systems that have &quot;holes&quot; in</span></span><br><span class="line"><span class="comment">    address space, so sbrk cannot extend to give contiguous space, but</span></span><br><span class="line"><span class="comment">    space is available elsewhere.  Note that we ignore mmap max count</span></span><br><span class="line"><span class="comment">    and threshold limits, since the space will not be used as a</span></span><br><span class="line"><span class="comment">    segregated mmap region.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Cannot merge with old top, so add its size back in */</span></span><br><span class="line">    <span class="keyword">if</span> (contiguous(av))</span><br><span class="line">      size = (size + old_size + pagemask) &amp; ~pagemask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we are relying on mmap as backup, then use larger units */</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>)(MMAP_AS_MORECORE_SIZE))</span><br><span class="line">      size = MMAP_AS_MORECORE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don&#x27;t try if size wraps around 0 */</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>)(nb)) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="type">char</span> *mbrk = (<span class="type">char</span>*)(MMAP(<span class="number">0</span>, size, PROT_READ|PROT_WRITE, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (mbrk != MAP_FAILED) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We do not need, and cannot use, another sbrk call to find end */</span></span><br><span class="line">	brk = mbrk;</span><br><span class="line">	snd_brk = brk + size;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	   Record that we no longer have a contiguous sbrk region.</span></span><br><span class="line"><span class="comment">	   After the first time mmap is used as backup, we do not</span></span><br><span class="line"><span class="comment">	   ever rely on contiguous space since this could incorrectly</span></span><br><span class="line"><span class="comment">	   bridge regions.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	set_noncontiguous(av);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="内存释放"><a href="#内存释放" class="headerlink" title="内存释放"></a>内存释放</h2><p>依然是文字先总结一遍流程。</p><ol><li>先检查是否有钩子函数，有则调用并返回。</li><li>如果是 <code>mmap</code> 分配的 chunk，则用 <code>munmap</code> 将其释放，如果释放的 <code>chunk</code> 大小大于 <code>mmap</code> 分配的阈值，且未关闭动态调整阈值开关，则调整一下 <code>mmap</code> 的阈值为当前 <code>chunk</code> 大小。</li><li>调用 <code>_int_free</code> 释放内存。</li><li>若 <code>chunk_size</code> &lt; <code>128B</code> ，且 chunk 不与 <code>top chunk</code> 相邻则放入 <code>fast bins</code> 中，这里不会加锁，而是用的 <code>CAS</code>，返回。</li><li>加锁分配区，前一个 chunk 若空闲，则合并。</li><li>后一个 chunk 若为 <code>top chunk</code> ，则将其合并到 <code>top chunk</code> 中，若不是也合并，将其放到 <code>unosrted bin</code>。</li><li>如果合并的 <code>chunk</code> 大于 <code>64KB</code>，则开始整合 <code>fast bins</code> 到 <code>unsorted bin</code> ，若 <code>top chunk</code> 的大小 大过 收缩阈值了，默认为 <code>128K</code> ，则收缩堆，也就是还给内核。</li><li>也就是说 释放内存回内核 需要两个条件， <code>chunk_size</code> &gt; <code>64KB</code>，且 <code>top chunk</code> 大于收缩阈值，则释放。</li></ol><h3 id="libc-free"><a href="#libc-free" class="headerlink" title="__libc_free"></a>__libc_free</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">__libc_free(<span class="type">void</span>* mem)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  mchunkptr p;                          <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> (*hook) (<span class="type">__malloc_ptr_t</span>, <span class="type">const</span> <span class="type">__malloc_ptr_t</span>)</span><br><span class="line">    = force_reg (__free_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">    (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>)                              <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  p = mem2chunk(mem);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped(p))                       <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* see if the dynamic brk/mmap threshold needs adjusting */</span></span><br><span class="line">    <span class="keyword">if</span> (!mp_.no_dyn_threshold</span><br><span class="line">	&amp;&amp; p-&gt;size &gt; mp_.mmap_threshold</span><br><span class="line">	&amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX)</span><br><span class="line">      &#123;</span><br><span class="line">	mp_.mmap_threshold = chunksize (p);</span><br><span class="line">	mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">      &#125;</span><br><span class="line">    munmap_chunk(p);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ar_ptr = arena_for_chunk(p);</span><br><span class="line">  _int_free(ar_ptr, p, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="int-free"><a href="#int-free" class="headerlink" title="_int_free"></a>_int_free</h3><p>只放出最重要的一段，收缩堆的条件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">      <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">	malloc_consolidate(av);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (av == &amp;main_arena) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MORECORE_CANNOT_TRIM</span></span><br><span class="line">	<span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(chunksize(av-&gt;top)) &gt;=</span><br><span class="line">	    (<span class="type">unsigned</span> <span class="type">long</span>)(mp_.trim_threshold))</span><br><span class="line">	  systrim(mp_.top_pad, av);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">/* Always try heap_trim(), even if the top chunk is not</span></span><br><span class="line"><span class="comment">	   large, because the corresponding heap might go away.  */</span></span><br><span class="line">	heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line"></span><br><span class="line">	assert(heap-&gt;ar_ptr == av);</span><br><span class="line">	heap_trim(heap, mp_.top_pad);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="其他细节"><a href="#其他细节" class="headerlink" title="其他细节"></a>其他细节</h2><p>由于 <code>ptmalloc</code> 用了 <code>mutex</code> ，如果一个多线程的进程执行 <code>fork</code> 会将执行 <code>fork</code> 的线程进行拷贝，其他线程会突然消失，这个时候子进程的 <code>mutex</code> 处于不安全的状态，只能直接重新初始化。关于这一点可以查看 <code>ptmalloc_unlock_all2</code> 这个函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread_atfork(ptmalloc_lock_all, ptmalloc_unlock_all, ptmalloc_unlock_all2);</span><br></pre></td></tr></table></figure><p>扩展堆和收缩堆还有释放堆的几个操作补充一下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Grow a heap.  size is automatically rounded up to a</span></span><br><span class="line"><span class="comment">   multiple of the page size. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">grow_heap</span><span class="params">(heap_info *h, <span class="type">long</span> diff)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> page_mask = GLRO(dl_pagesize) - <span class="number">1</span>;</span><br><span class="line">  <span class="type">long</span> new_size;</span><br><span class="line"></span><br><span class="line">  diff = (diff + page_mask) &amp; ~page_mask;</span><br><span class="line">  new_size = (<span class="type">long</span>)h-&gt;size + diff;</span><br><span class="line">  <span class="keyword">if</span>((<span class="type">unsigned</span> <span class="type">long</span>) new_size &gt; (<span class="type">unsigned</span> <span class="type">long</span>) HEAP_MAX_SIZE)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>((<span class="type">unsigned</span> <span class="type">long</span>) new_size &gt; h-&gt;mprotect_size) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__mprotect((<span class="type">char</span> *)h + h-&gt;mprotect_size,</span><br><span class="line">		   (<span class="type">unsigned</span> <span class="type">long</span>) new_size - h-&gt;mprotect_size,</span><br><span class="line">		   PROT_READ|PROT_WRITE) != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    h-&gt;mprotect_size = new_size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  h-&gt;size = new_size;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Shrink a heap.  */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">shrink_heap</span><span class="params">(heap_info *h, <span class="type">long</span> diff)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">long</span> new_size;</span><br><span class="line"></span><br><span class="line">  new_size = (<span class="type">long</span>)h-&gt;size - diff;</span><br><span class="line">  <span class="keyword">if</span>(new_size &lt; (<span class="type">long</span>)<span class="keyword">sizeof</span>(*h))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">/* Try to re-map the extra heap space freshly to save memory, and make it</span></span><br><span class="line"><span class="comment">     inaccessible.  See malloc-sysdep.h to know when this is true.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (check_may_shrink_heap (), <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>((<span class="type">char</span> *)MMAP((<span class="type">char</span> *)h + new_size, diff, PROT_NONE,</span><br><span class="line">		      MAP_FIXED) == (<span class="type">char</span> *) MAP_FAILED)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">      h-&gt;mprotect_size = new_size;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    __madvise ((<span class="type">char</span> *)h + new_size, diff, MADV_DONTNEED);</span><br><span class="line">  <span class="comment">/*fprintf(stderr, &quot;shrink %p %08lx\n&quot;, h, new_size);*/</span></span><br><span class="line"></span><br><span class="line">  h-&gt;size = new_size;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Delete a heap. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> delete_heap(heap) \</span></span><br><span class="line"><span class="meta">  do &#123;								\</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> ((char *)(heap) + HEAP_MAX_SIZE == aligned_heap_area)	\</span></span><br><span class="line"><span class="meta">      aligned_heap_area = NULL;					\</span></span><br><span class="line"><span class="meta">    __munmap((char*)(heap), HEAP_MAX_SIZE);			\</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>通过了解 <code>ptmalloc2</code> 分配释放内存的策略，可以知道，它比较适合短生命周期的内存分配，若是长生命周期的内存，则会不断抬高 <code>top chunk</code> ，导致无法将内存释放回内核，引起内存暴涨。而游戏服务器中，玩家的内存数据很有可能要等一个小时以上才释放，生命周期比较长，因此最好的做法还是自己写一个基于 <code>mmap</code> 的内存池（打脸了 在<a href="https://yuerer.com/Lua-GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/">Lua GC垃圾回收优化方案</a>中我还提到，认为内存池没有必要），之所以特意强调是基于 <code>mmap</code> 主要是 <code>brk</code> 它类似于栈，会将堆顶抬高，如果堆顶内存没释放，会导致堆顶以下的内存都不能还回内核，又会导致内存暴涨。</p></div><footer class="post-footer"><div class="post-tags"><a href="/tags/glibc/" rel="tag"># glibc</a> <a href="/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/" rel="tag"># 内存分配</a></div><div class="post-nav"><div class="post-nav-item"><a href="/Lua-GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/" rel="prev" title="Lua GC垃圾回收优化方案"><i class="fa fa-angle-left"></i> Lua GC垃圾回收优化方案</a></div><div class="post-nav-item"><a href="/Gossip-%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/" rel="next" title="Gossip 协议解析">Gossip 协议解析 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Yuerer</span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://unpkg.com/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://unpkg.com/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/comments.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/utils.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/motion.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/sidebar.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/next-boot.min.js"></script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://yuerer-comment-xufei-0bea01e6f05-1307930306.ap-shanghai.app.tcloudbase.com","cssUrl":"https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.css","commentCount":true,"pageview":true,"libUrl":"https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.js","locale":{"placeholder":"有何高见？"},"emoji":["https://unpkg.com/@waline/emojis@1.0.1/qq"],"meta":["nick","mail"],"requiredMeta":[["nick","mail"]],"wordLimit":0,"login":"disable","pageSize":10,"el":"#waline","comment":true,"path":"/ptmalloc2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"}</script><link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.css"><script>document.addEventListener("page:loaded",()=>{NexT.utils.loadComments(CONFIG.waline.el).then(()=>NexT.utils.getScript(CONFIG.waline.libUrl,{condition:window.Waline})).then(()=>Waline.init(Object.assign({},CONFIG.waline,{el:document.querySelector(CONFIG.waline.el)})))})</script></body></html>