<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.jpeg"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.ico"><link rel="mask-icon" href="/images/avatar.jpeg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous"><link rel="stylesheet" href="https://unpkg.com/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"yuerer.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"hide","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":true,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/config.min.js"></script><meta name="description" content="本文以 UE5.4 为基准，讲解智能指针的实现机制。阅读本文前需要对 C++11 的智能指针有基本了解。 简介 虚幻智能指针库 为C++11智能指针的自定义实现，旨在减轻内存分配和追踪的负担。该实现包括行业标准 共享指针、弱指针 和 唯一指针。其还可添加 共享引用，此类引用的行为与不可为空的共享指针相同。  根据官方文档，与 C++ 标准库相比，虚幻引擎新增了共享引用的概念。智能指针的实现位于 C"><meta property="og:type" content="article"><meta property="og:title" content="UE5 智能指针详解"><meta property="og:url" content="https://yuerer.com/UE5%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3/index.html"><meta property="og:site_name" content="Yuerer&#39;s Blog"><meta property="og:description" content="本文以 UE5.4 为基准，讲解智能指针的实现机制。阅读本文前需要对 C++11 的智能指针有基本了解。 简介 虚幻智能指针库 为C++11智能指针的自定义实现，旨在减轻内存分配和追踪的负担。该实现包括行业标准 共享指针、弱指针 和 唯一指针。其还可添加 共享引用，此类引用的行为与不可为空的共享指针相同。  根据官方文档，与 C++ 标准库相比，虚幻引擎新增了共享引用的概念。智能指针的实现位于 C"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2025-02-16T04:50:20.000Z"><meta property="article:modified_time" content="2025-10-21T13:50:52.262Z"><meta property="article:author" content="Yuerer"><meta property="article:tag" content="UE5"><meta property="article:tag" content="智能指针"><meta property="article:tag" content="TSharedPtr"><meta property="article:tag" content="TSharedRef"><meta property="article:tag" content="TWeakPtr"><meta property="article:tag" content="TUniquePtr"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://yuerer.com/UE5%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://yuerer.com/UE5%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3/","path":"UE5 智能指针详解/","title":"UE5 智能指针详解"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>UE5 智能指针详解 | Yuerer's Blog</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-129491388-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-129491388-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/third-party/analytics/google-analytics.min.js"></script><link rel="dns-prefetch" href="https://yuerer-comment-xufei-0bea01e6f05-1307930306.ap-shanghai.app.tcloudbase.com"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Yuerer's Blog</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">钰儿的Blog</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-text">线程安全</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="nav-text">引用计数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TSharedPtr"><span class="nav-text">TSharedPtr</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TWeakPtr"><span class="nav-text">TWeakPtr</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TSharedRef"><span class="nav-text">TSharedRef</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TSharedFromThis"><span class="nav-text">TSharedFromThis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TUniquePtr"><span class="nav-text">TUniquePtr</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Yuerer" src="/images/avatar.jpeg"><p class="site-author-name" itemprop="name">Yuerer</p><div class="site-description" itemprop="description">钰儿的Blog</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">65</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">16</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">90</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/Yu2erer" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Yu2erer" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:yu2erer#gmail.com" title="E-Mail → mailto:yu2erer#gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://yuerer.com/UE5%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpeg"><meta itemprop="name" content="Yuerer"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Yuerer's Blog"><meta itemprop="description" content="钰儿的Blog"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="UE5 智能指针详解 | Yuerer's Blog"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">UE5 智能指针详解</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-02-16 12:50:20" itemprop="dateCreated datePublished" datetime="2025-02-16T12:50:20+08:00">2025-02-16</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UE/" itemprop="url" rel="index"><span itemprop="name">UE</span></a> </span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Waline：</span> <a title="waline" href="/UE5%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/UE5%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3/" itemprop="commentCount"></span> </a></span><span class="post-meta-item" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="waline-pageview-count" data-path="/UE5%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3/"></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>本文以 UE5.4 为基准，讲解智能指针的实现机制。阅读本文前需要对 C++11 的智能指针有基本了解。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li><strong>虚幻智能指针库</strong> 为C++11智能指针的自定义实现，旨在减轻内存分配和追踪的负担。该实现包括行业标准 <strong>共享指针</strong>、<strong>弱指针</strong> 和 <strong>唯一指针</strong>。其还可添加 <strong>共享引用</strong>，此类引用的行为与不可为空的共享指针相同。</li></ul><p>根据官方文档，与 C++ 标准库相比，虚幻引擎新增了共享引用的概念。智能指针的实现位于 <code>Core</code> 模块下。</p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>UE 的智能指针分为两种模式，表示是否为线程安全。这里所说的线程安全仅指其内部的引用计数器是否线程安全。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">ESPMode</span> : uint8</span><br><span class="line">&#123;</span><br><span class="line">    NotThreadSafe = <span class="number">0</span>,</span><br><span class="line">    ThreadSafe = <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>默认为 <code>ThreadSafe</code> 和 C++标准库保持一致。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">ObjectType</span>, ESPMode Mode = ESPMode::ThreadSafe &gt; <span class="keyword">class</span> TSharedRef;</span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">ObjectType</span>, ESPMode Mode = ESPMode::ThreadSafe &gt; <span class="keyword">class</span> TSharedPtr;</span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">ObjectType</span>, ESPMode Mode = ESPMode::ThreadSafe &gt; <span class="keyword">class</span> TWeakPtr;</span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">ObjectType</span>, ESPMode Mode = ESPMode::ThreadSafe &gt; <span class="keyword">class</span> TSharedFromThis;</span><br></pre></td></tr></table></figure><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>引用控制器（以下简称控制块）中记录了共享引用次数和弱引用次数。</p><p>若为线程安全，内部计数器采用原子操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;ESPMode Mode&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TReferenceControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> RefCountType = std::<span class="type">conditional_t</span>&lt;Mode == ESPMode::ThreadSafe, std::atomic&lt;int32&gt;, int32&gt;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RefCountType SharedReferenceCount&#123;<span class="number">1</span>&#125;;</span><br><span class="line">    RefCountType WeakReferenceCount&#123;<span class="number">1</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><span id="more"></span><p>一个值得注意的地方是，即使 <code>SharedReferenceCount</code> 为 0，控制块也不一定会被销毁（当然对象本身已经销毁），只有当 <code>WeakReferenceCount</code> 也为 0 时，控制块才会被销毁。</p><ol><li><strong>对象销毁仅由共享引用计数控制</strong></li><li><strong>引用控制器销毁由弱引用计数控制</strong></li></ol><p>控制块带有 <code>Base</code> 后缀，表示它是基类。实际使用时，分别是 <code>FSharedReferencer</code> 和 <code>FWeakReferencer</code> 这两个类，它们对应两种指针的控制块。</p><p>它们以组合方式持有指向基类的指针，并且互为友元，这样在相互构造（共享指针或弱指针）时，能够增加或减少对方的引用计数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; ESPMode Mode &gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FSharedReferencer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt; ESPMode OtherMode &gt; <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">FWeakReferencer</span>;</span><br><span class="line"></span><br><span class="line">    TReferenceControllerBase&lt;Mode&gt;* ReferenceController;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; ESPMode Mode &gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FWeakReferencer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt; ESPMode OtherMode &gt; <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">FSharedReferencer</span>;</span><br><span class="line"></span><br><span class="line">    TReferenceControllerBase&lt;Mode&gt;* ReferenceController;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>控制块还有两种版本，一个是带删除器的版本，另一个是侵入式控制块。</p><p>先来了解一下删除器。</p><p>删除器通过重载 <code>operator()</code> 来实现在析构时执行特定行为，当然也可以使用 Lambda，编译器会自动将 Lambda 转换为含有 operator() 的类。删除器通常用于 C 风格数组，需要调用 <code>delete[]</code>。</p><p>删除器包装类有两个实现，其中一个将删除器作为成员变量。</p><p>是否将删除器作为成员变量，取决于 <code>DeleterType</code> 是否为空。这是因为编译器进行了<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/ebo">空基类优化</a>（Empty Base Optimization）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DeleterType, <span class="type">bool</span> bIsZeroSize = std::is_empty_v&lt;DeleterType&gt;&gt;</span><br><span class="line"><span class="keyword">struct</span> TDeleterHolder : <span class="keyword">private</span> DeleterType</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">TDeleterHolder</span>(DeleterType&amp;&amp; Arg)</span><br><span class="line">        : <span class="built_in">DeleterType</span>(<span class="built_in">MoveTemp</span>(Arg))</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ObjectType&gt;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">InvokeDeleter</span>(ObjectType * Object)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Invoke</span>(*<span class="built_in">static_cast</span>&lt;DeleterType*&gt;(<span class="keyword">this</span>), Object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DeleterType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TDeleterHolder</span>&lt;DeleterType, <span class="literal">false</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">TDeleterHolder</span><span class="params">(DeleterType&amp;&amp; Arg)</span></span></span><br><span class="line"><span class="function">        : Deleter(MoveTemp(Arg))</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ObjectType&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">InvokeDeleter</span><span class="params">(ObjectType * Object)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">Invoke</span>(Deleter, Object);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DeleterType Deleter;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>带删除器的控制块仅仅是在释放对象时调用删除器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ObjectType, <span class="keyword">typename</span> DeleterType, ESPMode Mode&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TReferenceControllerWithDeleter</span> : <span class="keyword">private</span> TDeleterHolder&lt;DeleterType&gt;, <span class="keyword">public</span> TReferenceControllerBase&lt;Mode&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DestroyObject</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">InvokeDeleter</span>(Object);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ObjectType* Object;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>侵入式控制块的特点是将引用计数和对象本身分配到同一块内存中，避免了二次分配，从而提高了性能。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ObjectType, ESPMode Mode&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TIntrusiveReferenceController</span> : <span class="keyword">public</span> TReferenceControllerBase&lt;Mode&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... ArgTypes&gt;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">TIntrusiveReferenceController</span><span class="params">(ArgTypes&amp;&amp;... Args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ((<span class="type">void</span>*)&amp;ObjectStorage) <span class="built_in">ObjectType</span>(<span class="built_in">Forward</span>&lt;ArgTypes&gt;(Args)...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ObjectType* <span class="title">GetObjectPtr</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (ObjectType*)&amp;ObjectStorage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DestroyObject</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">DestructItem</span>((ObjectType*)&amp;ObjectStorage);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> TTypeCompatibleBytes&lt;ObjectType&gt; ObjectStorage;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这三种控制块可以通过以下辅助方法来创建：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> SharedPointerInternals</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;ESPMode Mode, <span class="keyword">typename</span> ObjectType&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> TReferenceControllerBase&lt;Mode&gt;* <span class="title">NewDefaultReferenceController</span><span class="params">(ObjectType* Object)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TReferenceControllerWithDeleter&lt;ObjectType, DefaultDeleter&lt;ObjectType&gt;, Mode&gt;(Object, <span class="built_in">DefaultDeleter</span>&lt;ObjectType&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;ESPMode Mode, <span class="keyword">typename</span> ObjectType, <span class="keyword">typename</span> DeleterType&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> TReferenceControllerBase&lt;Mode&gt;* <span class="title">NewCustomReferenceController</span><span class="params">(ObjectType* Object, DeleterType&amp;&amp; Deleter)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TReferenceControllerWithDeleter&lt;ObjectType, <span class="keyword">typename</span> TRemoveReference&lt;DeleterType&gt;::Type, Mode&gt;(Object, <span class="built_in">Forward</span>&lt;DeleterType&gt;(Deleter));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;ESPMode Mode, <span class="keyword">typename</span> ObjectType, <span class="keyword">typename</span>... ArgTypes&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> TIntrusiveReferenceController&lt;ObjectType, Mode&gt;* <span class="title">NewIntrusiveReferenceController</span><span class="params">(ArgTypes&amp;&amp;... Args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TIntrusiveReferenceController</span>&lt;ObjectType, Mode&gt;(<span class="built_in">Forward</span>&lt;ArgTypes&gt;(Args)...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TSharedPtr"><a href="#TSharedPtr" class="headerlink" title="TSharedPtr"></a>TSharedPtr</h2><p>有了控制块后，就可以来实现智能指针了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">ObjectType</span>, ESPMode InMode &gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TSharedPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ElementType = ObjectType;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> ESPMode Mode = InMode;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">OtherType</span>, ESPMode OtherMode &gt; <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">TSharedPtr</span>;</span><br><span class="line">    <span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">OtherType</span>, ESPMode OtherMode &gt; <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">TSharedRef</span>;</span><br><span class="line">    <span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">OtherType</span>, ESPMode OtherMode &gt; <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">TWeakPtr</span>;</span><br><span class="line">    <span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">OtherType</span>, ESPMode OtherMode &gt; <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">TSharedFromThis</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ObjectType* Object;</span><br><span class="line">    SharedPointerInternals::FSharedReferencer&lt; Mode &gt; SharedReferenceCount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>构造空共享指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FORCEINLINE <span class="title">TSharedPtr</span><span class="params">( SharedPointerInternals::FNullTag* = <span class="literal">nullptr</span> )</span></span></span><br><span class="line"><span class="function">    : Object( nullptr )</span></span><br><span class="line"><span class="function">    , SharedReferenceCount()</span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造共享指针，允许为 nullptr，与 <code>std::shared_ptr</code> 行为对齐。</p><p><code>EnableSharedFromThis</code> 类似 <code>shared_from_this</code> 用于传递自身指针，但用共享指针包装。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;</span><br><span class="line">    <span class="keyword">typename</span> OtherType,</span><br><span class="line">    <span class="keyword">typename</span> = <span class="keyword">decltype</span>(<span class="built_in">ImplicitConv</span>&lt;ObjectType*&gt;((OtherType*)<span class="literal">nullptr</span>))</span><br><span class="line">&gt;</span><br><span class="line">FORCEINLINE <span class="keyword">explicit</span> <span class="built_in">TSharedPtr</span>( OtherType* InObject )</span><br><span class="line">    : <span class="built_in">Object</span>( InObject )</span><br><span class="line">    , <span class="built_in">SharedReferenceCount</span>( SharedPointerInternals::<span class="built_in">NewDefaultReferenceController</span>&lt; Mode &gt;( InObject ) )</span><br><span class="line">&#123;</span><br><span class="line">    SharedPointerInternals::<span class="built_in">EnableSharedFromThis</span>( <span class="keyword">this</span>, InObject, InObject );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跳过其他拷贝构造、移动构造、拷贝赋值、移动赋值的实现，以及带自定义删除器相关的构造函数。</p><p>由 <code>TRawPtrProxy</code> 隐式构造出 <code>TSharedPtr</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;</span><br><span class="line">    <span class="keyword">typename</span> OtherType,</span><br><span class="line">    <span class="keyword">typename</span> = <span class="keyword">decltype</span>(<span class="built_in">ImplicitConv</span>&lt;ObjectType*&gt;((OtherType*)<span class="literal">nullptr</span>))</span><br><span class="line">&gt;</span><br><span class="line">FORCEINLINE <span class="built_in">TSharedPtr</span>( SharedPointerInternals::TRawPtrProxy&lt; OtherType &gt; <span class="type">const</span>&amp; InRawPtrProxy )</span><br><span class="line">    : <span class="built_in">Object</span>( InRawPtrProxy.Object )</span><br><span class="line">    , <span class="built_in">SharedReferenceCount</span>( SharedPointerInternals::<span class="built_in">NewDefaultReferenceController</span>&lt; Mode &gt;( InRawPtrProxy.Object ) )</span><br><span class="line">&#123;</span><br><span class="line">    SharedPointerInternals::<span class="built_in">EnableSharedFromThis</span>( <span class="keyword">this</span>, InRawPtrProxy.Object, InRawPtrProxy.Object );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TRawPtrProxy</code> 是用 <code>MakeShareable</code> 辅助函数构造出来的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">ObjectType</span> &gt;</span><br><span class="line">[[nodiscard]] <span class="function">FORCEINLINE SharedPointerInternals::TRawPtrProxy&lt; ObjectType &gt; <span class="title">MakeShareable</span><span class="params">( ObjectType* InObject )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SharedPointerInternals::<span class="built_in">TRawPtrProxy</span>&lt; ObjectType &gt;( InObject );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此切忌，不要用 <code>auto</code> 去接 <code>MakeShareable</code> 的返回值，因为它返回的不是 <code>TSharedPtr</code> 而是 <code>TRawPtrProxy</code> ，但它可以隐式构造为 <code>TSharedPtr</code> 和 <code>TSharedRef</code> (这点后面可以看到)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> RawPtrProxy = <span class="built_in">MakeShareable</span>(obj); <span class="comment">// ERROR</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TWeakPtr"><a href="#TWeakPtr" class="headerlink" title="TWeakPtr"></a>TWeakPtr</h2><p><code>TWeakPtr</code> 的控制块总是从其他地方获取，而不是通过 new 创建的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">ObjectType</span>, ESPMode InMode &gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TWeakPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">using</span> ElementType = ObjectType;</span><br><span class="line">	<span class="type">static</span> <span class="keyword">constexpr</span> ESPMode Mode = InMode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">OtherType</span>, ESPMode OtherMode &gt; <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">TWeakPtr</span>;</span><br><span class="line">    <span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">OtherType</span>, ESPMode OtherMode &gt; <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">TSharedPtr</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	ObjectType* Object;</span><br><span class="line">	SharedPointerInternals::FWeakReferencer&lt; Mode &gt; WeakReferenceCount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>简单看三类构造函数吧，第一类是从 <code>TSharedPtr</code> 构造 <code>TWeakPtr</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;</span><br><span class="line">    <span class="keyword">typename</span> OtherType,</span><br><span class="line">    <span class="keyword">typename</span> = <span class="keyword">decltype</span>(<span class="built_in">ImplicitConv</span>&lt;ObjectType*&gt;((OtherType*)<span class="literal">nullptr</span>))</span><br><span class="line">&gt;</span><br><span class="line">FORCEINLINE <span class="built_in">TWeakPtr</span>( TSharedPtr&lt; OtherType, Mode &gt; <span class="type">const</span>&amp; InSharedPtr )</span><br><span class="line">    : <span class="built_in">Object</span>( InSharedPtr.Object )</span><br><span class="line">    , <span class="built_in">WeakReferenceCount</span>( InSharedPtr.SharedReferenceCount )</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二类从 <code>TSharedRef</code> 构造 <code>TWeakPtr</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;</span><br><span class="line">    <span class="keyword">typename</span> OtherType,</span><br><span class="line">    <span class="keyword">typename</span> = <span class="keyword">decltype</span>(<span class="built_in">ImplicitConv</span>&lt;ObjectType*&gt;((OtherType*)<span class="literal">nullptr</span>))</span><br><span class="line">&gt;</span><br><span class="line">FORCEINLINE <span class="built_in">TWeakPtr</span>( TSharedRef&lt; OtherType, Mode &gt; <span class="type">const</span>&amp; InSharedRef )</span><br><span class="line">    : <span class="built_in">Object</span>( InSharedRef.Object )</span><br><span class="line">    , <span class="built_in">WeakReferenceCount</span>( InSharedRef.SharedReferenceCount )</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三类从 <code>TWeakPtr</code> 构造 <code>TWeakPtr</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;</span><br><span class="line">    <span class="keyword">typename</span> OtherType,</span><br><span class="line">    <span class="keyword">typename</span> = <span class="keyword">decltype</span>(<span class="built_in">ImplicitConv</span>&lt;ObjectType*&gt;((OtherType*)<span class="literal">nullptr</span>))</span><br><span class="line">&gt;</span><br><span class="line">FORCEINLINE <span class="built_in">TWeakPtr</span>( TWeakPtr&lt; OtherType, Mode &gt; <span class="type">const</span>&amp; InWeakPtr )</span><br><span class="line">    : <span class="built_in">Object</span>( InWeakPtr.Object )</span><br><span class="line">    , <span class="built_in">WeakReferenceCount</span>( InWeakPtr.WeakReferenceCount )</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 <code>TWeakPtr</code> 转换为 <code>TSharedPtr</code> 时，注意共享指针可能已经被释放。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[nodiscard]] <span class="function">FORCEINLINE TSharedPtr&lt; ObjectType, Mode &gt; <span class="title">Pin</span><span class="params">()</span> &amp;&amp;</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">TSharedPtr</span>&lt; ObjectType, Mode &gt;( <span class="built_in">MoveTemp</span>( *<span class="keyword">this</span> ) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TSharedRef"><a href="#TSharedRef" class="headerlink" title="TSharedRef"></a>TSharedRef</h2><p><code>TSharedRef</code> 是 Unreal 引擎的扩展，与引用类似，但它不能为空，Unreal 推荐优先使用它，因为不需要担心为空的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">ObjectType</span>, ESPMode InMode &gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TSharedRef</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ElementType = ObjectType;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> ESPMode Mode = InMode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">OtherType</span>, ESPMode OtherMode &gt; <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">TSharedRef</span>;</span><br><span class="line">    <span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">OtherType</span>, ESPMode OtherMode &gt; <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">TSharedPtr</span>;</span><br><span class="line">    <span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">OtherType</span>, ESPMode OtherMode &gt; <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">TWeakPtr</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ObjectType* Object;</span><br><span class="line">    SharedPointerInternals::FSharedReferencer&lt; Mode &gt; SharedReferenceCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> TSharedRef UE::Core::Private::<span class="built_in">MakeSharedRef</span>&lt;ObjectType, Mode&gt;(ObjectType* InObject, SharedPointerInternals::TReferenceControllerBase&lt;Mode&gt;* InSharedReferenceCount);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>MakeSharedRef</code> 是为实现 <code>MakeShared</code> 函数而提供的辅助方法，用于构造 <code>TSharedRef</code>。Unreal 推荐使用 <code>MakeShared</code>，因为它允许直接用 <code>auto</code> 获取返回值，并且采用了侵入式引用控制块，这会将引用计数和对象本身放在同一块堆内存中，而不是分开分配。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InObjectType, ESPMode InMode = ESPMode::ThreadSafe, <span class="keyword">typename</span>... InArgTypes&gt;</span><br><span class="line">[[nodiscard]] FORCEINLINE TSharedRef&lt;InObjectType, InMode&gt; <span class="built_in">MakeShared</span>(InArgTypes&amp;&amp;... Args)</span><br><span class="line">&#123;</span><br><span class="line">    SharedPointerInternals::TIntrusiveReferenceController&lt;InObjectType, InMode&gt;* Controller = SharedPointerInternals::<span class="built_in">NewIntrusiveReferenceController</span>&lt;InMode, InObjectType&gt;(<span class="built_in">Forward</span>&lt;InArgTypes&gt;(Args)...);</span><br><span class="line">    <span class="keyword">return</span> UE::Core::Private::<span class="built_in">MakeSharedRef</span>&lt;InObjectType, InMode&gt;(Controller-&gt;<span class="built_in">GetObjectPtr</span>(), (SharedPointerInternals::TReferenceControllerBase&lt;InMode&gt;*)Controller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TSharedRef</code> 也可以通过 <code>TRawPtrProxy</code> 隐式构造，而 <code>MakeShareable</code> 也能方便地创建 <code>Ref</code> 或 <code>Ptr</code> 类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;</span><br><span class="line">    <span class="keyword">typename</span> OtherType,</span><br><span class="line">    <span class="keyword">typename</span> = <span class="keyword">decltype</span>(<span class="built_in">ImplicitConv</span>&lt;ObjectType*&gt;((OtherType*)<span class="literal">nullptr</span>))</span><br><span class="line">&gt;</span><br><span class="line">FORCEINLINE <span class="built_in">TSharedRef</span>( SharedPointerInternals::TRawPtrProxy&lt; OtherType &gt; <span class="type">const</span>&amp; InRawPtrProxy )</span><br><span class="line">    : <span class="built_in">Object</span>( InRawPtrProxy.Object )</span><br><span class="line">    , <span class="built_in">SharedReferenceCount</span>( SharedPointerInternals::<span class="built_in">NewDefaultReferenceController</span>&lt; Mode &gt;( InRawPtrProxy.Object ) )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">check</span>( InRawPtrProxy.Object != <span class="literal">nullptr</span> );</span><br><span class="line"></span><br><span class="line">    SharedPointerInternals::<span class="built_in">EnableSharedFromThis</span>( <span class="keyword">this</span>, InRawPtrProxy.Object, InRawPtrProxy.Object );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，Unreal 也实现了类似于 C++ 标准库中的 <code>std::static_pointer_cast</code>，这里称为 <code>StaticCastSharedPtr</code>。虽然还实现了 <code>ConstCastSharedPtr</code>，但并没有实现 <code>std::dynamic_pointer_cast</code>，因此在进行下行转型时需要特别小心，可能会导致崩溃。</p><h2 id="TSharedFromThis"><a href="#TSharedFromThis" class="headerlink" title="TSharedFromThis"></a>TSharedFromThis</h2><p>前面提到过 类似C++ 标准库的 <code>shared_from_this</code> 。</p><p>其实现原理是通过存储当前对象的弱指针 (WeakThis)，当需要将当前对象封装为共享指针时，使用 <code>AsShared</code> 函数即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">ObjectType</span>, ESPMode Mode &gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TSharedFromThis</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    [[nodiscard]] <span class="function">TSharedRef&lt; ObjectType, Mode &gt; <span class="title">AsShared</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">TSharedPtr&lt; ObjectType, Mode &gt; <span class="title">SharedThis</span><span class="params">( WeakThis.Pin() )</span></span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">MoveTemp</span>( SharedThis ).<span class="built_in">ToSharedRef</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [[nodiscard]] <span class="function">TWeakPtr&lt; ObjectType, Mode &gt; <span class="title">AsWeak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TWeakPtr&lt; ObjectType, Mode &gt; Result = WeakThis;</span><br><span class="line">        <span class="keyword">return</span> Result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">OtherType</span> &gt;</span><br><span class="line">    [[nodiscard]] <span class="function">FORCEINLINE <span class="type">static</span> TSharedRef&lt; OtherType, Mode &gt; <span class="title">SharedThis</span><span class="params">( OtherType* ThisPtr )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">StaticCastSharedRef</span>&lt; OtherType &gt;( ThisPtr-&gt;<span class="built_in">AsShared</span>() );</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> TWeakPtr&lt; ObjectType, Mode &gt; WeakThis;	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>两个内部函数用于存储 <code>WeakThis</code>，它们会在调用 <code>SharedPointerInternals::EnableSharedFromThis</code> 时被触发，并在智能指针构造过程中使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> SharedPtrType, <span class="keyword">class</span> OtherType &gt;</span></span><br><span class="line"><span class="function">FORCEINLINE <span class="type">void</span> <span class="title">UpdateWeakReferenceInternal</span><span class="params">( TSharedPtr&lt; SharedPtrType, Mode &gt; <span class="type">const</span>* InSharedPtr, OtherType* InObject )</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( !WeakThis.<span class="built_in">IsValid</span>() )</span><br><span class="line">    &#123;</span><br><span class="line">        WeakThis = <span class="built_in">TSharedPtr</span>&lt; ObjectType, Mode &gt;( *InSharedPtr, InObject );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> SharedRefType, <span class="keyword">class</span> OtherType &gt;</span></span><br><span class="line"><span class="function">FORCEINLINE <span class="type">void</span> <span class="title">UpdateWeakReferenceInternal</span><span class="params">( TSharedRef&lt; SharedRefType, Mode &gt; <span class="type">const</span>* InSharedRef, OtherType* InObject )</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( !WeakThis.<span class="built_in">IsValid</span>() )</span><br><span class="line">    &#123;</span><br><span class="line">        WeakThis = <span class="built_in">TSharedRef</span>&lt; ObjectType, Mode &gt;( *InSharedRef, InObject );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TUniquePtr"><a href="#TUniquePtr" class="headerlink" title="TUniquePtr"></a>TUniquePtr</h2><p><code>TUniquePtr</code> 提供了两个模板：一个是普通对象，另一个是 C 风格数组的偏特化版本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Deleter = TDefaultDelete&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> TUniquePtr : <span class="keyword">private</span> Deleter;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Deleter&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TUniquePtr</span>&lt;T[], Deleter&gt; : <span class="keyword">private</span> Deleter;</span><br></pre></td></tr></table></figure><p>包含一个成员。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T* Ptr;</span><br></pre></td></tr></table></figure><p>不同的删除器会调用不同的 <code>delete</code> 方式，例如 C 风格数组会调用 <code>delete []</code>。</p><p>TUniquePtr 禁止拷贝构造和拷贝赋值，在析构时会调用删除器释放内存，这部分实现非常简洁，就略过吧。</p></div><footer class="post-footer"><div class="post-tags"><a href="/tags/UE5/" rel="tag"># UE5</a> <a href="/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" rel="tag"># 智能指针</a> <a href="/tags/TSharedPtr/" rel="tag"># TSharedPtr</a> <a href="/tags/TSharedRef/" rel="tag"># TSharedRef</a> <a href="/tags/TWeakPtr/" rel="tag"># TWeakPtr</a> <a href="/tags/TUniquePtr/" rel="tag"># TUniquePtr</a></div><div class="post-nav"><div class="post-nav-item"><a href="/UE5%20%E8%93%9D%E5%9B%BE%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B%E5%89%96%E6%9E%90/" rel="prev" title="UE5 蓝图编译流程剖析"><i class="fa fa-angle-left"></i> UE5 蓝图编译流程剖析</a></div><div class="post-nav-item"><a href="/UE5%20UnLua%20%E8%84%9A%E6%9C%AC%E6%96%B9%E6%A1%88%E5%8E%9F%E7%90%86/" rel="next" title="UE5 UnLua 脚本方案原理">UE5 UnLua 脚本方案原理 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Yuerer</span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://unpkg.com/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://unpkg.com/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/comments.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/utils.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/motion.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/sidebar.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/next-boot.min.js"></script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://yuerer-comment-xufei-0bea01e6f05-1307930306.ap-shanghai.app.tcloudbase.com","cssUrl":"https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.css","commentCount":true,"pageview":true,"libUrl":"https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.js","locale":{"placeholder":"有何高见？"},"emoji":["https://unpkg.com/@waline/emojis@1.0.1/qq"],"meta":["nick","mail"],"requiredMeta":[["nick","mail"]],"wordLimit":0,"login":"disable","pageSize":10,"el":"#waline","comment":true,"path":"/UE5%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3/"}</script><link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.css"><script>document.addEventListener("page:loaded",()=>{NexT.utils.loadComments(CONFIG.waline.el).then(()=>NexT.utils.getScript(CONFIG.waline.libUrl,{condition:window.Waline})).then(()=>Waline.init(Object.assign({},CONFIG.waline,{el:document.querySelector(CONFIG.waline.el)})))})</script></body></html>