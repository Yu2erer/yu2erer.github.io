<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.jpeg"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.ico"><link rel="mask-icon" href="/images/avatar.jpeg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous"><link rel="stylesheet" href="https://unpkg.com/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"yuerer.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"hide","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":true,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/config.min.js"></script><meta name="description" content="UE5 的垃圾回收（GC）采用 标记-清除（Mark &amp; Sweep） 策略，通过遍历对象引用关系确定可达对象并清理其余内存。本文聚焦 UE5.6 的 增量垃圾回收，尤其是 增量标记（Incremental Marking） 的最新变化，以及 工程上实现该算法的优化。阅读前如已熟悉通用 GC 原理（例如 Lua 的三色标记），会更易理解 UE 的实现细节与优化策略。 从 STW 到 增量扫"><meta property="og:type" content="article"><meta property="og:title" content="UE5 增量垃圾回收深度解析"><meta property="og:url" content="https://yuerer.com/UE5%20%E5%A2%9E%E9%87%8F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/index.html"><meta property="og:site_name" content="Yuerer&#39;s Blog"><meta property="og:description" content="UE5 的垃圾回收（GC）采用 标记-清除（Mark &amp; Sweep） 策略，通过遍历对象引用关系确定可达对象并清理其余内存。本文聚焦 UE5.6 的 增量垃圾回收，尤其是 增量标记（Incremental Marking） 的最新变化，以及 工程上实现该算法的优化。阅读前如已熟悉通用 GC 原理（例如 Lua 的三色标记），会更易理解 UE 的实现细节与优化策略。 从 STW 到 增量扫"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://yuerer.com/images/UE5%E5%A2%9E%E9%87%8F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90-1761635111650.png"><meta property="og:image" content="https://yuerer.com/images/UE5%E5%A2%9E%E9%87%8F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90-1761634938385.png"><meta property="og:image" content="https://yuerer.com/images/UE5%E5%A2%9E%E9%87%8F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90.png"><meta property="article:published_time" content="2025-10-30T13:40:20.000Z"><meta property="article:modified_time" content="2025-10-30T13:46:49.005Z"><meta property="article:author" content="Yuerer"><meta property="article:tag" content="UE5"><meta property="article:tag" content="GC"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://yuerer.com/images/UE5%E5%A2%9E%E9%87%8F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90-1761635111650.png"><link rel="canonical" href="https://yuerer.com/UE5%20%E5%A2%9E%E9%87%8F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://yuerer.com/UE5%20%E5%A2%9E%E9%87%8F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/","path":"UE5 增量垃圾回收深度解析/","title":"UE5 增量垃圾回收深度解析"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>UE5 增量垃圾回收深度解析 | Yuerer's Blog</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-129491388-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-129491388-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/third-party/analytics/google-analytics.min.js"></script><link rel="dns-prefetch" href="https://yuerer-comment-xufei-0bea01e6f05-1307930306.ap-shanghai.app.tcloudbase.com"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Yuerer's Blog</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">钰儿的Blog</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E-STW-%E5%88%B0-%E5%A2%9E%E9%87%8F%E6%89%AB%E6%8F%8F"><span class="nav-text">从 STW 到 增量扫描</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D"><span class="nav-text">对象分配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E6%A6%82%E5%BF%B5"><span class="nav-text">关键结构与概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GUObjectArray%EF%BC%88%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%E8%A1%A8%EF%BC%89"><span class="nav-text">GUObjectArray（全局对象表）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FUObjectItem%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9D%A1%E7%9B%AE%EF%BC%89"><span class="nav-text">FUObjectItem（对象条目）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Disregard-%E5%8C%BA%EF%BC%88%E9%9D%9E-GC-%E5%AF%B9%E8%B1%A1%E5%8C%BA%EF%BC%89"><span class="nav-text">Disregard 区（非 GC 对象区）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cluster%EF%BC%88%E7%B0%87%EF%BC%89"><span class="nav-text">Cluster（簇）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E8%B5%8B%E5%80%BC%EF%BC%88%E5%86%99%E5%B1%8F%E9%9A%9C%EF%BC%89"><span class="nav-text">对象赋值（写屏障）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A2%9E%E9%87%8F-GC"><span class="nav-text">增量 GC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A2%9E%E9%87%8F%E6%89%AB%E6%8F%8F%EF%BC%88Reachability-Pass%EF%BC%89"><span class="nav-text">增量扫描（Reachability Pass）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E7%BD%AE%E5%8F%AF%E8%BE%BE%E6%A0%87%E8%AE%B0"><span class="nav-text">重置可达标记</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%B6%E9%9B%86%E5%BC%BA%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1"><span class="nav-text">收集强引用对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A2%9E%E9%87%8F%E6%89%AB%E6%8F%8F%E7%9A%84%E5%86%99%E5%B1%8F%E9%9A%9C%E5%A4%84%E7%90%86"><span class="nav-text">增量扫描的写屏障处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E6%89%AB%E6%8F%8F"><span class="nav-text">引用扫描</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0%E5%8F%AF%E8%BE%BE%E5%AF%B9%E8%B1%A1"><span class="nav-text">标记可达对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%B6%E9%9B%86%E4%B8%8D%E5%8F%AF%E8%BE%BE%E5%AF%B9%E8%B1%A1"><span class="nav-text">收集不可达对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B8%85%E7%90%86%EF%BC%88Sweep-Purge%EF%BC%89"><span class="nav-text">清理（Sweep &#x2F; Purge）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E5%8F%82"><span class="nav-text">调参</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Yuerer" src="/images/avatar.jpeg"><p class="site-author-name" itemprop="name">Yuerer</p><div class="site-description" itemprop="description">钰儿的Blog</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">65</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">16</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">90</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/Yu2erer" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Yu2erer" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:yu2erer#gmail.com" title="E-Mail → mailto:yu2erer#gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://yuerer.com/UE5%20%E5%A2%9E%E9%87%8F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpeg"><meta itemprop="name" content="Yuerer"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Yuerer's Blog"><meta itemprop="description" content="钰儿的Blog"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="UE5 增量垃圾回收深度解析 | Yuerer's Blog"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">UE5 增量垃圾回收深度解析</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-10-30 21:40:20" itemprop="dateCreated datePublished" datetime="2025-10-30T21:40:20+08:00">2025-10-30</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UE/" itemprop="url" rel="index"><span itemprop="name">UE</span></a> </span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Waline：</span> <a title="waline" href="/UE5%20%E5%A2%9E%E9%87%8F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/UE5%20%E5%A2%9E%E9%87%8F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/" itemprop="commentCount"></span> </a></span><span class="post-meta-item" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="waline-pageview-count" data-path="/UE5%20%E5%A2%9E%E9%87%8F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/"></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>UE5 的垃圾回收（GC）采用 <strong>标记-清除（Mark &amp; Sweep）</strong> 策略，通过遍历对象引用关系确定可达对象并清理其余内存。本文聚焦 <strong>UE5.6</strong> 的 <strong>增量垃圾回收</strong>，尤其是 <strong>增量标记（Incremental Marking）</strong> 的最新变化，以及 <strong>工程上实现该算法的优化</strong>。阅读前如已熟悉通用 GC 原理（例如 Lua 的三色标记），会更易理解 UE 的实现细节与优化策略。</p><h2 id="从-STW-到-增量扫描"><a href="#从-STW-到-增量扫描" class="headerlink" title="从 STW 到 增量扫描"></a>从 STW 到 增量扫描</h2><p>在 UE5.4 之前，GC 的可达性分析通常以 <strong>一次性完成（Stop-the-World）</strong> 的方式进行：扫描阶段暂停游戏逻辑，实现简单，但缺点是 停顿时间可能较长，带来 Gameplay 卡顿。<br>从 UE5.4 起，引擎引入 增量扫描：将可达性分析拆分到多帧执行，平滑每帧的 GC 开销。这引出了一个核心问题：</p><blockquote><p>扫描间隙产生的新对象&#x2F;新引用如何处理？</p></blockquote><h2 id="对象分配"><a href="#对象分配" class="headerlink" title="对象分配"></a>对象分配</h2><p>对象通过 <code>NewObject</code> 分配时，会进入 <code>UObjectBase</code> 构造并注册到全局对象表 <code>GUObjectArray</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">UObjectBase::<span class="built_in">UObjectBase</span>(UClass* InClass,</span><br><span class="line">    EObjectFlags InFlags,</span><br><span class="line">    EInternalObjectFlags InInternalFlags,</span><br><span class="line">    UObject *InOuter,</span><br><span class="line">    FName InName,</span><br><span class="line">    int32 InInternalIndex,</span><br><span class="line">    int32 InSerialNumber,</span><br><span class="line">    FRemoteObjectId InRemoteId)</span><br><span class="line">:   <span class="built_in">ObjectFlags</span>(InFlags)</span><br><span class="line">,   <span class="built_in">InternalIndex</span>(INDEX_NONE)</span><br><span class="line">,   <span class="built_in">ClassPrivate</span>(InClass)</span><br><span class="line">,   <span class="built_in">OuterPrivate</span>(InOuter)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">AddObject</span>(InName, InInternalFlags, InInternalIndex, InSerialNumber, InRemoteId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AddObject</code> 会把对象注册到 <code>GUObjectArray</code> 并设置内部标志位：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UObjectBase::AddObject</span><span class="params">(FName InName, EInternalObjectFlags InSetInternalFlags, int32 InInternalIndex, int32 InSerialNumber, FRemoteObjectId InRemoteId)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NamePrivate = InName;</span><br><span class="line">    EInternalObjectFlags InternalFlagsToSet = InSetInternalFlags;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">IsInGameThread</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        InternalFlagsToSet |= EInternalObjectFlags::Async;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ObjectFlags &amp; RF_MarkAsRootSet)</span><br><span class="line">    &#123;</span><br><span class="line">        InternalFlagsToSet |= EInternalObjectFlags::RootSet;</span><br><span class="line">        ObjectFlags &amp;= ~RF_MarkAsRootSet;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ObjectFlags &amp; RF_MarkAsNative)</span><br><span class="line">    &#123;</span><br><span class="line">        InternalFlagsToSet |= EInternalObjectFlags::Native;</span><br><span class="line">        ObjectFlags &amp;= ~RF_MarkAsNative;</span><br><span class="line">    &#125;</span><br><span class="line">    GUObjectArray.<span class="built_in">AllocateUObjectIndex</span>(<span class="keyword">this</span>, InternalFlagsToSet, InInternalIndex, InSerialNumber, InRemoteId);</span><br><span class="line">    <span class="built_in">HashObject</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>AllocateUObjectIndex</code> 中，可见关键点：非 “DisregardForGC” 窗口下，新对象会被标上 “Reachable” 位，即默认可达：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FUObjectArray::AllocateUObjectIndex</span><span class="params">(UObjectBase* Object, EInternalObjectFlags InitialFlags, int32 AlreadyAllocatedIndex, int32 SerialNumber, FRemoteObjectId RemoteId)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">LockInternalArray</span>();</span><br><span class="line">    FUObjectItem* ObjectItem = <span class="built_in">IndexToObject</span>(Index);</span><br><span class="line">    ObjectItem-&gt;Flags = (int32)EInternalObjectFlags::PendingConstruction;</span><br><span class="line">    <span class="keyword">if</span> (!(<span class="built_in">IsOpenForDisregardForGC</span>() &amp; GUObjectArray.<span class="built_in">DisregardForGCEnabled</span>()))</span><br><span class="line">    &#123;</span><br><span class="line">        ObjectItem-&gt;Flags |= (int32)UE::GC::Private::FGCFlags::<span class="built_in">GetReachableFlagValue_ForGC</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ObjectItem-&gt;<span class="built_in">SetObject</span>(Object);  </span><br><span class="line">    ObjectItem-&gt;RefCount = <span class="number">0</span>;  </span><br><span class="line">    ObjectItem-&gt;ClusterRootIndex = <span class="number">0</span>;  </span><br><span class="line">    ObjectItem-&gt;SerialNumber = SerialNumber;</span><br><span class="line">    Object-&gt;InternalIndex = Index;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (InitialFlags != EInternalObjectFlags::None)  </span><br><span class="line">    &#123;  </span><br><span class="line">        ObjectItem-&gt;<span class="built_in">ThisThreadAtomicallySetFlag</span>(InitialFlags);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">UnlockInternalArray</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="关键结构与概念"><a href="#关键结构与概念" class="headerlink" title="关键结构与概念"></a>关键结构与概念</h3><h3 id="GUObjectArray（全局对象表）"><a href="#GUObjectArray（全局对象表）" class="headerlink" title="GUObjectArray（全局对象表）"></a>GUObjectArray（全局对象表）</h3><p>采用 分块（Chunked）固定容量 的方式保存 <code>FUObjectItem</code>，每块 65536 个元素，保证槽位地址稳定（GC 经常拿指针，避免动态扩容带来的迁移）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> COREUOBJECT_API FUObjectArray GUObjectArray;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FUObjectArray</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> FChunkedFixedUObjectArray TUObjectArray;</span><br><span class="line">    TUObjectArray ObjObjects;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FChunkedFixedUObjectArray</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">enum</span></span><br><span class="line">    &#123;</span><br><span class="line">        NumElementsPerChunk = <span class="number">64</span> * <span class="number">1024</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    FUObjectItem** Objects;</span><br><span class="line">    FUObjectItem* PreAllocatedObjects;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img data-src="/images/UE5%E5%A2%9E%E9%87%8F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90-1761635111650.png"></p><h3 id="FUObjectItem（对象条目）"><a href="#FUObjectItem（对象条目）" class="headerlink" title="FUObjectItem（对象条目）"></a>FUObjectItem（对象条目）</h3><p>为每个 <code>UObject</code> 提供 GC 所需的元数据：内部 Flags、簇信息、序列号、强引用计数等。<br>每个 <code>UObject</code> 实例都会对应一个 <code>FUObjectItem</code> 结构。<br>这里的 <code>union</code> 是一种空间优化技巧，由于 UObject 地址 8 字节对齐（低 3 位恒为 0），引擎通过拆分高低位来压缩存储（但默认没开启，所以读者可以忽略）。<br><code>Flags</code> 是 <code>EInternalObjectFlags</code> 从 <code>UObjectFlags</code> 中提取出来的一些垃圾回收关键 <code>Flags</code>，这是为了少解引用一次 <code>UObject</code> ，减少 Cache Miss。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FUObjectItem</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">UObjectBase</span>* Object = <span class="literal">nullptr</span>;</span><br><span class="line">        uint32 ObjectPtrLow; <span class="comment">// 指针压缩的空间优化，默认不开</span></span><br><span class="line">    &#125;;</span><br><span class="line">    int32 Flags;              <span class="comment">// EInternalObjectFlags</span></span><br><span class="line">    int32 ClusterRootIndex;   <span class="comment">// 所属簇根在 GUObjectArray 的索引</span></span><br><span class="line">    int32 SerialNumber;       <span class="comment">// 槽位复用用来使弱引用失效</span></span><br><span class="line">    int32 RefCount;           <span class="comment">// 强引用计数（TStrongObjectPtr）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Disregard-区（非-GC-对象区）"><a href="#Disregard-区（非-GC-对象区）" class="headerlink" title="Disregard 区（非 GC 对象区）"></a>Disregard 区（非 GC 对象区）</h3><p>引擎初始化阶段开启 <code>IsOpenForDisregardForGC()</code> 时，允许分配 <strong>不参与 GC</strong> 的对象，之后 GC 会跳过此区段扫描。<br><img data-src="/images/UE5%E5%A2%9E%E9%87%8F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90-1761634938385.png"></p><h3 id="Cluster（簇）"><a href="#Cluster（簇）" class="headerlink" title="Cluster（簇）"></a>Cluster（簇）</h3><p>将强相关对象聚合为 <strong>簇</strong>。当扫描到 <strong>簇根</strong> 时，可一次性把整簇标记为可达，显著降低图遍历成本。</p><h2 id="对象赋值（写屏障）"><a href="#对象赋值（写屏障）" class="headerlink" title="对象赋值（写屏障）"></a>对象赋值（写屏障）</h2><p>在增量扫描间隙，游戏逻辑可能会发生引用写入：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A-&gt;Target = B;</span><br></pre></td></tr></table></figure><p>如果 <code>A</code> 已扫描、<code>B</code> 尚未标记，B 可能被误扫为垃圾。为解决该一致性问题，自 UE5.4 起，推荐使用 <code>TObjectPtr</code> 以启用 写屏障，而非原生裸指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>()</span><br><span class="line">AMyWeapon* Weapon; <span class="comment">// Bad</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>()</span><br><span class="line">TObjectPtr&lt;AMyWeapon&gt; Weapon;</span><br></pre></td></tr></table></figure><p>当我们执行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyActor-&gt;Weapon = NewWeapon;</span><br></pre></td></tr></table></figure><p>底层会自动触发写屏障，从而让 GC 识别到新引用关系，并将其标记为可达。<br><code>TObjectPtr</code> 包含 <code>FObjectPtr</code> ，可以看到这个类其实啥也没做，写屏障放到了 <code>FObjectPtr</code> 里实现。</p><blockquote><p>当开启垃圾回收屏障时 <code>UE_OBJECT_PTR_GC_BARRIER</code>，需要提供自定义的构造函数和赋值运算符来让类型变成非平凡（non-trivial）的赋值类型，从而阻止编译器用 <code>memcpy/memmove</code> 绕过构造函数&#x2F;赋值运算符。</p></blockquote><p>后续将直接给出开启垃圾回收屏障版本的代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TObjectPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ElementType = T;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> UE_OBJECT_PTR_GC_BARRIER</span></span><br><span class="line">    [[nodiscard]] <span class="built_in">TObjectPtr</span>(TObjectPtr&lt;T&gt;&amp;&amp; Other)</span><br><span class="line">        : <span class="built_in">ObjectPtr</span>(<span class="built_in">MoveTemp</span>(Other.ObjectPtr))</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    [[nodiscard]] <span class="built_in">TObjectPtr</span>(<span class="type">const</span> TObjectPtr&lt;T&gt;&amp; Other)</span><br><span class="line">        : <span class="built_in">ObjectPtr</span>(Other.ObjectPtr)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    [[nodiscard]] <span class="built_in">TObjectPtr</span>(TObjectPtr&lt;T&gt;&amp;&amp; Other) = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">TObjectPtr</span>(<span class="type">const</span> TObjectPtr&lt;T&gt;&amp; Other) = <span class="keyword">default</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// UE_OBJECT_PTR_GC_BARRIER</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> UE_OBJECT_PTR_GC_BARRIER</span></span><br><span class="line">    TObjectPtr&lt;T&gt;&amp; <span class="keyword">operator</span>=(TObjectPtr&lt;T&gt;&amp;&amp; Other)</span><br><span class="line">    &#123;</span><br><span class="line">        ObjectPtr = <span class="built_in">MoveTemp</span>(Other.ObjectPtr);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TObjectPtr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> TObjectPtr&lt;T&gt;&amp; Other)</span><br><span class="line">    &#123;</span><br><span class="line">        ObjectPtr = Other.ObjectPtr;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    TObjectPtr&lt;T&gt;&amp; <span class="keyword">operator</span>=(TObjectPtr&lt;T&gt;&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    TObjectPtr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> TObjectPtr&lt;T&gt;&amp;) = <span class="keyword">default</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// UE_OBJECT_PTR_GC_BARRIER</span></span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    FObjectPtr ObjectPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看出实际做写屏障在 <code>FObjectPtr</code> 的构造&#x2F;赋值处触发：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FObjectPtr</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">mutable</span> FObjectHandle Handle;</span><br><span class="line"></span><br><span class="line">    [[nodiscard]] <span class="function"><span class="keyword">explicit</span> FORCEINLINE <span class="title">FObjectPtr</span><span class="params">(UObject* Object)</span></span></span><br><span class="line"><span class="function">        : Handle(UE::CoreUObject::Private::MakeObjectHandle(Object))</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">        <span class="built_in">ConditionallyMarkAsReachable</span>(Object);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">FORCEINLINE <span class="type">void</span> <span class="title">ConditionallyMarkAsReachable</span><span class="params">(<span class="type">const</span> UObject* InObj)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (UE::GC::GIsIncrementalReachabilityPending &amp;&amp; InObj)</span><br><span class="line">        &#123;</span><br><span class="line">            UE::GC::<span class="built_in">MarkAsReachable</span>(InObj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当 增量可达性分析进行中（<code>GIsIncrementalReachabilityPending</code> 为真）且发生新引用写入时，写屏障会把对象推入“新起点”容器，用于后续继续扫描：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> TExpandingChunkedList&lt;UObject*&gt; GReachableObjects;</span><br><span class="line"><span class="type">static</span> TExpandingChunkedList&lt;FUObjectItem*&gt; GReachableClusters;</span><br><span class="line"></span><br><span class="line"><span class="function">FORCEINLINE <span class="type">static</span> <span class="type">void</span> <span class="title">MarkObjectItemAsReachable</span><span class="params">(FUObjectItem* ObjectItem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (FGCFlags::<span class="built_in">MarkAsReachableInterlocked_ForGC</span>(ObjectItem))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ObjectItem-&gt;<span class="built_in">GetOwnerIndex</span>() &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            GReachableObjects.<span class="built_in">Push</span>(<span class="built_in">static_cast</span>&lt;UObject*&gt;(ObjectItem-&gt;<span class="built_in">GetObject</span>()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            GReachableClusters.<span class="built_in">Push</span>(ObjectItem);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="增量-GC"><a href="#增量-GC" class="headerlink" title="增量 GC"></a>增量 GC</h2><p>GC 的增量标记与增量清理由引擎 <code>tick</code> 推进：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UWorld::Tick</span><span class="params">( ELevelTick TickType, <span class="type">float</span> DeltaSeconds )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GEngine-&gt;<span class="built_in">ConditionalCollectGarbage</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当至少一个 <code>World</code> 已经 <code>BegunPlay</code> 则进入回收逻辑，优先推进增量扫描（可达性分析），其次增量清理。</p><ul><li>优先推进增量扫描（Reachability Analysis）。</li><li>若扫描&#x2F;清理都不需推进，且时间达到阈值，则执行一轮 <code>PerformGarbageCollectionAndCleanupActors</code>。</li><li>否则继续 IncrementalPurge（增量清理）。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UEngine::ConditionalCollectGarbage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (GFrameCounter != LastGCFrame)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (bHasAWorldBegunPlay)</span><br><span class="line">        &#123;</span><br><span class="line">            TimeSinceLastPendingKillPurge += FApp::<span class="built_in">GetDeltaTime</span>();</span><br><span class="line"></span><br><span class="line">            <span class="type">const</span> <span class="type">float</span> TimeBetweenPurgingPendingKillObjects = <span class="built_in">GetTimeBetweenGarbageCollectionPasses</span>(bHasPlayersConnected);</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">if</span> (bShouldDelayGarbageCollect)</span><br><span class="line">            &#123;</span><br><span class="line">                bShouldDelayGarbageCollect = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">IsIncrementalReachabilityAnalysisPending</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">PerformIncrementalReachabilityAnalysis</span>(<span class="built_in">GetReachabilityAnalysisTimeLimit</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">IsIncrementalPurgePending</span>()</span><br><span class="line">                &amp;&amp; (TimeSinceLastPendingKillPurge &gt; TimeBetweenPurgingPendingKillObjects) &amp;&amp; TimeBetweenPurgingPendingKillObjects &gt; <span class="number">0.f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">PerformGarbageCollectionAndCleanupActors</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">float</span> IncGCTime = <span class="built_in">GetIncrementalGCTimePerFrame</span>();</span><br><span class="line">                <span class="built_in">IncrementalPurgeGarbage</span>(<span class="literal">true</span>, IncGCTime);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        LastGCFrame = GFrameCounter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">IsIncrementalReachabilityAnalysisPending</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">PerformIncrementalReachabilityAnalysis</span>(<span class="built_in">GetReachabilityAnalysisTimeLimit</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设是第一次进入垃圾回收，所以没有增量扫描也没有增量清理且时间还没到达两次 GC 的间隔，于是前 N 帧都会反复进入 <code>IncrementalPurgeGarbage</code>，但因为实在没有垃圾，直接返回，相当于空转。<br>直到时间阈值达到，正式进入到 <code>PerformGarbageCollectionAndCleanupActors</code> 中，此时先尝试做垃圾回收，并尝试清理挂在 <code>UWorld</code> 上的 <code>Actor</code> 指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UEngine::PerformGarbageCollectionAndCleanupActors</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TGuardValue&lt;<span class="type">bool</span>&gt; _FullGC(bGCPerformingFullPurge, bForcePurge);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">TryCollectGarbage</span>(GARBAGE_COLLECTION_KEEPFLAGS, bForcePurge))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ForEachObjectOfClass</span>(UWorld::<span class="built_in">StaticClass</span>(), [](UObject* World)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">CastChecked</span>&lt;UWorld&gt;(World)-&gt;<span class="built_in">CleanupActors</span>();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        TimeSinceLastPendingKillPurge = <span class="number">0.0f</span>;</span><br><span class="line">        bFullPurgeTriggered = <span class="literal">false</span>;</span><br><span class="line">        LastGCFrame = GFrameCounter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="增量扫描（Reachability-Pass）"><a href="#增量扫描（Reachability-Pass）" class="headerlink" title="增量扫描（Reachability Pass）"></a>增量扫描（Reachability Pass）</h3><h4 id="重置可达标记"><a href="#重置可达标记" class="headerlink" title="重置可达标记"></a>重置可达标记</h4><p>为了做可达性分析，首先我们要重置所有对象为不可达，在 UE 5.4 之前，确实是通过遍历所有GC对象进行标记的，这就很浪费，熟悉 Lua 的都知道三色标记法，只需要每次扫描之前交换一次当前不可达标记即可，UE 新版本中也确实是这么优化的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MarkObjectsAsUnreachable</span><span class="params">(<span class="type">const</span> EObjectFlags KeepFlags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FGCFlags::<span class="built_in">SwapReachableAndMaybeUnreachable</span>();</span><br><span class="line">    <span class="built_in">MarkClusteredObjectsAsReachable</span>(GatherOptions, InitialObjects);</span><br><span class="line">    <span class="built_in">MarkRootObjectsAsReachable</span>(GatherOptions, KeepFlags, InitialObjects);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此阶段在多线程下执行，先标记：</p><ul><li>所有 <strong>簇根及其成员</strong>；</li><li>所有 <strong>根对象</strong>；</li></ul><p>为 Reachable，减轻后面扫描的工作量。</p><h4 id="收集强引用对象"><a href="#收集强引用对象" class="headerlink" title="收集强引用对象"></a>收集强引用对象</h4><p>让对象避免被回收的典型方式：</p><ul><li><code>AddToRoot</code>：加入根集。</li><li><code>TStrongObjectPtr</code>：增加强引用计数（临时持有）。</li><li>实现 <code>FGCObject::AddReferencedObjects</code>：自定义向 GC 报告引用。</li><li><code>FGCObjectScopeGuard</code> 在指定代码区域内保持对象（基于 <code>FGCObject</code> 实现）。</li></ul><p>这也就意味着我们还需要支持第三种，收集该类对象通常由单独线程进行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BeginInitialReferenceCollection</span><span class="params">(EGCOptions Options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InitialReferences.<span class="built_in">Reset</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsParallel</span>(Options))</span><br><span class="line">    &#123;</span><br><span class="line">        InitialCollection = UE::Tasks::<span class="built_in">Launch</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;CollectInitialReferences&quot;</span>), </span><br><span class="line">            [&amp;] () &#123; FGCObject::GGCObjectReferencer-&gt;<span class="built_in">AddInitialReferences</span>(InitialReferences); &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="增量扫描的写屏障处理"><a href="#增量扫描的写屏障处理" class="headerlink" title="增量扫描的写屏障处理"></a>增量扫描的写屏障处理</h4><p>增量扫描间隙业务逻辑还在执行，需要将触发写屏障的新引用对象作为新的扫描起点加入。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PerformReachabilityAnalysisPass</span><span class="params">(<span class="type">const</span> EGCOptions Options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FContextPoolScope Pool;</span><br><span class="line">    FWorkerContext* Context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!Private::GReachableObjects.<span class="built_in">IsEmpty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        Private::GReachableObjects.<span class="built_in">PopAllAndEmpty</span>(InitialObjects);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (GReachabilityState.<span class="built_in">GetNumIterations</span>() == <span class="number">0</span> || (Stats.bFoundGarbageRef &amp;&amp; !GReachabilityState.<span class="built_in">IsSuspended</span>()))</span><br><span class="line">    &#123;</span><br><span class="line">        Context-&gt;InitialNativeReferences = <span class="built_in">GetInitialReferences</span>(Options);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!Private::GReachableClusters.<span class="built_in">IsEmpty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        TArray&lt;FUObjectItem*&gt; KeepClusterRefs;</span><br><span class="line">        Private::GReachableClusters.<span class="built_in">PopAllAndEmpty</span>(KeepClusterRefs);</span><br><span class="line">        <span class="keyword">for</span> (FUObjectItem* ObjectItem : KeepClusterRefs)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">MarkReferencedClustersAsReachable</span>&lt;EGCOptions::None&gt;(ObjectItem-&gt;<span class="built_in">GetClusterIndex</span>(), InitialObjects);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Context-&gt;<span class="built_in">SetInitialObjectsUnpadded</span>(InitialObjects);</span><br><span class="line">    <span class="built_in">PerformReachabilityAnalysisOnObjects</span>(Context, Options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GReachableObjects</code> 与 <code>GReachableClusters</code> 分别保存新对象和新簇根。<br>该函数每帧执行一次，直到扫描完成。</p><h4 id="引用扫描"><a href="#引用扫描" class="headerlink" title="引用扫描"></a>引用扫描</h4><p>为了高效地遍历对象引用，UE 会在初始化时（编辑器热重载时）Link 一下，为每个 <code>UClass</code> 构建 <code>ReferenceTokenStream</code> ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class-&gt;<span class="built_in">AssembleReferenceTokenStream</span>();</span><br></pre></td></tr></table></figure><p>其思路是：通过反射收集 <strong>相对对象首地址的偏移</strong> 与 <strong>成员类型</strong>，序列化为紧凑结构，GC 扫描时只需 <strong>顺序解释</strong> 即可，避免层层虚调用与递归：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> DispatcherType, <span class="keyword">typename</span> ObjectType&gt;</span></span><br><span class="line"><span class="function">FORCEINLINE_DEBUGGABLE <span class="type">void</span> <span class="title">VisitMembers</span><span class="params">(DispatcherType&amp; Dispatcher, FSchemaView Schema, ObjectType* Instance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> EOrigin Origin = Schema.<span class="built_in">GetOrigin</span>();</span><br><span class="line">    uint64* InstanceCursor = (uint64*)Instance;</span><br><span class="line">    uint32 DebugIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> FMemberWord* WordIt = Schema.<span class="built_in">GetWords</span>(); <span class="literal">true</span>; ++WordIt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="type">const</span> FMemberWordUnpacked <span class="title">Quad</span><span class="params">(WordIt-&gt;Members)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (FMemberUnpacked Member : Quad.Members)</span><br><span class="line">        &#123;</span><br><span class="line">            uint8* MemberPtr = (uint8*)(InstanceCursor + Member.WordOffset);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (Member.Type)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> EMemberType::Reference:    Dispatcher.<span class="built_in">HandleKillableReference</span>(*(UObject**)MemberPtr, <span class="built_in">FMemberId</span>(DebugIdx), Origin);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>：消除虚函数调用、递归层级与分支预测失败，显著提升 cache 局部性。</p><h4 id="标记可达对象"><a href="#标记可达对象" class="headerlink" title="标记可达对象"></a>标记可达对象</h4><p>扫描到的引用会进入到 <code>Dispatcher.HandleKillableReference</code> 或 <code>Dispatcher.HandleImmutableReference</code> 中进行标记。</p><ul><li><code>Killable</code> 表示可以清空（可变）的引用。</li><li><code>Immutable</code> 表示不可清空（不可变）的引用，比如 <code>Outer</code>、<code>Class</code>。</li></ul><p>这个概念设计出来是为了更安全的处理引用，举一个具体的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AMyActor</span> : <span class="keyword">public</span> AActor</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UPROPERTY</span>()</span><br><span class="line">    TObjectPtr&lt;UInventoryItem&gt; HeldItem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当 <code>HeldItem</code> 所指对象被 <code>MarkAsGarbage()</code> 后， GC 会自动清空该 Killable 引用，避免悬空指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HeldItem-&gt;<span class="built_in">MarkAsGarbage</span>();</span><br></pre></td></tr></table></figure><p>这样 <code>HeldItem</code> 就不用总是担心是否<strong>野指针</strong>，在早期 UE 版本中，只有一个 <code>MarkPendingKill</code> 的概念，这个东西就不会自动去清空所有引用它的地方的指针，已被废弃。</p><p><code>HandleXXXReference</code> 核心都是将其先存起来，批处理化，<code>Prefetch</code> 使用了 <code>_mm_prefetch</code> 函数来预先加载指定对象到 Cache 中。<br>Killable 引用存储槽位地址以便后续置 null，Immutable 引用只存对象指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FORCEINLINE_DEBUGGABLE <span class="type">void</span> <span class="title">HandleKillableReference</span><span class="params">(UObject*&amp; Object, FMemberId MemberId, EOrigin Origin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">QueueReference</span>(Context.<span class="built_in">GetReferencingObject</span>(), Object, MemberId, ProcessorType::<span class="built_in">MayKill</span>(Origin, <span class="literal">true</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FORCEINLINE <span class="type">void</span> <span class="title">HandleImmutableReference</span><span class="params">(UObject* Object, FMemberId MemberId, EOrigin Origin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ImmutableBatcher.<span class="built_in">PushReference</span>(FImmutableReference&#123;Object&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FORCEINLINE_DEBUGGABLE <span class="type">void</span> <span class="title">QueueReference</span><span class="params">(<span class="type">const</span> UObject* ReferencingObject,  UObject*&amp; Object, FMemberId MemberId, EKillable Killable)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Killable == EKillable::Yes)</span><br><span class="line">    &#123;</span><br><span class="line">        FPlatformMisc::<span class="built_in">Prefetch</span>(&amp;Object);</span><br><span class="line">        KillableBatcher.<span class="built_in">PushReference</span>(FMutableReference&#123;&amp;Object&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ImmutableBatcher.<span class="built_in">PushReference</span>(FImmutableReference&#123;Object&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PushReference</code> 会将其放入 <code>UnvalidatedReferences</code> 队列中，这表示是未经验证的队列，只有经过验证的引用，才会被标记为可达。<br>队列严格按照 Cache Line 大小对齐，对齐减少多核写竞争：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alignas</span> (PLATFORM_CACHE_LINE_SIZE)  TBatchQueue&lt;UnvalidatedReferenceType, UnvalidatedBatchSize&gt; UnvalidatedReferences;</span><br><span class="line"><span class="built_in">alignas</span> (PLATFORM_CACHE_LINE_SIZE)  TBatchQueue&lt;ValidatedReferenceType, ValidatedBatchSize, ValidatedPrefetchAhead&gt; ValidatedReferences;</span><br></pre></td></tr></table></figure><blockquote><p>CPU 从内存取数据是按固定大小的<strong>cache line</strong>（常见是 64B）成块搬进来。<br>只要一个线程写了落在某个 cache line 里的任意字节，这整条 line 在其他核上的副本就要被标记失效<br>尽量让它们不共享同一条 line，减少互相写入导致的失效。</p></blockquote><p>验证对象是否有效（非 Permanent 且已 Resolved），这个对象既不是永不 GC 的对象，同时该对象又是已经被加载到内存上的（UE允许对象先不加载，占个位，直到 <code>Resolved</code> 后才加载进来分配指针）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FORCEINLINE_DEBUGGABLE <span class="type">void</span> <span class="title">DrainUnvalidated</span><span class="params">(<span class="type">const</span> uint32 Num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">FPermanentObjectPoolExtents <span class="title">Permanent</span><span class="params">(PermanentPool)</span></span>;</span><br><span class="line">    FValidatedBitmask ValidsA, ValidsB;</span><br><span class="line">    <span class="keyword">for</span> (uint32 Idx = <span class="number">0</span>; Idx &lt; Num; ++Idx)</span><br><span class="line">        ValidsA.<span class="built_in">Set</span>(Idx, !Permanent.<span class="built_in">Contains</span>(<span class="built_in">GetObject</span>(UnvalidatedReferences[Idx])));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (uint32 Idx = <span class="number">0</span>; Idx &lt; Num; ++Idx)</span><br><span class="line">        ValidsB.<span class="built_in">Set</span>(Idx, <span class="built_in">IsObjectHandleResolved_ForGC</span>(<span class="built_in">reinterpret_cast</span>&lt;FObjectHandle&amp;&gt;(<span class="built_in">GetObject</span>(UnvalidatedReferences[Idx]))));</span><br><span class="line"></span><br><span class="line">    FValidatedBitmask Validations = FValidatedBitmask::<span class="built_in">And</span>(ValidsA, ValidsB);</span><br><span class="line">    <span class="built_in">QueueValidReferences</span>(Validations);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>bitmask</code> 是因为CPU 对分支预测（<code>if</code> 条件）非常敏感。如果CPU 分支预测经常失败，会导致 pipeline flush（流水线清空重排），严重拖慢性能。<br>经过验证的引用会放入到 <code>ValidatedReferences</code> 队列中。</p><p>现在处理 经过验证的引用的队列，依然是预取一些需要的字段，最后交由 <code>HandleBatchedReference</code> 去标记可达。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FORCEINLINE_DEBUGGABLE <span class="type">void</span> <span class="title">DrainValidated</span><span class="params">(<span class="type">const</span> uint32 Num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> uint32 InternalIndexPrefetchOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> uint32 PrefetchAhead = ValidatedPrefetchAhead;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> ::<span class="type">size_t</span> OffsetOfFlags = FGCFlags::<span class="built_in">OffsetOfFlags_ForGC</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (uint32 Idx = <span class="number">0</span>; Idx &lt; Num; ++Idx)</span><br><span class="line">    &#123;</span><br><span class="line">        FPlatformMisc::<span class="built_in">Prefetch</span>(ValidatedReferences[Idx].Object, InternalIndexPrefetchOffset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (uint32 Idx = <span class="number">0</span>; Idx &lt; Num; ++Idx)</span><br><span class="line">    &#123;</span><br><span class="line">        ObjectIndices[Idx] = GUObjectArray.<span class="built_in">ObjectToIndex</span>(ValidatedReferences[Idx].Object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FChunkedFixedUObjectArray&amp; ObjectArray = GUObjectArray.<span class="built_in">GetObjectItemArrayUnsafe</span>();</span><br><span class="line">    FReferenceMetadata Metadatas[ValidatedBatchSize + PrefetchAhead];</span><br><span class="line">    <span class="keyword">for</span> (uint32 Idx = <span class="number">0</span>; Idx &lt; Num; ++Idx)</span><br><span class="line">    &#123;</span><br><span class="line">        Metadatas[Idx].ObjectItem = ObjectArray.<span class="built_in">GetObjectPtr</span>(ObjectIndices[Idx]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (uint32 Idx = <span class="number">0</span>; Idx &lt; Num; ++Idx)</span><br><span class="line">    &#123;</span><br><span class="line">        FPlatformMisc::<span class="built_in">Prefetch</span>(Metadatas[Idx].ObjectItem, OffsetOfFlags);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (uint32 Idx = <span class="number">0</span>; Idx &lt; Num; ++Idx)</span><br><span class="line">    &#123;</span><br><span class="line">        Metadatas[Idx].Flags = Metadatas[Idx].ObjectItem-&gt;<span class="built_in">GetFlags</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (uint32 Idx = <span class="number">0</span>; Idx &lt; Num; ++Idx)</span><br><span class="line">    &#123;</span><br><span class="line">        ProcessorType::<span class="built_in">HandleBatchedReference</span>(Context, ValidatedReferences[Idx], Metadatas[Idx]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ValidatedReferences.Num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>UObjectBase::InternalIndex</code> 实际在 偏移12 上，但这里 <code>InternalIndexPrefetchOffset</code> 却等于 0，这是因为 <code>UObject</code> 按 16B 对齐，而 Cache Line 大小为 64B，所以不需要填入具体的 Offset 也能保证一定会将这个字段包括进来预热，写 0 还能让该机器码更紧凑。</p><p>当该对象已经被 <code>MarkAsGarbage()</code> 后，它身上就会多个 <code>EInternalObjectFlags::Garbage</code> 标记，此时就可以找到引用它的地方，给它置空，这就和我们前面的例子对应上了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> EInternalObjectFlags KillFlag = EInternalObjectFlags::Garbage;</span><br><span class="line"><span class="function">FORCEINLINE_DEBUGGABLE <span class="type">void</span> <span class="title">KillReference</span><span class="params">(UObject*&amp; Object)</span> </span>&#123; Object = <span class="literal">nullptr</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FORCEINLINE <span class="type">static</span> <span class="type">void</span> <span class="title">HandleBatchedReference</span><span class="params">(FWorkerContext&amp; Context, FResolvedMutableReference Reference, FReferenceMetadata Metadata)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Metadata.<span class="built_in">Has</span>(KillFlag))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">KillReference</span>(*Reference.Mutable);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">HandleValidReference</span>(Context, Reference, Metadata);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>否则则进行标记，这时候要考虑多线程的情况，被其他线程提前标记过后 <code>MarkAsReachableInterlocked_ForGC</code> 的情况下会返回 <code>false</code> ，此时只需要考虑该对象是否为簇成员，若是则考虑其簇根是否被递归扫描过，确保将簇与簇之间的引用也标记一遍，也就是说 先遇到簇成员、没遇到根，也能把整簇激活。<br>其实大部分簇在垃圾回收刚启动时候就会调用 <code>MarkClusteredObjectsAsReachable</code> 将已有的簇标记为可达，并传播下去，所以这里大部分情况下都啥也不做，这就是为什么 簇能加速垃圾回收。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FORCEINLINE <span class="type">static</span> <span class="type">bool</span> <span class="title">HandleValidReference</span><span class="params">(FWorkerContext&amp; Context, FImmutableReference Reference, FReferenceMetadata Metadata)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (FGCFlags::<span class="built_in">MarkAsReachableInterlocked_ForGC</span>(Metadata.ObjectItem))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Metadata.<span class="built_in">Has</span>(EInternalObjectFlags::ClusterRoot))</span><br><span class="line">        &#123;</span><br><span class="line">            Context.ObjectsToSerialize.<span class="built_in">Add</span>&lt;Options&gt;(Reference.Object);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">MarkReferencedClustersAsReachableThunk</span>&lt;Options&gt;(Metadata.ObjectItem-&gt;<span class="built_in">GetClusterIndex</span>(), Context.ObjectsToSerialize);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((Metadata.ObjectItem-&gt;<span class="built_in">GetOwnerIndex</span>() &gt; <span class="number">0</span>) &amp; !Metadata.<span class="built_in">Has</span>(EInternalObjectFlags::ReachableInCluster))</span><br><span class="line">        &#123;</span><br><span class="line">            FUObjectItem* RootObjectItem = GUObjectArray.<span class="built_in">IndexToObjectUnsafeForGC</span>(Metadata.ObjectItem-&gt;<span class="built_in">GetOwnerIndex</span>());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (FGCFlags::<span class="built_in">ThisThreadAtomicallySetFlag_ForGC</span>(Metadata.ObjectItem, EInternalObjectFlags::ReachableInCluster))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (FGCFlags::<span class="built_in">MarkAsReachableInterlocked_ForGC</span>(RootObjectItem))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">MarkReferencedClustersAsReachableThunk</span>&lt;Options&gt;(RootObjectItem-&gt;<span class="built_in">GetClusterIndex</span>(), Context.ObjectsToSerialize);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此我们讲解完了整个垃圾回收的扫描过程，已经将可达的对象全都标记出来了。</p><h4 id="收集不可达对象"><a href="#收集不可达对象" class="headerlink" title="收集不可达对象"></a>收集不可达对象</h4><p>因为已经找出了所有可达对象，因此所有可能不可达 <code>MaybeUnreachable</code> 的对象都是可以回收的。<br>多线程迭代所有对象，找出所有可能不可达对象，将其全部标记为不可达。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GatherUnreachableObjects</span><span class="params">(UE::GC::EGatherOptions Options, <span class="type">double</span> TimeLimit <span class="comment">/*= 0.0*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ParallelFor</span>( <span class="built_in">TEXT</span>(<span class="string">&quot;GC.GatherUnreachable&quot;</span>), GGatherUnreachableObjectsState.<span class="built_in">NumWorkerThreads</span>(), <span class="number">1</span>, [&amp;ThreadIterators, &amp;GatherStartTime, &amp;TimeLimit, &amp;TimeLimitExceededFlag](int32 ThreadIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">constexpr</span> int32 TimeLimitPollInterval = <span class="number">10</span>;</span><br><span class="line">        FTimeSlicer <span class="built_in">Timer</span>(TimeLimitPollInterval, ThreadIndex * TimeLimitPollInterval, GatherStartTime, TimeLimit, TimeLimitExceededFlag);</span><br><span class="line">        FGatherUnreachableObjectsState::FIterator&amp; Iterator = ThreadIterators[ThreadIndex];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (Iterator.Index &lt;= Iterator.LastIndex)</span><br><span class="line">        &#123;</span><br><span class="line">            FUObjectItem* ObjectItem = &amp;GUObjectArray.<span class="built_in">GetObjectItemArrayUnsafe</span>()[Iterator.Index++];</span><br><span class="line">            <span class="keyword">if</span> (FGCFlags::<span class="built_in">IsMaybeUnreachable_ForGC</span>(ObjectItem))</span><br><span class="line">            &#123;</span><br><span class="line">                FGCFlags::<span class="built_in">SetUnreachable</span>(ObjectItem);</span><br><span class="line">                Iterator.Payload.<span class="built_in">Add</span>(&#123; ObjectItem &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, (GGatherUnreachableObjectsState.<span class="built_in">NumWorkerThreads</span>() == <span class="number">1</span>) ? EParallelForFlags::ForceSingleThread : EParallelForFlags::None);</span><br><span class="line">    GGatherUnreachableObjectsState.<span class="built_in">Finish</span>(GUnreachableObjects);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="/images/UE5%E5%A2%9E%E9%87%8F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90.png"></p><h3 id="清理（Sweep-Purge）"><a href="#清理（Sweep-Purge）" class="headerlink" title="清理（Sweep &#x2F; Purge）"></a>清理（Sweep &#x2F; Purge）</h3><p>根据对象状态依次执行</p><ul><li><code>BeginDestroy()</code></li><li><code>FinishDestroy()</code></li></ul><p>最后将其从 <code>GUObjectArray</code> 全局表中删除，后释放内存（只要该对象<strong>不在永久对象池</strong>的地址范围内，就释放）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">UnhashUnreachableObjects</span><span class="params">(<span class="type">bool</span> bUseTimeLimit, <span class="type">double</span> TimeLimit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (GUnrechableObjectIndex &lt; GUnreachableObjects.<span class="built_in">Num</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        FUObjectItem* ObjectItem = GUnreachableObjects[GUnrechableObjectIndex++].ObjectItem;</span><br><span class="line">        UObject* Object = <span class="built_in">static_cast</span>&lt;UObject*&gt;(ObjectItem-&gt;<span class="built_in">GetObject</span>());</span><br><span class="line">        Object-&gt;<span class="built_in">ConditionalBeginDestroy</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IncrementalDestroyGarbage</span><span class="params">(<span class="type">bool</span> bUseTimeLimit, <span class="type">double</span> TimeLimit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Object-&gt;<span class="built_in">IsReadyForFinishDestroy</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        Object-&gt;<span class="built_in">ConditionalFinishDestroy</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FORCENOINLINE <span class="type">bool</span> <span class="title">DestroyObjects</span><span class="params">(<span class="type">bool</span> bUseTimeLimit, <span class="type">double</span> TimeLimit, <span class="type">double</span> StartTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GUObjectArray.<span class="built_in">FreeUObjectIndex</span>(Object);</span><br><span class="line">    </span><br><span class="line">    Object-&gt;~<span class="built_in">UObject</span>();  </span><br><span class="line">    GUObjectAllocator.<span class="built_in">FreeUObject</span>(Object);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FUObjectAllocator::FreeUObject</span><span class="params">(UObjectBase *Object)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">FPermanentObjectPoolExtents</span>().<span class="built_in">Contains</span>(Object) == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        FMemory::<span class="built_in">Free</span>(Object);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">check</span>(GExitPurge);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调参"><a href="#调参" class="headerlink" title="调参"></a>调参</h2><p>在打包（Cooked）环境下，可以预先设置以下三个配置值，预分配对象槽位，进行性能优化。</p><ul><li><code>gc.MaxObjectsInGame</code> 预先分配好 <code>Chunk</code>。</li><li><code>gc.MaxObjectsNotConsideredByGC</code> 先预跑一次，然后去日志里找 <code>Log: XXX objects as part of root set at end of initial load.</code>，再将该值设置进去，这表示不需要参与垃圾回收的对象个数。</li><li><code>gc.PreAllocateUObjectArray</code> 提前为 UObjectArray 预留出一大块连续的槽位（FUObjectItem）。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UObjectBaseInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    int32 MaxObjectsNotConsideredByGC = <span class="number">0</span>;</span><br><span class="line">    int32 MaxUObjects = <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// Default to ~2M UObjects</span></span><br><span class="line">    <span class="type">bool</span> bPreAllocateUObjectArray = <span class="literal">false</span>;	</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (FPlatformProperties::<span class="built_in">RequiresCookedData</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">IsRunningCookOnTheFly</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            GCreateGCClusters = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            GConfig-&gt;<span class="built_in">GetInt</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;/Script/Engine.GarbageCollectionSettings&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;gc.MaxObjectsNotConsideredByGC&quot;</span>), MaxObjectsNotConsideredByGC, GEngineIni);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        GConfig-&gt;<span class="built_in">GetInt</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;/Script/Engine.GarbageCollectionSettings&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;gc.MaxObjectsInGame&quot;</span>), MaxUObjects, GEngineIni);</span><br><span class="line"></span><br><span class="line">        GConfig-&gt;<span class="built_in">GetBool</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;/Script/Engine.GarbageCollectionSettings&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;gc.PreAllocateUObjectArray&quot;</span>), bPreAllocateUObjectArray, GEngineIni);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (MaxObjectsNotConsideredByGC == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        GUObjectAllocator.<span class="built_in">DisablePersistentAllocator</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    GUObjectArray.<span class="built_in">AllocateObjectPool</span>(MaxUObjects, MaxObjectsNotConsideredByGC, bPreAllocateUObjectArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可通过以下三个配置，调节垃圾回收触发速率：</p><ul><li><code>gc.TimeBetweenPurgingPendingKillObjects</code> 表示两次清理 <code>PendingKill</code> 对象之间等待的时间，调小这个值可以更快地触发 GC，默认 60s。</li><li><code>gc.TimeBetweenPurgingPendingKillObjectsOnIdleServerMultiplier</code> DS专用，没有玩家时两次 GC 的时间的倍率，默认10倍。</li><li><code>gc.LowMemory.MemoryThresholdMB</code> 表示内存紧张时，两次清理 <code>PendingKill</code> 对象之间等待的时间，就是内存紧张，可以更快触发 GC。默认 30s。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">UEngine::GetTimeBetweenGarbageCollectionPasses</span><span class="params">(<span class="type">bool</span> bHasPlayersConnected)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> TimeBetweenGC = GTimeBetweenPurgingPendingKillObjects; <span class="comment">// 60s</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsRunningDedicatedServer</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!bHasPlayersConnected)</span><br><span class="line">        &#123;</span><br><span class="line">            TimeBetweenGC *= GTimeBetweenPurgingPendingKillObjectsOnIdleServerMultiplier; <span class="comment">// 10x</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (GLowMemoryMemoryThresholdMB &gt; <span class="number">0.0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TimeBetweenGC = <span class="built_in">GetLowMemoryGCTimer</span>(TimeBetweenGC); <span class="comment">// 30s</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TimeBetweenGC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-tags"><a href="/tags/UE5/" rel="tag"># UE5</a> <a href="/tags/GC/" rel="tag"># GC</a></div><div class="post-nav"><div class="post-nav-item"><a href="/UE5%20UnLua%20%E8%84%9A%E6%9C%AC%E6%96%B9%E6%A1%88%E5%8E%9F%E7%90%86/" rel="prev" title="UE5 UnLua 脚本方案原理"><i class="fa fa-angle-left"></i> UE5 UnLua 脚本方案原理</a></div><div class="post-nav-item"></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Yuerer</span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://unpkg.com/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://unpkg.com/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/comments.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/utils.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/motion.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/sidebar.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/next-boot.min.js"></script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://yuerer-comment-xufei-0bea01e6f05-1307930306.ap-shanghai.app.tcloudbase.com","cssUrl":"https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.css","commentCount":true,"pageview":true,"libUrl":"https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.js","locale":{"placeholder":"有何高见？"},"emoji":["https://unpkg.com/@waline/emojis@1.0.1/qq"],"meta":["nick","mail"],"requiredMeta":[["nick","mail"]],"wordLimit":0,"login":"disable","pageSize":10,"el":"#waline","comment":true,"path":"/UE5%20%E5%A2%9E%E9%87%8F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/"}</script><link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.css"><script>document.addEventListener("page:loaded",()=>{NexT.utils.loadComments(CONFIG.waline.el).then(()=>NexT.utils.getScript(CONFIG.waline.libUrl,{condition:window.Waline})).then(()=>Waline.init(Object.assign({},CONFIG.waline,{el:document.querySelector(CONFIG.waline.el)})))})</script></body></html>