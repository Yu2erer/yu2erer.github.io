<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.jpeg"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.ico"><link rel="mask-icon" href="/images/avatar.jpeg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous"><link rel="stylesheet" href="https://unpkg.com/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"yuerer.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"hide","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":true,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/config.min.js"></script><meta name="description" content="钰儿的Blog"><meta property="og:type" content="website"><meta property="og:title" content="Yuerer&#39;s Blog"><meta property="og:url" content="https://yuerer.com/index.html"><meta property="og:site_name" content="Yuerer&#39;s Blog"><meta property="og:description" content="钰儿的Blog"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="Yuerer"><meta property="article:tag" content="yuerer,yu2erer,yuerer&#39;s blog,yuerer blog,钰儿,钰儿儿,blog"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://yuerer.com/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Yuerer's Blog</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-129491388-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-129491388-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/third-party/analytics/google-analytics.min.js"></script><link rel="dns-prefetch" href="https://yuerer-comment-xufei-0bea01e6f05-1307930306.ap-shanghai.app.tcloudbase.com"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">Yuerer's Blog</h1><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">钰儿的Blog</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-overview-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Yuerer" src="/images/avatar.jpeg"><p class="site-author-name" itemprop="name">Yuerer</p><div class="site-description" itemprop="description">钰儿的Blog</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">65</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">16</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">90</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/Yu2erer" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Yu2erer" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:yu2erer#gmail.com" title="E-Mail → mailto:yu2erer#gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div></div></div></div></aside></div><div class="main-inner index posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://yuerer.com/UE5%20%E5%A2%9E%E9%87%8F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpeg"><meta itemprop="name" content="Yuerer"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Yuerer's Blog"><meta itemprop="description" content="钰儿的Blog"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Yuerer's Blog"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/UE5%20%E5%A2%9E%E9%87%8F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">UE5 增量垃圾回收深度解析</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-10-30 21:40:20" itemprop="dateCreated datePublished" datetime="2025-10-30T21:40:20+08:00">2025-10-30</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UE/" itemprop="url" rel="index"><span itemprop="name">UE</span></a> </span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Waline：</span> <a title="waline" href="/UE5%20%E5%A2%9E%E9%87%8F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/UE5%20%E5%A2%9E%E9%87%8F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/" itemprop="commentCount"></span> </a></span><span class="post-meta-item" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="waline-pageview-count" data-path="/UE5%20%E5%A2%9E%E9%87%8F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/"></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>UE5 的垃圾回收（GC）采用 <strong>标记-清除（Mark &amp; Sweep）</strong> 策略，通过遍历对象引用关系确定可达对象并清理其余内存。本文聚焦 <strong>UE5.6</strong> 的 <strong>增量垃圾回收</strong>，尤其是 <strong>增量标记（Incremental Marking）</strong> 的最新变化，以及 <strong>工程上实现该算法的优化</strong>。阅读前如已熟悉通用 GC 原理（例如 Lua 的三色标记），会更易理解 UE 的实现细节与优化策略。</p><h2 id="从-STW-到-增量扫描"><a href="#从-STW-到-增量扫描" class="headerlink" title="从 STW 到 增量扫描"></a>从 STW 到 增量扫描</h2><p>在 UE5.4 之前，GC 的可达性分析通常以 <strong>一次性完成（Stop-the-World）</strong> 的方式进行：扫描阶段暂停游戏逻辑，实现简单，但缺点是 停顿时间可能较长，带来 Gameplay 卡顿。<br>从 UE5.4 起，引擎引入 增量扫描：将可达性分析拆分到多帧执行，平滑每帧的 GC 开销。这引出了一个核心问题：</p><blockquote><p>扫描间隙产生的新对象&#x2F;新引用如何处理？</p></blockquote><h2 id="对象分配"><a href="#对象分配" class="headerlink" title="对象分配"></a>对象分配</h2><p>对象通过 <code>NewObject</code> 分配时，会进入 <code>UObjectBase</code> 构造并注册到全局对象表 <code>GUObjectArray</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">UObjectBase::<span class="built_in">UObjectBase</span>(UClass* InClass,</span><br><span class="line">    EObjectFlags InFlags,</span><br><span class="line">    EInternalObjectFlags InInternalFlags,</span><br><span class="line">    UObject *InOuter,</span><br><span class="line">    FName InName,</span><br><span class="line">    int32 InInternalIndex,</span><br><span class="line">    int32 InSerialNumber,</span><br><span class="line">    FRemoteObjectId InRemoteId)</span><br><span class="line">:   <span class="built_in">ObjectFlags</span>(InFlags)</span><br><span class="line">,   <span class="built_in">InternalIndex</span>(INDEX_NONE)</span><br><span class="line">,   <span class="built_in">ClassPrivate</span>(InClass)</span><br><span class="line">,   <span class="built_in">OuterPrivate</span>(InOuter)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">AddObject</span>(InName, InInternalFlags, InInternalIndex, InSerialNumber, InRemoteId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AddObject</code> 会把对象注册到 <code>GUObjectArray</code> 并设置内部标志位：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UObjectBase::AddObject</span><span class="params">(FName InName, EInternalObjectFlags InSetInternalFlags, int32 InInternalIndex, int32 InSerialNumber, FRemoteObjectId InRemoteId)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NamePrivate = InName;</span><br><span class="line">    EInternalObjectFlags InternalFlagsToSet = InSetInternalFlags;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">IsInGameThread</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        InternalFlagsToSet |= EInternalObjectFlags::Async;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ObjectFlags &amp; RF_MarkAsRootSet)</span><br><span class="line">    &#123;</span><br><span class="line">        InternalFlagsToSet |= EInternalObjectFlags::RootSet;</span><br><span class="line">        ObjectFlags &amp;= ~RF_MarkAsRootSet;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ObjectFlags &amp; RF_MarkAsNative)</span><br><span class="line">    &#123;</span><br><span class="line">        InternalFlagsToSet |= EInternalObjectFlags::Native;</span><br><span class="line">        ObjectFlags &amp;= ~RF_MarkAsNative;</span><br><span class="line">    &#125;</span><br><span class="line">    GUObjectArray.<span class="built_in">AllocateUObjectIndex</span>(<span class="keyword">this</span>, InternalFlagsToSet, InInternalIndex, InSerialNumber, InRemoteId);</span><br><span class="line">    <span class="built_in">HashObject</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>AllocateUObjectIndex</code> 中，可见关键点：非 “DisregardForGC” 窗口下，新对象会被标上 “Reachable” 位，即默认可达：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FUObjectArray::AllocateUObjectIndex</span><span class="params">(UObjectBase* Object, EInternalObjectFlags InitialFlags, int32 AlreadyAllocatedIndex, int32 SerialNumber, FRemoteObjectId RemoteId)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">LockInternalArray</span>();</span><br><span class="line">    FUObjectItem* ObjectItem = <span class="built_in">IndexToObject</span>(Index);</span><br><span class="line">    ObjectItem-&gt;Flags = (int32)EInternalObjectFlags::PendingConstruction;</span><br><span class="line">    <span class="keyword">if</span> (!(<span class="built_in">IsOpenForDisregardForGC</span>() &amp; GUObjectArray.<span class="built_in">DisregardForGCEnabled</span>()))</span><br><span class="line">    &#123;</span><br><span class="line">        ObjectItem-&gt;Flags |= (int32)UE::GC::Private::FGCFlags::<span class="built_in">GetReachableFlagValue_ForGC</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ObjectItem-&gt;<span class="built_in">SetObject</span>(Object);  </span><br><span class="line">    ObjectItem-&gt;RefCount = <span class="number">0</span>;  </span><br><span class="line">    ObjectItem-&gt;ClusterRootIndex = <span class="number">0</span>;  </span><br><span class="line">    ObjectItem-&gt;SerialNumber = SerialNumber;</span><br><span class="line">    Object-&gt;InternalIndex = Index;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (InitialFlags != EInternalObjectFlags::None)  </span><br><span class="line">    &#123;  </span><br><span class="line">        ObjectItem-&gt;<span class="built_in">ThisThreadAtomicallySetFlag</span>(InitialFlags);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">UnlockInternalArray</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="post-button"><a class="btn" href="/UE5%20%E5%A2%9E%E9%87%8F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://yuerer.com/UE5%20UnLua%20%E8%84%9A%E6%9C%AC%E6%96%B9%E6%A1%88%E5%8E%9F%E7%90%86/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpeg"><meta itemprop="name" content="Yuerer"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Yuerer's Blog"><meta itemprop="description" content="钰儿的Blog"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Yuerer's Blog"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/UE5%20UnLua%20%E8%84%9A%E6%9C%AC%E6%96%B9%E6%A1%88%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">UE5 UnLua 脚本方案原理</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-10-24 23:21:20" itemprop="dateCreated datePublished" datetime="2025-10-24T23:21:20+08:00">2025-10-24</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UE/" itemprop="url" rel="index"><span itemprop="name">UE</span></a> </span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Waline：</span> <a title="waline" href="/UE5%20UnLua%20%E8%84%9A%E6%9C%AC%E6%96%B9%E6%A1%88%E5%8E%9F%E7%90%86/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/UE5%20UnLua%20%E8%84%9A%E6%9C%AC%E6%96%B9%E6%A1%88%E5%8E%9F%E7%90%86/" itemprop="commentCount"></span> </a></span><span class="post-meta-item" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="waline-pageview-count" data-path="/UE5%20UnLua%20%E8%84%9A%E6%9C%AC%E6%96%B9%E6%A1%88%E5%8E%9F%E7%90%86/"></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>本文剖析 UnLua 是如何将 Lua 接入到 UE5中。尽可能少贴代码，将部分 Lua C API 的操作转为 Lua 伪代码，同时每个小节只关注主线内容，方便阅读和理解。</p><h2 id="对象绑定"><a href="#对象绑定" class="headerlink" title="对象绑定"></a>对象绑定</h2><p>本小节只关注当 UE5 创建一个对象时，是如何将其和 Lua 脚本给绑定起来的。</p><h3 id="1-创建虚拟机"><a href="#1-创建虚拟机" class="headerlink" title="1. 创建虚拟机"></a>1. 创建虚拟机</h3><p>我们需要创建一个 Lua 虚拟机来执行游戏逻辑，但有时又希望每个 <code>GameInstance</code> 各自拥有自己的虚拟机，这样会更方便调试和管理，这就意味着需要确定每个 <code>Object</code> 会被分配到哪个虚拟机（以后为和代码保持一致，会简称为 <code>Env</code>），抽象出 <code>ULuaEnvLocator</code> 用于定位 <code>Object</code> 所属 <code>Env</code>，并创建 <code>Env</code>，<code>Env</code> 的一些简单操作会封装到 <code>FLuaEnv</code> 中。<br>大部分情况下，只需认为整个客户端只会开启一个 Lua 虚拟机就可以了，基于这个前提，甚至可以去掉这个类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UNLUA_API</span> ULuaEnvLocator : <span class="keyword">public</span> UObject</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> UnLua::FLuaEnv* <span class="title">Locate</span><span class="params">(<span class="type">const</span> UObject* Object)</span></span>;</span><br><span class="line">    TSharedPtr&lt;UnLua::FLuaEnv, ESPMode::ThreadSafe&gt; Env;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>定位当前 Object 属于哪个 Env</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EnvLocator = <span class="built_in">NewObject</span>&lt;ULuaEnvLocator&gt;(<span class="built_in">GetTransientPackage</span>(), EnvLocatorClass);</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> Env = EnvLocator-&gt;<span class="built_in">Locate</span>(Class);</span><br></pre></td></tr></table></figure><p>从以上代码能看出 <code>FLuaEnv</code> 就是虚拟机本身的封装类。</p><h3 id="2-绑定-UE-反射对象到-Lua"><a href="#2-绑定-UE-反射对象到-Lua" class="headerlink" title="2. 绑定 UE 反射对象到 Lua"></a>2. 绑定 UE 反射对象到 Lua</h3><p>通过继承以下两个类，来进行监听当前创建、销毁哪些 <code>UObject</code> ，从而实现绑定，内部实现为了解耦，会在多处监听。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FUnLuaModule</span> : <span class="keyword">public</span> IUnLuaModule,  </span><br><span class="line">                     <span class="keyword">public</span> FUObjectArray::FUObjectCreateListener,  </span><br><span class="line">                     <span class="keyword">public</span> FUObjectArray::FUObjectDeleteListener</span><br><span class="line"></span><br><span class="line">GUObjectArray.<span class="built_in">AddUObjectCreateListener</span>(<span class="keyword">this</span>);</span><br><span class="line">GUObjectArray.<span class="built_in">AddUObjectDeleteListener</span>(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>知道了哪些对象创建出来后，还需要知道该对象跟哪份 Lua 文件进行绑定，<code>Unlua</code> 有好几种方案，第一种是最好理解的，要求实现 <code>IUnLuaInterface</code> 接口：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UNLUA_API</span> IUnLuaInterface</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UFUNCTION</span>(BlueprintNativeEvent)</span><br><span class="line">    <span class="function">FString <span class="title">GetModuleName</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="post-button"><a class="btn" href="/UE5%20UnLua%20%E8%84%9A%E6%9C%AC%E6%96%B9%E6%A1%88%E5%8E%9F%E7%90%86/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://yuerer.com/UE5%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpeg"><meta itemprop="name" content="Yuerer"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Yuerer's Blog"><meta itemprop="description" content="钰儿的Blog"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Yuerer's Blog"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/UE5%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">UE5 智能指针详解</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-02-16 12:50:20" itemprop="dateCreated datePublished" datetime="2025-02-16T12:50:20+08:00">2025-02-16</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UE/" itemprop="url" rel="index"><span itemprop="name">UE</span></a> </span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Waline：</span> <a title="waline" href="/UE5%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/UE5%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3/" itemprop="commentCount"></span> </a></span><span class="post-meta-item" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="waline-pageview-count" data-path="/UE5%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3/"></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>本文以 UE5.4 为基准，讲解智能指针的实现机制。阅读本文前需要对 C++11 的智能指针有基本了解。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li><strong>虚幻智能指针库</strong> 为C++11智能指针的自定义实现，旨在减轻内存分配和追踪的负担。该实现包括行业标准 <strong>共享指针</strong>、<strong>弱指针</strong> 和 <strong>唯一指针</strong>。其还可添加 <strong>共享引用</strong>，此类引用的行为与不可为空的共享指针相同。</li></ul><p>根据官方文档，与 C++ 标准库相比，虚幻引擎新增了共享引用的概念。智能指针的实现位于 <code>Core</code> 模块下。</p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>UE 的智能指针分为两种模式，表示是否为线程安全。这里所说的线程安全仅指其内部的引用计数器是否线程安全。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">ESPMode</span> : uint8</span><br><span class="line">&#123;</span><br><span class="line">    NotThreadSafe = <span class="number">0</span>,</span><br><span class="line">    ThreadSafe = <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>默认为 <code>ThreadSafe</code> 和 C++标准库保持一致。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">ObjectType</span>, ESPMode Mode = ESPMode::ThreadSafe &gt; <span class="keyword">class</span> TSharedRef;</span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">ObjectType</span>, ESPMode Mode = ESPMode::ThreadSafe &gt; <span class="keyword">class</span> TSharedPtr;</span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">ObjectType</span>, ESPMode Mode = ESPMode::ThreadSafe &gt; <span class="keyword">class</span> TWeakPtr;</span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">ObjectType</span>, ESPMode Mode = ESPMode::ThreadSafe &gt; <span class="keyword">class</span> TSharedFromThis;</span><br></pre></td></tr></table></figure><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>引用控制器（以下简称控制块）中记录了共享引用次数和弱引用次数。</p><p>若为线程安全，内部计数器采用原子操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;ESPMode Mode&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TReferenceControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> RefCountType = std::<span class="type">conditional_t</span>&lt;Mode == ESPMode::ThreadSafe, std::atomic&lt;int32&gt;, int32&gt;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RefCountType SharedReferenceCount&#123;<span class="number">1</span>&#125;;</span><br><span class="line">    RefCountType WeakReferenceCount&#123;<span class="number">1</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="post-button"><a class="btn" href="/UE5%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://yuerer.com/UE5%20%E8%93%9D%E5%9B%BE%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B%E5%89%96%E6%9E%90/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpeg"><meta itemprop="name" content="Yuerer"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Yuerer's Blog"><meta itemprop="description" content="钰儿的Blog"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Yuerer's Blog"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/UE5%20%E8%93%9D%E5%9B%BE%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B%E5%89%96%E6%9E%90/" class="post-title-link" itemprop="url">UE5 蓝图编译流程剖析</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-02-02 22:46:20" itemprop="dateCreated datePublished" datetime="2025-02-02T22:46:20+08:00">2025-02-02</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UE/" itemprop="url" rel="index"><span itemprop="name">UE</span></a> </span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Waline：</span> <a title="waline" href="/UE5%20%E8%93%9D%E5%9B%BE%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B%E5%89%96%E6%9E%90/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/UE5%20%E8%93%9D%E5%9B%BE%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B%E5%89%96%E6%9E%90/" itemprop="commentCount"></span> </a></span><span class="post-meta-item" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="waline-pageview-count" data-path="/UE5%20%E8%93%9D%E5%9B%BE%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B%E5%89%96%E6%9E%90/"></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>本文以 UE5.4 为基准，剖析蓝图编译的全流程。在阅读本文之前，需要比较熟悉蓝图，比较熟悉反射，同时最好先阅读 <a target="_blank" rel="noopener" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/compiler-overview-for-blueprints-visual-scripting-in-unreal-engine">蓝图编译器概述</a>。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>UE5 的蓝图编译总共分为16个阶段，可简单分类为收集、过滤、验证、兼容、构建骨架、构建语句、生成字节码，重新链接这几个阶段。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">STAGE I: GATHER</span><br><span class="line">STAGE II: FILTER</span><br><span class="line">STAGE III: SORT</span><br><span class="line">STAGE IV: SET TEMPORARY BLUEPRINT FLAGS</span><br><span class="line">STAGE V: VALIDATE</span><br><span class="line">STAGE VI: <span class="built_in">PURGE</span> (LOAD ONLY)</span><br><span class="line">STAGE VII: DISCARD SKELETON CDO</span><br><span class="line">STAGE VIII: RECOMPILE SKELETON</span><br><span class="line">STAGE IX: RECONSTRUCT NODES, <span class="function">REPLACE DEPRECATED <span class="title">NODES</span> <span class="params">(LOAD ONLY)</span></span></span><br><span class="line"><span class="function">STAGE X: CREATE REINSTANCER (DISCARD <span class="string">&#x27;OLD&#x27;</span> CLASS)</span></span><br><span class="line"><span class="function">STAGE XI: CREATE UPDATED CLASS HIERARCHY</span></span><br><span class="line"><span class="function">STAGE XII: COMPILE CLASS LAYOUT</span></span><br><span class="line"><span class="function">STAGE XIII: COMPILE CLASS FUNCTIONS</span></span><br><span class="line"><span class="function">STAGE XIV: REINSTANCE</span></span><br><span class="line"><span class="function">STAGE XV: POST CDO COMPILED </span></span><br><span class="line"><span class="function">STAGE XVI: CLEAR TEMPORARY FLAGS</span></span><br></pre></td></tr></table></figure><p>下面将从蓝图编辑器按下编译按钮时进行剖析，在每个阶段遇到新的概念时会进行讲解。</p><p>当按下蓝图的编译按钮时，将会执行到 <code>FBlueprintEditor::Compile()</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FBlueprintEditor::Compile</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UBlueprint* BlueprintObj = <span class="built_in">GetBlueprintObj</span>();</span><br><span class="line">    FKismetEditorUtilities::<span class="built_in">CompileBlueprint</span>(BlueprintObj, CompileOptions, &amp;LogResults);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>UBlueprint</code> 就是用户正在编辑的蓝图资源。</p><p>最终会进入 <code>FBlueprintCompilationManagerImpl::FlushCompilationQueueImpl</code> 函数，此时正式进入蓝图编译的16个阶段。</p><p><img data-src="/images/UE5_blueprint_compile.png" alt="UE5_blueprint_compile"></p><h2 id="STAGE-I-GATHER"><a href="#STAGE-I-GATHER" class="headerlink" title="STAGE I: GATHER"></a>STAGE I: GATHER</h2><p>阶段1：收集所有需要重新编译的依赖蓝图。</p><p>若当前编译的蓝图是宏蓝图，则需要完全编译(生成骨架、字节码)所有依赖该宏蓝图的蓝图，因为宏的引脚类型可能发生变化。</p><p>而依赖该普通蓝图的蓝图仅需重新生成字节码，而不重新生成骨架，虽然引脚类型也可能发生改变，但此时还没有足够的信息证实是否发生了改变，先假定没有发生改变，避免不必要的开销。</p><div class="post-button"><a class="btn" href="/UE5%20%E8%93%9D%E5%9B%BE%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B%E5%89%96%E6%9E%90/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://yuerer.com/UE5%20%E5%8F%8D%E5%B0%84%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E4%B8%8E%E6%B3%A8%E5%86%8C/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpeg"><meta itemprop="name" content="Yuerer"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Yuerer's Blog"><meta itemprop="description" content="钰儿的Blog"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Yuerer's Blog"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/UE5%20%E5%8F%8D%E5%B0%84%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E4%B8%8E%E6%B3%A8%E5%86%8C/" class="post-title-link" itemprop="url">UE5 反射代码生成与注册</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-01-11 22:17:20" itemprop="dateCreated datePublished" datetime="2025-01-11T22:17:20+08:00">2025-01-11</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UE/" itemprop="url" rel="index"><span itemprop="name">UE</span></a> </span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Waline：</span> <a title="waline" href="/UE5%20%E5%8F%8D%E5%B0%84%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E4%B8%8E%E6%B3%A8%E5%86%8C/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/UE5%20%E5%8F%8D%E5%B0%84%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E4%B8%8E%E6%B3%A8%E5%86%8C/" itemprop="commentCount"></span> </a></span><span class="post-meta-item" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="waline-pageview-count" data-path="/UE5%20%E5%8F%8D%E5%B0%84%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E4%B8%8E%E6%B3%A8%E5%86%8C/"></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>本文以 UE5.4 为基准，剖析反射代码的生成内容和注册流程。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>UE5 的 C++ 需要各种宏来辅助开发，在编译时使用 <code>UHT</code> 工具扫描这些宏来生成 <code>XXX.generated.h</code> 和 <code>XXX.gen.cpp</code> 两个文件，接下来将分析UHT生成的文件，来学习反射具体做了什么。代码将会删减掉热更相关的内容，只关注核心逻辑。</p><h2 id="反射代码"><a href="#反射代码" class="headerlink" title="反射代码"></a>反射代码</h2><h3 id="Enum"><a href="#Enum" class="headerlink" title="Enum"></a>Enum</h3><p>枚举的声明在C++中有三种方式，C风格、namespace、enum class。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">ECppForm</span></span><br><span class="line">&#123;</span><br><span class="line">    Regular,</span><br><span class="line">    Namespaced,</span><br><span class="line">    EnumClass</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了减小本文篇幅，此处只看 enum class。在一个新文件中定义完该 enum class 后，进行构建。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UENUM</span>(BlueprintType)</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">EMyEnumClass</span>:uint8</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Enum1	<span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">&quot;DisplayInBlueprint&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">    Enum2,</span></span><br><span class="line"><span class="function">&#125;</span>;</span><br></pre></td></tr></table></figure><p>最终会生成 <code>generated.h</code> 和 <code>gen.cpp</code> 两个文件。</p><p><code>generated.h</code> 的内容如下，仅仅只是一些模板全特化，便于开发。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FOREACH_ENUM_EMYENUMCLASS(op) \</span></span><br><span class="line"><span class="meta">    op(EMyEnumClass::Enum1) \</span></span><br><span class="line"><span class="meta">    op(EMyEnumClass::Enum2) </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">EMyEnumClass</span> : uint8;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">TIsUEnumClass</span>&lt;EMyEnumClass&gt; &#123; <span class="keyword">enum</span> &#123; Value = <span class="literal">true</span> &#125;; &#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; REFLECTION_API UEnum* <span class="built_in">StaticEnum</span>&lt;EMyEnumClass&gt;();</span><br></pre></td></tr></table></figure><div class="post-button"><a class="btn" href="/UE5%20%E5%8F%8D%E5%B0%84%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E4%B8%8E%E6%B3%A8%E5%86%8C/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://yuerer.com/UE5%20%E7%BD%91%E7%BB%9C%E5%89%96%E6%9E%90(%E5%9B%9B)%20%E5%B1%9E%E6%80%A7%E5%90%8C%E6%AD%A5%E4%B8%8ERPC/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpeg"><meta itemprop="name" content="Yuerer"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Yuerer's Blog"><meta itemprop="description" content="钰儿的Blog"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Yuerer's Blog"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/UE5%20%E7%BD%91%E7%BB%9C%E5%89%96%E6%9E%90(%E5%9B%9B)%20%E5%B1%9E%E6%80%A7%E5%90%8C%E6%AD%A5%E4%B8%8ERPC/" class="post-title-link" itemprop="url">UE5 网络剖析(四) 属性同步与RPC</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2024-12-07 10:59:20" itemprop="dateCreated datePublished" datetime="2024-12-07T10:59:20+08:00">2024-12-07</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UE/" itemprop="url" rel="index"><span itemprop="name">UE</span></a> </span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Waline：</span> <a title="waline" href="/UE5%20%E7%BD%91%E7%BB%9C%E5%89%96%E6%9E%90(%E5%9B%9B)%20%E5%B1%9E%E6%80%A7%E5%90%8C%E6%AD%A5%E4%B8%8ERPC/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/UE5%20%E7%BD%91%E7%BB%9C%E5%89%96%E6%9E%90(%E5%9B%9B)%20%E5%B1%9E%E6%80%A7%E5%90%8C%E6%AD%A5%E4%B8%8ERPC/" itemprop="commentCount"></span> </a></span><span class="post-meta-item" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="waline-pageview-count" data-path="/UE5%20%E7%BD%91%E7%BB%9C%E5%89%96%E6%9E%90(%E5%9B%9B)%20%E5%B1%9E%E6%80%A7%E5%90%8C%E6%AD%A5%E4%B8%8ERPC/"></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>本文主要剖析 UE5 网络中是如何进行属性同步和RPC的。</p><h2 id="同步-Actor"><a href="#同步-Actor" class="headerlink" title="同步 Actor"></a>同步 Actor</h2><p>要进行属性同步，首先就要先同步 Actor，但更要知道哪些 Actor 需要网络同步。</p><h3 id="哪些-Actor-需要网络同步"><a href="#哪些-Actor-需要网络同步" class="headerlink" title="哪些 Actor 需要网络同步"></a>哪些 Actor 需要网络同步</h3><p>Actor 需要设置 <code>bReplicates</code> 为 true，才会进行同步，</p><p>以 Spawn Pawn 为例，玩家登录之后会由 <code>GameMode</code> 创建 Pawn 实例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AActor* <span class="title">UWorld::SpawnActor</span><span class="params">( UClass* Class, FVector <span class="type">const</span>* Location, FRotator <span class="type">const</span>* Rotation, <span class="type">const</span> FActorSpawnParameters&amp; SpawnParameters )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    AActor* <span class="type">const</span> Actor = <span class="built_in">NewObject</span>&lt;AActor&gt;(LevelToSpawnIn, Class, NewActorName, ActorFlags, Template, <span class="literal">false</span><span class="comment">/*bCopyTransientsFromClassDefaults*/</span>, <span class="literal">nullptr</span><span class="comment">/*InInstanceGraph*/</span>, ExternalPackage);</span><br><span class="line">    <span class="comment">// Add this newly spawned actor to the network actor list. Do this after PostSpawnInitialize so that actor has &quot;finished&quot; spawning.</span></span><br><span class="line">    <span class="built_in">AddNetworkActor</span>( Actor );</span><br><span class="line">    <span class="keyword">return</span> Actor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若 <code>bReplicates</code> 为 true，则 RemoteRole 为 ROLE_SimulatedProxy，表示是远端为模拟代理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AActor::PostInitProperties</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">PostInitProperties</span>();</span><br><span class="line">    RemoteRole = (bReplicates ? ROLE_SimulatedProxy : ROLE_None);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将需要同步的 Actor 加入到 NetDriver中的一个集合里， 至此就找到了要网络同步的 Actor，需要注意一点是 <code>Replicate</code> 是支持动态开关的。</p><div class="post-button"><a class="btn" href="/UE5%20%E7%BD%91%E7%BB%9C%E5%89%96%E6%9E%90(%E5%9B%9B)%20%E5%B1%9E%E6%80%A7%E5%90%8C%E6%AD%A5%E4%B8%8ERPC/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://yuerer.com/UE5%20%E7%BD%91%E7%BB%9C%E5%89%96%E6%9E%90(%E4%B8%89)%20%E7%99%BB%E5%BD%95/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpeg"><meta itemprop="name" content="Yuerer"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Yuerer's Blog"><meta itemprop="description" content="钰儿的Blog"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Yuerer's Blog"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/UE5%20%E7%BD%91%E7%BB%9C%E5%89%96%E6%9E%90(%E4%B8%89)%20%E7%99%BB%E5%BD%95/" class="post-title-link" itemprop="url">UE5 网络剖析(三) 登录</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2024-11-30 10:19:20" itemprop="dateCreated datePublished" datetime="2024-11-30T10:19:20+08:00">2024-11-30</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UE/" itemprop="url" rel="index"><span itemprop="name">UE</span></a> </span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Waline：</span> <a title="waline" href="/UE5%20%E7%BD%91%E7%BB%9C%E5%89%96%E6%9E%90(%E4%B8%89)%20%E7%99%BB%E5%BD%95/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/UE5%20%E7%BD%91%E7%BB%9C%E5%89%96%E6%9E%90(%E4%B8%89)%20%E7%99%BB%E5%BD%95/" itemprop="commentCount"></span> </a></span><span class="post-meta-item" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="waline-pageview-count" data-path="/UE5%20%E7%BD%91%E7%BB%9C%E5%89%96%E6%9E%90(%E4%B8%89)%20%E7%99%BB%E5%BD%95/"></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>本文剖析 UE5 客户端与DS建立连接后的登录流程，以及 <code>Bunch</code> 的发送接收，这样之后看属性同步时，能轻松一些。</p><h2 id="登录流程"><a href="#登录流程" class="headerlink" title="登录流程"></a>登录流程</h2><p>书接上回，握手之后会执行 <code>UPendingNetGame::SendInitialJoin</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UPendingNetGame::BeginHandshake</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Kick off the connection handshake</span></span><br><span class="line">    UNetConnection* ServerConn = NetDriver-&gt;ServerConnection;</span><br><span class="line">    <span class="keyword">if</span> (ServerConn-&gt;Handler.<span class="built_in">IsValid</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        ServerConn-&gt;Handler-&gt;<span class="built_in">BeginHandshaking</span>(</span><br><span class="line">            FPacketHandlerHandshakeComplete::<span class="built_in">CreateUObject</span>(<span class="keyword">this</span>, &amp;UPendingNetGame::SendInitialJoin));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">SendInitialJoin</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在继续分析之前，先来看官方的注释，描述了登录的流程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Most of the work <span class="keyword">for</span> handling these control messages are done either in UWorld::NotifyControlMessage,</span><br><span class="line"><span class="keyword">and</span> UPendingNetGame::NotifyControlMessage. Briefly, the flow looks like <span class="keyword">this</span>:</span><br><span class="line"></span><br><span class="line">Client<span class="string">&#x27;s UPendingNetGame::SendInitialJoin sends NMT_Hello.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Server&#x27;</span>s UWorld::NotifyControlMessage receives NMT_Hello, sends NMT_Challenge.</span><br><span class="line"></span><br><span class="line">Client<span class="string">&#x27;s UPendingNetGame::NotifyControlMessage receives NMT_Challenge, and sends back data in NMT_Login.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Server&#x27;</span>s UWorld::NotifyControlMessage receives NMT_Login, verifies challenge data, <span class="keyword">and</span> then calls AGameModeBase::PreLogin.</span><br><span class="line">If PreLogin doesn<span class="string">&#x27;t report any errors, Server calls UWorld::WelcomePlayer, which call AGameModeBase::GameWelcomePlayer,</span></span><br><span class="line"><span class="string">and send NMT_Welcome with map information.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Client&#x27;</span>s UPendingNetGame::NotifyControlMessage receives NMT_Welcome, <span class="function">reads the map <span class="title">info</span> <span class="params">(so it can start loading later)</span>,</span></span><br><span class="line"><span class="function"><span class="keyword">and</span> sends an NMT_NetSpeed message with the configured Net Speed of the client.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Server&#x27;s UWorld::NotifyControlMessage receives NMT_NetSpeed, <span class="keyword">and</span> adjusts the connections Net Speed appropriately.</span></span><br></pre></td></tr></table></figure><div class="post-button"><a class="btn" href="/UE5%20%E7%BD%91%E7%BB%9C%E5%89%96%E6%9E%90(%E4%B8%89)%20%E7%99%BB%E5%BD%95/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://yuerer.com/UE5%20%E7%BD%91%E7%BB%9C%E5%89%96%E6%9E%90(%E4%BA%8C)%20%E6%97%A0%E7%8A%B6%E6%80%81%E8%BF%9E%E6%8E%A5/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpeg"><meta itemprop="name" content="Yuerer"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Yuerer's Blog"><meta itemprop="description" content="钰儿的Blog"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Yuerer's Blog"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/UE5%20%E7%BD%91%E7%BB%9C%E5%89%96%E6%9E%90(%E4%BA%8C)%20%E6%97%A0%E7%8A%B6%E6%80%81%E8%BF%9E%E6%8E%A5/" class="post-title-link" itemprop="url">UE5 网络剖析(二) 无状态连接</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2024-11-23 10:38:20" itemprop="dateCreated datePublished" datetime="2024-11-23T10:38:20+08:00">2024-11-23</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UE/" itemprop="url" rel="index"><span itemprop="name">UE</span></a> </span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Waline：</span> <a title="waline" href="/UE5%20%E7%BD%91%E7%BB%9C%E5%89%96%E6%9E%90(%E4%BA%8C)%20%E6%97%A0%E7%8A%B6%E6%80%81%E8%BF%9E%E6%8E%A5/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/UE5%20%E7%BD%91%E7%BB%9C%E5%89%96%E6%9E%90(%E4%BA%8C)%20%E6%97%A0%E7%8A%B6%E6%80%81%E8%BF%9E%E6%8E%A5/" itemprop="commentCount"></span> </a></span><span class="post-meta-item" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="waline-pageview-count" data-path="/UE5%20%E7%BD%91%E7%BB%9C%E5%89%96%E6%9E%90(%E4%BA%8C)%20%E6%97%A0%E7%8A%B6%E6%80%81%E8%BF%9E%E6%8E%A5/"></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>本文主要剖析 UE5 中客户端是如何与DS建立连接，构建基础 Channel，以及无状态握手流程。</p><h2 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立"></a>连接建立</h2><h3 id="服务端监听流程"><a href="#服务端监听流程" class="headerlink" title="服务端监听流程"></a>服务端监听流程</h3><p><code>UGameInstance::EnableListenServer</code> 调用 <code>UWorld::Listen</code> 去创建 UNetDriver 对象。</p><p>UNetDriver 默认有两个子类， IpNetDriver 和 DemoNetDriver 后面一个用于回放。</p><p>根据要创建的 NetDriver 名, 查找并构造该 Driver, 并存入 World-&gt;Context.ActiveNetDrivers，这里面很多地方会用到，比如需要设置某个 Actor 冻结时，就需要通知各个 NetDriver。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UNetDriver* <span class="title">CreateNetDriver_Local</span><span class="params">(UEngine* Engine, FWorldContext&amp; Context, FName NetDriverDefinition, FName InNetDriverName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Definition = Engine-&gt;NetDriverDefinitions.<span class="built_in">FindByPredicate</span>(FindNetDriverDefPred);</span><br><span class="line">    UClass* NetDriverClass = <span class="built_in">StaticLoadClass</span>(UNetDriver::<span class="built_in">StaticClass</span>(), <span class="literal">nullptr</span>, *Definition-&gt;DriverClassName.<span class="built_in">ToString</span>(), <span class="literal">nullptr</span>, LOAD_Quiet);</span><br><span class="line">    ReturnVal = <span class="built_in">NewObject</span>&lt;UNetDriver&gt;(<span class="built_in">GetTransientPackage</span>(), NetDriverClass);</span><br><span class="line">    <span class="comment">// 数组 重载了 operator new</span></span><br><span class="line">    <span class="keyword">new</span>(Context.ActiveNetDrivers) <span class="built_in">FNamedNetDriver</span>(ReturnVal, Definition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="post-button"><a class="btn" href="/UE5%20%E7%BD%91%E7%BB%9C%E5%89%96%E6%9E%90(%E4%BA%8C)%20%E6%97%A0%E7%8A%B6%E6%80%81%E8%BF%9E%E6%8E%A5/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://yuerer.com/UE5%20%E7%BD%91%E7%BB%9C%E5%89%96%E6%9E%90(%E4%B8%80)%20%E5%8F%AF%E9%9D%A0UDP/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpeg"><meta itemprop="name" content="Yuerer"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Yuerer's Blog"><meta itemprop="description" content="钰儿的Blog"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Yuerer's Blog"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/UE5%20%E7%BD%91%E7%BB%9C%E5%89%96%E6%9E%90(%E4%B8%80)%20%E5%8F%AF%E9%9D%A0UDP/" class="post-title-link" itemprop="url">UE5 网络剖析(一) 可靠UDP</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2024-11-02 13:30:20" itemprop="dateCreated datePublished" datetime="2024-11-02T13:30:20+08:00">2024-11-02</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UE/" itemprop="url" rel="index"><span itemprop="name">UE</span></a> </span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Waline：</span> <a title="waline" href="/UE5%20%E7%BD%91%E7%BB%9C%E5%89%96%E6%9E%90(%E4%B8%80)%20%E5%8F%AF%E9%9D%A0UDP/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/UE5%20%E7%BD%91%E7%BB%9C%E5%89%96%E6%9E%90(%E4%B8%80)%20%E5%8F%AF%E9%9D%A0UDP/" itemprop="commentCount"></span> </a></span><span class="post-meta-item" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="waline-pageview-count" data-path="/UE5%20%E7%BD%91%E7%BB%9C%E5%89%96%E6%9E%90(%E4%B8%80)%20%E5%8F%AF%E9%9D%A0UDP/"></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>本文主要剖析 UE5 中的可靠UDP的设计思路。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>UE5的网络收发使用UDP进行通信，而UDP又是不可靠的协议，只管发出，不管对端是否收到，也不保序，因此需要有一套机制来使得UE5的数据包有保序、可靠这两大特点。</p><h2 id="Packet"><a href="#Packet" class="headerlink" title="Packet"></a>Packet</h2><p>UE5在UDP之上，包装了一层 Packet，其内部传输的数据是一个个 Bunch，可靠不可靠指的是 Bunch的属性，Bunch 是什么这个暂时可以先不用关心，但 Packet 是需要搞明白的，因为 UE5 是使用 Packet 来完成保序的工作。</p><h3 id="序列号"><a href="#序列号" class="headerlink" title="序列号"></a>序列号</h3><p>既然要实现保序、可靠，就需要知道对端收没收到包，那么自然是要通知对端我发的消息ID，以及我收到的消息ID，UE5也不例外，Packet 头部包含了 Seq 和 AckedSeq（取得最新收到的Packet的序列号），为了避免序列号回环无法直接比较序列号大小的情况，以及序列号占用比特位过大的问题，Seq 使用<code>TSequenceNumber</code> 实现，容量为14bit，可表示 <code>[0, 16383]</code>，两个 Seq 的差值若小于最大值的一半，则认为比较是正确的，没有发生回环。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;SIZE_T NumBits, <span class="keyword">typename</span> SequenceType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TSequenceNumber</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(TIsSigned&lt;SequenceType&gt;::Value == <span class="literal">false</span>, <span class="string">&quot;The base type for sequence numbers must be unsigned&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> SequenceT = SequenceType;</span><br><span class="line">    <span class="keyword">using</span> DifferenceT = int32;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constants</span></span><br><span class="line">    <span class="keyword">enum</span> &#123; SeqNumberBits = NumBits &#125;;</span><br><span class="line">    <span class="keyword">enum</span> &#123; SeqNumberCount = <span class="built_in">SequenceT</span>(<span class="number">1</span>) &lt;&lt; NumBits &#125;;</span><br><span class="line">    <span class="keyword">enum</span> &#123; SeqNumberHalf = <span class="built_in">SequenceT</span>(<span class="number">1</span>) &lt;&lt; (NumBits - <span class="number">1</span>) &#125;;</span><br><span class="line">    <span class="keyword">enum</span> &#123; SeqNumberMax = SeqNumberCount - <span class="number">1u</span> &#125;;</span><br><span class="line">    <span class="keyword">enum</span> &#123; SeqNumberMask = SeqNumberMax &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="post-button"><a class="btn" href="/UE5%20%E7%BD%91%E7%BB%9C%E5%89%96%E6%9E%90(%E4%B8%80)%20%E5%8F%AF%E9%9D%A0UDP/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://yuerer.com/Lua%205.4%20%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpeg"><meta itemprop="name" content="Yuerer"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Yuerer's Blog"><meta itemprop="description" content="钰儿的Blog"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="undefined | Yuerer's Blog"><meta itemprop="description" content=""></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/Lua%205.4%20%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" class="post-title-link" itemprop="url">Lua 5.4 分代垃圾回收</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2024-08-25 14:54:20" itemprop="dateCreated datePublished" datetime="2024-08-25T14:54:20+08:00">2024-08-25</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Lua/" itemprop="url" rel="index"><span itemprop="name">Lua</span></a> </span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Waline：</span> <a title="waline" href="/Lua%205.4%20%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/Lua%205.4%20%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" itemprop="commentCount"></span> </a></span><span class="post-meta-item" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="waline-pageview-count" data-path="/Lua%205.4%20%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>近期在改 Lua 5.4 的垃圾回收，虽然之前也写过分代垃圾回收的原理，但这次改完之后对其更有感悟，就简单记录一下Lua 5.4 的分代垃圾回收的实现原理。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>分代垃圾回收认为对象分为年轻代和老年代，其中年轻代对象很快就会被释放(比如临时对象)，而老年代对象存在的时间比较长，不容易被释放，因此也就不需要经常去扫描老年代，只需要经常去扫描年轻代，等到年轻代垃圾回收的时候实在收不回对象，再进行一次全量垃圾回收。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Lua 的 age 总共占用 3 Bit，刚创建出来的对象为 <code>G_NEW</code> ，当它活过一轮垃圾回收后，提升为 <code>G_SURVIVAL</code> ，若再活过一轮垃圾回收，则彻底进入 <code>G_OLD</code> 老年代，不在年轻代中扫描它。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> G_NEW		0	<span class="comment">/* created in current cycle */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> G_SURVIVAL	1	<span class="comment">/* created in previous cycle */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> G_OLD0		2	<span class="comment">/* marked old by frw. barrier in this cycle */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> G_OLD1		3	<span class="comment">/* first full cycle as old */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> G_OLD		4	<span class="comment">/* really old object (not to be visited) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> G_TOUCHED1	5	<span class="comment">/* old object touched this cycle */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> G_TOUCHED2	6	<span class="comment">/* old object touched in previous cycle */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AGEBITS		7  <span class="comment">/* all age bits (111) */</span></span></span><br></pre></td></tr></table></figure><p>这里面的 <code>G_OLD0</code> 是用于 Barrier forward，假设你创建了一个新对象，它本该是 <code>G_NEW</code> 但因为它被老年代对象引用，所以必须要强行将它改为老年代，否则会发生跨代引用，该新对象直接被清理掉。</p><p>同理 <code>G_TOUCHED1</code> 则是用于 Barrier back，假设你创建了一个新对象，然后放置在一个老年代的 table中，此时为了不频繁触发该 table 的 barrier，则将其修改为 <code>G_TOUCHED1</code> ，同时将其放置在 <code>grayagain</code> 链表中，这是因为老年代table是不会在年轻代的垃圾回收中被扫描到，但此时老年代又确实引用了年轻代对象，所以要将它放在一条特殊链表中，使其能在年轻代中被扫描到。</p><div class="post-button"><a class="btn" href="/Lua%205.4%20%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><nav class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a></nav></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Yuerer</span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://unpkg.com/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://unpkg.com/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/comments.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/utils.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/motion.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/sidebar.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/next-boot.min.js"></script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://yuerer-comment-xufei-0bea01e6f05-1307930306.ap-shanghai.app.tcloudbase.com","cssUrl":"https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.css","commentCount":true,"pageview":true,"libUrl":"https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.js","locale":{"placeholder":"有何高见？"},"emoji":["https://unpkg.com/@waline/emojis@1.0.1/qq"],"meta":["nick","mail"],"requiredMeta":[["nick","mail"]],"wordLimit":0,"login":"disable","pageSize":10,"el":"#waline","comment":true,"path":"/"}</script><link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.css"><script>document.addEventListener("page:loaded",()=>{NexT.utils.loadComments(CONFIG.waline.el).then(()=>NexT.utils.getScript(CONFIG.waline.libUrl,{condition:window.Waline})).then(()=>Waline.init(Object.assign({},CONFIG.waline,{el:document.querySelector(CONFIG.waline.el)})))})</script></body></html>