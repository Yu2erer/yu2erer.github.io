<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.jpeg"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.ico"><link rel="mask-icon" href="/images/avatar.jpeg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous"><link rel="stylesheet" href="https://unpkg.com/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"yuerer.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"hide","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":true,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/config.min.js"></script><meta name="description" content="一直觉得关系型数据库非常难用，在使用之前要先定好表的结构，中途修改存储结构，改动就会非常繁杂，特别是 外键 这玩意离开了学校就再也没见过。好在在 游戏领域 中，用的最多的都是 NoSQL 。 熟悉我风格的人，可以看出这个系列的标题，不再是 源码剖析，而是只有 剖析 两字，主要是考虑到 Redis 6.0 的代码量已经挺大了，同时网络中又有大量关于 Redis 数据结构的源码剖析，没必要再炒冷饭了。"><meta property="og:type" content="article"><meta property="og:title" content="Redis 6 剖析(一) 异步机制"><meta property="og:url" content="https://yuerer.com/Redis-6-%E5%89%96%E6%9E%90(%E4%B8%80)-%E5%BC%82%E6%AD%A5%E6%9C%BA%E5%88%B6/index.html"><meta property="og:site_name" content="Yuerer&#39;s Blog"><meta property="og:description" content="一直觉得关系型数据库非常难用，在使用之前要先定好表的结构，中途修改存储结构，改动就会非常繁杂，特别是 外键 这玩意离开了学校就再也没见过。好在在 游戏领域 中，用的最多的都是 NoSQL 。 熟悉我风格的人，可以看出这个系列的标题，不再是 源码剖析，而是只有 剖析 两字，主要是考虑到 Redis 6.0 的代码量已经挺大了，同时网络中又有大量关于 Redis 数据结构的源码剖析，没必要再炒冷饭了。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://yuerer.com/images/Redis6-ThreadIO-Init.png"><meta property="og:image" content="https://yuerer.com/images/Redis6-ThreadIO.png"><meta property="article:published_time" content="2021-03-26T15:46:20.000Z"><meta property="article:modified_time" content="2025-10-21T13:50:52.260Z"><meta property="article:author" content="Yuerer"><meta property="article:tag" content="Redis"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://yuerer.com/images/Redis6-ThreadIO-Init.png"><link rel="canonical" href="https://yuerer.com/Redis-6-%E5%89%96%E6%9E%90(%E4%B8%80)-%E5%BC%82%E6%AD%A5%E6%9C%BA%E5%88%B6/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://yuerer.com/Redis-6-%E5%89%96%E6%9E%90(%E4%B8%80)-%E5%BC%82%E6%AD%A5%E6%9C%BA%E5%88%B6/","path":"Redis-6-剖析(一)-异步机制/","title":"Redis 6 剖析(一) 异步机制"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Redis 6 剖析(一) 异步机制 | Yuerer's Blog</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-129491388-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-129491388-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/third-party/analytics/google-analytics.min.js"></script><link rel="dns-prefetch" href="https://yuerer-comment-xufei-0bea01e6f05-1307930306.ap-shanghai.app.tcloudbase.com"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Yuerer's Blog</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">钰儿的Blog</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E7%82%B9"><span class="nav-text">阻塞点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C-I-O-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-text">网络 I&#x2F;O (多线程)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#initThreadedIO"><span class="nav-text">initThreadedIO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IOThreadMain"><span class="nav-text">IOThreadMain</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Threaded-I-O-%E8%AF%BB%E5%86%99%E6%B5%81%E7%A8%8B"><span class="nav-text">Threaded I&#x2F;O 读写流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#handleClientsWithPendingReadsUsingThreads"><span class="nav-text">handleClientsWithPendingReadsUsingThreads</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#handleClientsWithPendingWritesUsingThreads"><span class="nav-text">handleClientsWithPendingWritesUsingThreads</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BIO-%E4%B8%89%E4%B8%AA%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-text">BIO (三个多线程)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#bioInit"><span class="nav-text">bioInit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bioProcessBackgroundJobs"><span class="nav-text">bioProcessBackgroundJobs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-text">关闭文件描述符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BA%A4%E4%BA%92-%E6%83%B0%E6%80%A7%E5%88%A0%E9%99%A4"><span class="nav-text">客户端交互 (惰性删除)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF-%E6%97%A5%E5%BF%97"><span class="nav-text">AOF 日志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#propagate"><span class="nav-text">propagate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#feedAppendOnlyFile"><span class="nav-text">feedAppendOnlyFile</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#flushAppendOnlyFile"><span class="nav-text">flushAppendOnlyFile</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOF%E6%97%A5%E5%BF%97%E9%87%8D%E5%86%99-%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="nav-text">AOF日志重写 (多进程)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#rewriteAppendOnlyFileBackground"><span class="nav-text">rewriteAppendOnlyFileBackground</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#checkChildrenDone"><span class="nav-text">checkChildrenDone</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RDB-%E5%BF%AB%E7%85%A7-%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="nav-text">RDB 快照 (多进程)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Yuerer" src="/images/avatar.jpeg"><p class="site-author-name" itemprop="name">Yuerer</p><div class="site-description" itemprop="description">钰儿的Blog</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">65</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">16</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">90</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/Yu2erer" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Yu2erer" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:yu2erer#gmail.com" title="E-Mail → mailto:yu2erer#gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://yuerer.com/Redis-6-%E5%89%96%E6%9E%90(%E4%B8%80)-%E5%BC%82%E6%AD%A5%E6%9C%BA%E5%88%B6/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpeg"><meta itemprop="name" content="Yuerer"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Yuerer's Blog"><meta itemprop="description" content="钰儿的Blog"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Redis 6 剖析(一) 异步机制 | Yuerer's Blog"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Redis 6 剖析(一) 异步机制</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-03-26 23:46:20" itemprop="dateCreated datePublished" datetime="2021-03-26T23:46:20+08:00">2021-03-26</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a> </span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Waline：</span> <a title="waline" href="/Redis-6-%E5%89%96%E6%9E%90(%E4%B8%80)-%E5%BC%82%E6%AD%A5%E6%9C%BA%E5%88%B6/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/Redis-6-%E5%89%96%E6%9E%90(%E4%B8%80)-%E5%BC%82%E6%AD%A5%E6%9C%BA%E5%88%B6/" itemprop="commentCount"></span> </a></span><span class="post-meta-item" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="waline-pageview-count" data-path="/Redis-6-%E5%89%96%E6%9E%90(%E4%B8%80)-%E5%BC%82%E6%AD%A5%E6%9C%BA%E5%88%B6/"></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>一直觉得关系型数据库非常难用，在使用之前要先定好表的结构，中途修改存储结构，改动就会非常繁杂，特别是 <code>外键</code> 这玩意离开了学校就再也没见过。好在在 <code>游戏领域</code> 中，用的最多的都是 <code>NoSQL</code> 。</p><p>熟悉我风格的人，可以看出这个系列的标题，不再是 <code>源码剖析</code>，而是只有 <code>剖析</code> 两字，主要是考虑到 <code>Redis 6.0</code> 的代码量已经挺大了，同时网络中又有大量关于 <code>Redis</code> 数据结构的源码剖析，没必要再炒冷饭了。</p><p>出于以上的原因，我将 <code>Redis</code> 分为几个部分进行剖析和讨论。</p><ol><li>异步机制</li><li>主从同步</li><li>集群</li><li>数据结构</li></ol><p>本篇主要是来剖析 <code>Redis</code> 为了避免 <code>阻塞</code> ，是如何运用 <code>多进程</code> 与 <code>多线程</code>，这两种异步机制的。</p><h2 id="阻塞点"><a href="#阻塞点" class="headerlink" title="阻塞点"></a>阻塞点</h2><p><code>Redis</code> 一般有以下几种阻塞的点。</p><p>从网络交互来看有</p><ul><li>网络 I&#x2F;O (多线程)</li><li>客户端交互 (部分删除用多线程 <code>BIO</code>)</li><li>传输 RDB 快照 (多进程)</li></ul><p>从磁盘交互又分</p><ul><li>关闭文件 (多线程 <code>BIO</code>)</li><li>记录 AOF 日志 (多线程 <code>BIO</code>)</li><li>AOF 日志重写 (多进程)</li><li>RDB 快照生成 (多进程)</li></ul><span id="more"></span><h2 id="网络-I-O-多线程"><a href="#网络-I-O-多线程" class="headerlink" title="网络 I&#x2F;O (多线程)"></a>网络 I&#x2F;O (多线程)</h2><p><code>Redis</code> 在早期的版本中 采用的是 <code>单线程 + I/O 多路复用</code> 的模型，而在最新的 <code>6.0</code> ，采用了 <code>Thread I/O</code> ，默认不会开启，开启需要在配置中加入以下两行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">io-threads-do-reads true // 开启多线程读和解析执行</span><br><span class="line">io-threads 2 // 开启多少个线程，至少要大于 1</span><br></pre></td></tr></table></figure><p><code>Redis</code> 在初始化的时候，会调用 <code>initThreadedIO</code> 。</p><p><img data-src="/images/Redis6-ThreadIO-Init.png" alt="Redis6-ThreadIO-Init"></p><h3 id="initThreadedIO"><a href="#initThreadedIO" class="headerlink" title="initThreadedIO"></a>initThreadedIO</h3><p>根据配置，创建 <code>server.io_threads_num</code> 个子线程，如果只是 一个，则选择直接返回，将 网络I&#x2F;O的处理放到主线程（相当于使用单线程I&#x2F;O）。</p><p>通过为每个线程创建一个 <code>mutex</code> 来达到 临时开启暂停子线程的功能，之所以需要这样，主要是 子线程都是一个死循环，采用 <code>自旋锁</code> 的形式去获取任务链表，如果一直没有任务，CPU占用也会达到 <code>100%</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Initialize the data structures needed for threaded I/O. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initThreadedIO</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    server.io_threads_active = <span class="number">0</span>; <span class="comment">/* We start with threads not active. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don&#x27;t spawn any thread if the user selected a single thread:</span></span><br><span class="line"><span class="comment">     * we&#x27;ll handle I/O directly from the main thread. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.io_threads_num == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.io_threads_num &gt; IO_THREADS_MAX_NUM) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Fatal: too many I/O threads configured. &quot;</span></span><br><span class="line">                             <span class="string">&quot;The maximum number is %d.&quot;</span>, IO_THREADS_MAX_NUM);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Spawn and initialize the I/O threads. */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; server.io_threads_num; i++) &#123;</span><br><span class="line">        <span class="comment">/* Things we do for all the threads including the main thread. */</span></span><br><span class="line">        io_threads_list[i] = listCreate();</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">/* Thread 0 is the main thread. */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Things we do only for the additional threads. */</span></span><br><span class="line">        <span class="type">pthread_t</span> tid;</span><br><span class="line">        pthread_mutex_init(&amp;io_threads_mutex[i],<span class="literal">NULL</span>);</span><br><span class="line">        setIOPendingCount(i, <span class="number">0</span>);</span><br><span class="line">        pthread_mutex_lock(&amp;io_threads_mutex[i]); <span class="comment">/* Thread will be stopped. */</span></span><br><span class="line">        <span class="keyword">if</span> (pthread_create(&amp;tid,<span class="literal">NULL</span>,IOThreadMain,(<span class="type">void</span>*)(<span class="type">long</span>)i) != <span class="number">0</span>) &#123;</span><br><span class="line">            serverLog(LL_WARNING,<span class="string">&quot;Fatal: Can&#x27;t initialize IO thread.&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        io_threads[i] = tid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="IOThreadMain"><a href="#IOThreadMain" class="headerlink" title="IOThreadMain"></a>IOThreadMain</h3><p>通过 <code>atomic</code> 实现自旋锁的形式，去获取任务列表，再根据写任务或读任务去执行。其中在一开始的时候通过 <code>lock(mutex)</code> 的形式，给主线程暂停子线程的机会。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IO_THREADS_MAX_NUM 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IO_THREADS_OP_READ 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IO_THREADS_OP_WRITE 1</span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> io_threads[IO_THREADS_MAX_NUM];</span><br><span class="line"><span class="type">pthread_mutex_t</span> io_threads_mutex[IO_THREADS_MAX_NUM];</span><br><span class="line">redisAtomic <span class="type">unsigned</span> <span class="type">long</span> io_threads_pending[IO_THREADS_MAX_NUM];</span><br><span class="line"><span class="type">int</span> io_threads_op;      <span class="comment">/* IO_THREADS_OP_WRITE or IO_THREADS_OP_READ. */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span> *io_threads_list[IO_THREADS_MAX_NUM];</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">getIOPendingCount</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> count = <span class="number">0</span>;</span><br><span class="line">    atomicGetWithSync(io_threads_pending[i], count);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">setIOPendingCount</span><span class="params">(<span class="type">int</span> i, <span class="type">unsigned</span> <span class="type">long</span> count)</span> &#123;</span><br><span class="line">    atomicSetWithSync(io_threads_pending[i], count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">IOThreadMain</span><span class="params">(<span class="type">void</span> *myid)</span> &#123;</span><br><span class="line">    <span class="comment">/* The ID is the thread number (from 0 to server.iothreads_num-1), and is</span></span><br><span class="line"><span class="comment">     * used by the thread to just manipulate a single sub-array of clients. */</span></span><br><span class="line">    <span class="type">long</span> id = (<span class="type">unsigned</span> <span class="type">long</span>)myid;</span><br><span class="line">    <span class="type">char</span> thdname[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(thdname, <span class="keyword">sizeof</span>(thdname), <span class="string">&quot;io_thd_%ld&quot;</span>, id);</span><br><span class="line">    redis_set_thread_title(thdname);</span><br><span class="line">    redisSetCpuAffinity(server.server_cpulist);</span><br><span class="line">    makeThreadKillable();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* Wait for start */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000000</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getIOPendingCount(id) != <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Give the main thread a chance to stop this thread. */</span></span><br><span class="line">        <span class="keyword">if</span> (getIOPendingCount(id) == <span class="number">0</span>) &#123;</span><br><span class="line">            pthread_mutex_lock(&amp;io_threads_mutex[id]);</span><br><span class="line">            pthread_mutex_unlock(&amp;io_threads_mutex[id]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        serverAssert(getIOPendingCount(id) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Process: note that the main thread will never touch our list</span></span><br><span class="line"><span class="comment">         * before we drop the pending count to 0. */</span></span><br><span class="line">        listIter li;</span><br><span class="line">        listNode *ln;</span><br><span class="line">        listRewind(io_threads_list[id],&amp;li);</span><br><span class="line">        <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">            client *c = listNodeValue(ln);</span><br><span class="line">            <span class="keyword">if</span> (io_threads_op == IO_THREADS_OP_WRITE) &#123;</span><br><span class="line">                writeToClient(c,<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (io_threads_op == IO_THREADS_OP_READ) &#123;</span><br><span class="line">                readQueryFromClient(c-&gt;conn);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                serverPanic(<span class="string">&quot;io_threads_op value is unknown&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        listEmpty(io_threads_list[id]);</span><br><span class="line">        setIOPendingCount(id, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Threaded-I-O-读写流程"><a href="#Threaded-I-O-读写流程" class="headerlink" title="Threaded I&#x2F;O 读写流程"></a>Threaded I&#x2F;O 读写流程</h3><ol><li><code>beforeSleep</code> 会先遍历所有待读的客户端，采用 <code>Round-Robin</code> 将其分配到各个线程。</li><li>通过原子操作设置任务数量，交给 <code>I/O线程</code> 操作，自旋等到操作完成，再回到主线程执行命令，并加入到 <code>clients_pending_write</code> 。</li><li>遍历所有待写的客户端，再次用相同的策略分配到各个线程。</li><li>通过原子操作设置任务数量，再次交给 <code>I/O线程</code> 操作，自旋等待完成。</li><li>如果还没写完，则设置 <code>Write Handler</code> 到 <code>epoll</code> ，之后未完成的写任务交给主线程去写。</li></ol><p><img data-src="/images/Redis6-ThreadIO.png" alt="Redis6-ThreadIO"></p><h3 id="handleClientsWithPendingReadsUsingThreads"><a href="#handleClientsWithPendingReadsUsingThreads" class="headerlink" title="handleClientsWithPendingReadsUsingThreads"></a>handleClientsWithPendingReadsUsingThreads</h3><p>读操作，先检查 <code>I/O 线程</code> 是否关闭，从 <code>clients_pending_read</code> 中取出并进行分配到子线程， 访问 <code>io_threads_list</code> 不需要加锁， <code>io_threads_list[i]</code> 只会有主线程和 i子线程访问，而主线程与子线程之间又通过一个原子变量进行同步，之间通过自旋的形式解决了数据竞争的问题，在等待任务完成的同时，主线程也承担一部分的读操作。最后加入到 <code>clients_pending_write</code> 链表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">handleClientsWithPendingReadsUsingThreads</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!server.io_threads_active || !server.io_threads_do_reads) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> processed = listLength(server.clients_pending_read);</span><br><span class="line">    <span class="keyword">if</span> (processed == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Distribute the clients across N different lists. */</span></span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    listRewind(server.clients_pending_read,&amp;li);</span><br><span class="line">    <span class="type">int</span> item_id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line">        <span class="type">int</span> target_id = item_id % server.io_threads_num;</span><br><span class="line">        listAddNodeTail(io_threads_list[target_id],c);</span><br><span class="line">        item_id++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Give the start condition to the waiting threads, by setting the</span></span><br><span class="line"><span class="comment">     * start condition atomic var. */</span></span><br><span class="line">    io_threads_op = IO_THREADS_OP_READ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; server.io_threads_num; j++) &#123;</span><br><span class="line">        <span class="type">int</span> count = listLength(io_threads_list[j]);</span><br><span class="line">        setIOPendingCount(j, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Also use the main thread to process a slice of clients. */</span></span><br><span class="line">    listRewind(io_threads_list[<span class="number">0</span>],&amp;li);</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line">        readQueryFromClient(c-&gt;conn);</span><br><span class="line">    &#125;</span><br><span class="line">    listEmpty(io_threads_list[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait for all the other threads to end their work. */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> pending = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; server.io_threads_num; j++)</span><br><span class="line">            pending += getIOPendingCount(j);</span><br><span class="line">        <span class="keyword">if</span> (pending == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Run the list of clients again to process the new buffers. */</span></span><br><span class="line">    <span class="keyword">while</span>(listLength(server.clients_pending_read)) &#123;</span><br><span class="line">        ln = listFirst(server.clients_pending_read);</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line">        c-&gt;flags &amp;= ~CLIENT_PENDING_READ;</span><br><span class="line">        listDelNode(server.clients_pending_read,ln);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (processPendingCommandsAndResetClient(c) == C_ERR) &#123;</span><br><span class="line">            <span class="comment">/* If the client is no longer valid, we avoid</span></span><br><span class="line"><span class="comment">             * processing the client later. So we just go</span></span><br><span class="line"><span class="comment">             * to the next. */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        processInputBuffer(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We may have pending replies if a thread readQueryFromClient() produced</span></span><br><span class="line"><span class="comment">         * replies and did not install a write handler (it can&#x27;t).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_PENDING_WRITE) &amp;&amp; clientHasPendingReplies(c))</span><br><span class="line">            clientInstallWriteHandler(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Update processed count on server */</span></span><br><span class="line">    server.stat_io_reads_processed += processed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="handleClientsWithPendingWritesUsingThreads"><a href="#handleClientsWithPendingWritesUsingThreads" class="headerlink" title="handleClientsWithPendingWritesUsingThreads"></a>handleClientsWithPendingWritesUsingThreads</h3><p>写操作，检查一下 <code>I/O线程</code> 是否开启，当任务量少的时候，会通过 <code>lock(mutex)</code> 临时阻塞子线程，因为子线程是一个死循环，就算没有任务也会占满 <code>CPU</code> 。如果没有写完，则会设置写回调，注册到 <code>epoll</code> 中，下次由主线程去写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">stopThreadedIOIfNeeded</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> pending = listLength(server.clients_pending_write);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return ASAP if IO threads are disabled (single threaded mode). */</span></span><br><span class="line">    <span class="keyword">if</span> (server.io_threads_num == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pending &lt; (server.io_threads_num*<span class="number">2</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (server.io_threads_active) stopThreadedIO();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">handleClientsWithPendingWritesUsingThreads</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> processed = listLength(server.clients_pending_write);</span><br><span class="line">    <span class="keyword">if</span> (processed == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* Return ASAP if there are no clients. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If I/O threads are disabled or we have few clients to serve, don&#x27;t</span></span><br><span class="line"><span class="comment">     * use I/O threads, but the boring synchronous code. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.io_threads_num == <span class="number">1</span> || stopThreadedIOIfNeeded()) &#123;</span><br><span class="line">        <span class="keyword">return</span> handleClientsWithPendingWrites();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Start threads if needed. */</span></span><br><span class="line">    <span class="keyword">if</span> (!server.io_threads_active) startThreadedIO();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Distribute the clients across N different lists. */</span></span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    listRewind(server.clients_pending_write,&amp;li);</span><br><span class="line">    <span class="type">int</span> item_id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line">        c-&gt;flags &amp;= ~CLIENT_PENDING_WRITE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Remove clients from the list of pending writes since</span></span><br><span class="line"><span class="comment">         * they are going to be closed ASAP. */</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_CLOSE_ASAP) &#123;</span><br><span class="line">            listDelNode(server.clients_pending_write, ln);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> target_id = item_id % server.io_threads_num;</span><br><span class="line">        listAddNodeTail(io_threads_list[target_id],c);</span><br><span class="line">        item_id++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Give the start condition to the waiting threads, by setting the</span></span><br><span class="line"><span class="comment">     * start condition atomic var. */</span></span><br><span class="line">    io_threads_op = IO_THREADS_OP_WRITE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; server.io_threads_num; j++) &#123;</span><br><span class="line">        <span class="type">int</span> count = listLength(io_threads_list[j]);</span><br><span class="line">        setIOPendingCount(j, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Also use the main thread to process a slice of clients. */</span></span><br><span class="line">    listRewind(io_threads_list[<span class="number">0</span>],&amp;li);</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line">        writeToClient(c,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    listEmpty(io_threads_list[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait for all the other threads to end their work. */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> pending = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; server.io_threads_num; j++)</span><br><span class="line">            pending += getIOPendingCount(j);</span><br><span class="line">        <span class="keyword">if</span> (pending == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Run the list of clients again to install the write handler where</span></span><br><span class="line"><span class="comment">     * needed. */</span></span><br><span class="line">    listRewind(server.clients_pending_write,&amp;li);</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Install the write handler if there are pending writes in some</span></span><br><span class="line"><span class="comment">         * of the clients. */</span></span><br><span class="line">        <span class="keyword">if</span> (clientHasPendingReplies(c) &amp;&amp;</span><br><span class="line">                connSetWriteHandler(c-&gt;conn, sendReplyToClient) == AE_ERR)</span><br><span class="line">        &#123;</span><br><span class="line">            freeClientAsync(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    listEmpty(server.clients_pending_write);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Update processed count on server */</span></span><br><span class="line">    server.stat_io_writes_processed += processed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出， <code>Redis</code> 的多线程模型并不是那么优雅，主线程完全没必要去等待所有线程的读或写操作，同时 <code>I/O线程</code> 又很暴力，直接一个死循环，吃光CPU，实现起来不够好，不过这也确实解决了单线程下 <code>Redis</code> 因为 <code>read</code> ， <code>write</code> 系统调用导致的性能开销（用户缓冲区和内核缓冲区拷贝所带来的）。</p><p>在网络中，见到不少人批判 <code>Redis</code> 使用自旋锁是一种开倒车的行为，但我不这么认为，使用 <code>mutex</code> 或者 <code>spinlock</code> 要根据实际情况来，当锁的粒度非常小的时候， <code>spinlock</code> 能够省去不必要的上下文切换的开销。</p><h2 id="BIO-三个多线程"><a href="#BIO-三个多线程" class="headerlink" title="BIO (三个多线程)"></a>BIO (三个多线程)</h2><p><code>BIO</code> 是 <code>Redis</code> 的后台线程，主要接收以下三种任务，每个任务都会开一个单独的线程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Background job opcodes */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIO_CLOSE_FILE    0 <span class="comment">/* Deferred close(2) syscall. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIO_AOF_FSYNC     1 <span class="comment">/* Deferred AOF fsync. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIO_LAZY_FREE     2 <span class="comment">/* Deferred objects freeing. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIO_NUM_OPS       3</span></span><br></pre></td></tr></table></figure><ol><li>关闭文件描述符。</li><li>AOF 同步内核缓冲区的数据到文件(fsync)。</li><li>惰性释放，将部分内存的释放放到另一个线程。</li></ol><h3 id="bioInit"><a href="#bioInit" class="headerlink" title="bioInit"></a>bioInit</h3><p>初始化三个后台线程的互斥量和条件变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">pthread_t</span> bio_threads[BIO_NUM_OPS];</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_mutex_t</span> bio_mutex[BIO_NUM_OPS];</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_cond_t</span> bio_newjob_cond[BIO_NUM_OPS];</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_cond_t</span> bio_step_cond[BIO_NUM_OPS];</span><br><span class="line"><span class="type">static</span> <span class="built_in">list</span> *bio_jobs[BIO_NUM_OPS];</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> bio_pending[BIO_NUM_OPS];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_THREAD_STACK_SIZE (1024*1024*4)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bioInit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">pthread_attr_t</span> attr;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    <span class="type">size_t</span> stacksize;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialization of state vars and objects */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; BIO_NUM_OPS; j++) &#123;</span><br><span class="line">        pthread_mutex_init(&amp;bio_mutex[j],<span class="literal">NULL</span>);</span><br><span class="line">        pthread_cond_init(&amp;bio_newjob_cond[j],<span class="literal">NULL</span>);</span><br><span class="line">        pthread_cond_init(&amp;bio_step_cond[j],<span class="literal">NULL</span>);</span><br><span class="line">        bio_jobs[j] = listCreate();</span><br><span class="line">        bio_pending[j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the stack size as by default it may be small in some system */</span></span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    pthread_attr_getstacksize(&amp;attr,&amp;stacksize);</span><br><span class="line">    <span class="keyword">if</span> (!stacksize) stacksize = <span class="number">1</span>; <span class="comment">/* The world is full of Solaris Fixes */</span></span><br><span class="line">    <span class="keyword">while</span> (stacksize &lt; REDIS_THREAD_STACK_SIZE) stacksize *= <span class="number">2</span>;</span><br><span class="line">    pthread_attr_setstacksize(&amp;attr, stacksize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Ready to spawn our threads. We use the single argument the thread</span></span><br><span class="line"><span class="comment">     * function accepts in order to pass the job ID the thread is</span></span><br><span class="line"><span class="comment">     * responsible of. */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; BIO_NUM_OPS; j++) &#123;</span><br><span class="line">        <span class="type">void</span> *arg = (<span class="type">void</span>*)(<span class="type">unsigned</span> <span class="type">long</span>) j;</span><br><span class="line">        <span class="keyword">if</span> (pthread_create(&amp;thread,&amp;attr,bioProcessBackgroundJobs,arg) != <span class="number">0</span>) &#123;</span><br><span class="line">            serverLog(LL_WARNING,<span class="string">&quot;Fatal: Can&#x27;t initialize Background Jobs.&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        bio_threads[j] = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bioProcessBackgroundJobs"><a href="#bioProcessBackgroundJobs" class="headerlink" title="bioProcessBackgroundJobs"></a>bioProcessBackgroundJobs</h3><p>设置线程名字，阻塞 <code>SIGALRM</code> 信号，然后不断获取任务，根据任务类型进行操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bio_job</span> &#123;</span></span><br><span class="line">    <span class="type">time_t</span> time; <span class="comment">/* Time at which the job was created. */</span></span><br><span class="line">    <span class="comment">/* Job specific arguments.*/</span></span><br><span class="line">    <span class="type">int</span> fd; <span class="comment">/* Fd for file based background jobs */</span></span><br><span class="line">    lazy_free_fn *free_fn; <span class="comment">/* Function that will free the provided arguments */</span></span><br><span class="line">    <span class="type">void</span> *free_args[]; <span class="comment">/* List of arguments to be passed to the free function */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">bioProcessBackgroundJobs</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio_job</span> *<span class="title">job</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> type = (<span class="type">unsigned</span> <span class="type">long</span>) arg;</span><br><span class="line">    <span class="type">sigset_t</span> sigset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check that the type is within the right interval. */</span></span><br><span class="line">    <span class="keyword">if</span> (type &gt;= BIO_NUM_OPS) &#123;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">&quot;Warning: bio thread started with wrong type %lu&quot;</span>,type);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> BIO_CLOSE_FILE:</span><br><span class="line">        redis_set_thread_title(<span class="string">&quot;bio_close_file&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BIO_AOF_FSYNC:</span><br><span class="line">        redis_set_thread_title(<span class="string">&quot;bio_aof_fsync&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BIO_LAZY_FREE:</span><br><span class="line">        redis_set_thread_title(<span class="string">&quot;bio_lazy_free&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    redisSetCpuAffinity(server.bio_cpulist);</span><br><span class="line"></span><br><span class="line">    makeThreadKillable();</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;bio_mutex[type]);</span><br><span class="line">    <span class="comment">/* Block SIGALRM so we are sure that only the main thread will</span></span><br><span class="line"><span class="comment">     * receive the watchdog signal. */</span></span><br><span class="line">    sigemptyset(&amp;sigset);</span><br><span class="line">    sigaddset(&amp;sigset, SIGALRM);</span><br><span class="line">    <span class="keyword">if</span> (pthread_sigmask(SIG_BLOCK, &amp;sigset, <span class="literal">NULL</span>))</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">&quot;Warning: can&#x27;t mask SIGALRM in bio.c thread: %s&quot;</span>, strerror(errno));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        listNode *ln;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* The loop always starts with the lock hold. */</span></span><br><span class="line">        <span class="keyword">if</span> (listLength(bio_jobs[type]) == <span class="number">0</span>) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;bio_newjob_cond[type],&amp;bio_mutex[type]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Pop the job from the queue. */</span></span><br><span class="line">        ln = listFirst(bio_jobs[type]);</span><br><span class="line">        job = ln-&gt;value;</span><br><span class="line">        <span class="comment">/* It is now possible to unlock the background system as we know have</span></span><br><span class="line"><span class="comment">         * a stand alone job structure to process.*/</span></span><br><span class="line">        pthread_mutex_unlock(&amp;bio_mutex[type]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Process the job accordingly to its type. */</span></span><br><span class="line">        <span class="keyword">if</span> (type == BIO_CLOSE_FILE) &#123;</span><br><span class="line">            close(job-&gt;fd);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == BIO_AOF_FSYNC) &#123;</span><br><span class="line">            redis_fsync(job-&gt;fd);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == BIO_LAZY_FREE) &#123;</span><br><span class="line">            job-&gt;free_fn(job-&gt;free_args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            serverPanic(<span class="string">&quot;Wrong job type in bioProcessBackgroundJobs().&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        zfree(job);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Lock again before reiterating the loop, if there are no longer</span></span><br><span class="line"><span class="comment">         * jobs to process we&#x27;ll block again in pthread_cond_wait(). */</span></span><br><span class="line">        pthread_mutex_lock(&amp;bio_mutex[type]);</span><br><span class="line">        listDelNode(bio_jobs[type],ln);</span><br><span class="line">        bio_pending[type]--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Unblock threads blocked on bioWaitStepOfType() if any. */</span></span><br><span class="line">        pthread_cond_broadcast(&amp;bio_step_cond[type]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关闭文件描述符"><a href="#关闭文件描述符" class="headerlink" title="关闭文件描述符"></a>关闭文件描述符</h3><p>关闭文件描述符，有可能会删除掉文件，引起阻塞。因为 <code>Redis</code> 实现的时候会通过 <code>rename</code> 覆盖掉原有文件，将文件描述符的关闭交给 <code>bio</code> 子线程避免阻塞。</p><h3 id="客户端交互-惰性删除"><a href="#客户端交互-惰性删除" class="headerlink" title="客户端交互 (惰性删除)"></a>客户端交互 (惰性删除)</h3><p>客户端操作，无非就是对数据结构进行增删改查，大部分的操作都是 <code>O(1)</code>，需要注意的是对集合的查询和聚合操作，同时删除一个 <code>BigKey</code> 也会带来性能开销，即使 <code>Redis</code> 用的 <code>jemalloc</code> 已经性能够好了。因此 <code>Redis</code> 选择开子线程的方式，去另一个线程释放内存。</p><p>这里有几个条件必须满足。</p><ol><li>该对象没有其他人共享了。</li><li>这个对象之后一定访问不到。(hash表中为 value 的情况)</li></ol><p>这样做也就不需要加锁了。（Lua 好适合这种情况）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">freeObjAsync</span><span class="params">(robj *key, robj *obj)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> free_effort = lazyfreeGetFreeEffort(key,obj);</span><br><span class="line">    <span class="keyword">if</span> (free_effort &gt; LAZYFREE_THRESHOLD &amp;&amp; obj-&gt;refcount == <span class="number">1</span>) &#123;</span><br><span class="line">        atomicIncr(lazyfree_objects,<span class="number">1</span>);</span><br><span class="line">        bioCreateLazyFreeJob(lazyfreeFreeObject,<span class="number">1</span>,obj);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        decrRefCount(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此删除东西最好用 <code>unlink</code> ，当其为 BigKey 时，就会放入 <code>bio</code> 进行释放。同理 <code>flushdb</code> 也可以异步清除。</p><h3 id="AOF-日志"><a href="#AOF-日志" class="headerlink" title="AOF 日志"></a>AOF 日志</h3><p>每当执行一条命令后，若开启了 <code>AOF日志</code> 则将其记录到 <code>AOF 缓冲区</code> （写后日志）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">propagate(c-&gt;cmd,c-&gt;db-&gt;id,c-&gt;argv,c-&gt;argc,propagate_flags);</span><br></pre></td></tr></table></figure><h3 id="propagate"><a href="#propagate" class="headerlink" title="propagate"></a>propagate</h3><p>AOF日志若开启，则调用 <code>feedAppendOnlyFile</code> 将其写入到 <code>server.aof_buf</code> 中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">propagate</span><span class="params">(<span class="keyword">struct</span> redisCommand *cmd, <span class="type">int</span> dbid, robj **argv, <span class="type">int</span> argc,</span></span><br><span class="line"><span class="params">               <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!server.replication_allowed)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Propagate a MULTI request once we encounter the first command which</span></span><br><span class="line"><span class="comment">     * is a write command.</span></span><br><span class="line"><span class="comment">     * This way we&#x27;ll deliver the MULTI/..../EXEC block as a whole and</span></span><br><span class="line"><span class="comment">     * both the AOF and the replication link will have the same consistency</span></span><br><span class="line"><span class="comment">     * and atomicity guarantees. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.in_exec &amp;&amp; !server.propagate_in_transaction)</span><br><span class="line">        execCommandPropagateMulti(dbid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This needs to be unreachable since the dataset should be fixed during </span></span><br><span class="line"><span class="comment">     * client pause, otherwise data may be lossed during a failover. */</span></span><br><span class="line">    serverAssert(!(areClientsPaused() &amp;&amp; !server.client_pause_in_transaction));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.aof_state != AOF_OFF &amp;&amp; flags &amp; PROPAGATE_AOF)</span><br><span class="line">        feedAppendOnlyFile(cmd,dbid,argv,argc);</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; PROPAGATE_REPL)</span><br><span class="line">        replicationFeedSlaves(server.slaves,dbid,argv,argc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="feedAppendOnlyFile"><a href="#feedAppendOnlyFile" class="headerlink" title="feedAppendOnlyFile"></a>feedAppendOnlyFile</h3><p>先检查目前所用的 db， <code>Redis</code> 默认有 <code>REDIS_DEFAULT_DBNUM</code> 16个db。后将有相对时间过期的指令转换为绝对时间。如果有 <code>AOF</code> 子进程在重写日志，则还会将其写入<code>server.aof_rewrite_buf_blocks</code> 链表中，同时通过管道传输到子进程。就算子进程宕机了，主进程的 <code>AOF日志</code> 也还是完整的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">feedAppendOnlyFile</span><span class="params">(<span class="keyword">struct</span> redisCommand *cmd, <span class="type">int</span> dictid, robj **argv, <span class="type">int</span> argc)</span> &#123;</span><br><span class="line">    sds buf = sdsempty();</span><br><span class="line">    <span class="comment">/* The DB this command was targeting is not the same as the last command</span></span><br><span class="line"><span class="comment">     * we appended. To issue a SELECT command is needed. */</span></span><br><span class="line">    <span class="keyword">if</span> (dictid != server.aof_selected_db) &#123;</span><br><span class="line">        <span class="type">char</span> seldb[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">snprintf</span>(seldb,<span class="keyword">sizeof</span>(seldb),<span class="string">&quot;%d&quot;</span>,dictid);</span><br><span class="line">        buf = sdscatprintf(buf,<span class="string">&quot;*2\r\n$6\r\nSELECT\r\n$%lu\r\n%s\r\n&quot;</span>,</span><br><span class="line">            (<span class="type">unsigned</span> <span class="type">long</span>)<span class="built_in">strlen</span>(seldb),seldb);</span><br><span class="line">        server.aof_selected_db = dictid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cmd-&gt;proc == expireCommand || cmd-&gt;proc == pexpireCommand ||</span><br><span class="line">        cmd-&gt;proc == expireatCommand) &#123;</span><br><span class="line">        <span class="comment">/* Translate EXPIRE/PEXPIRE/EXPIREAT into PEXPIREAT */</span></span><br><span class="line">        buf = catAppendOnlyExpireAtCommand(buf,cmd,argv[<span class="number">1</span>],argv[<span class="number">2</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd-&gt;proc == setCommand &amp;&amp; argc &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        robj *pxarg = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">/* When SET is used with EX/PX argument setGenericCommand propagates them with PX millisecond argument.</span></span><br><span class="line"><span class="comment">         * So since the command arguments are re-written there, we can rely here on the index of PX being 3. */</span></span><br><span class="line">        <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">3</span>]-&gt;ptr, <span class="string">&quot;px&quot;</span>)) &#123;</span><br><span class="line">            pxarg = argv[<span class="number">4</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* For AOF we convert SET key value relative time in milliseconds to SET key value absolute time in</span></span><br><span class="line"><span class="comment">         * millisecond. Whenever the condition is true it implies that original SET has been transformed</span></span><br><span class="line"><span class="comment">         * to SET PX with millisecond time argument so we do not need to worry about unit here.*/</span></span><br><span class="line">        <span class="keyword">if</span> (pxarg) &#123;</span><br><span class="line">            robj *millisecond = getDecodedObject(pxarg);</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> when = strtoll(millisecond-&gt;ptr,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">            when += mstime();</span><br><span class="line"></span><br><span class="line">            decrRefCount(millisecond);</span><br><span class="line"></span><br><span class="line">            robj *newargs[<span class="number">5</span>];</span><br><span class="line">            newargs[<span class="number">0</span>] = argv[<span class="number">0</span>];</span><br><span class="line">            newargs[<span class="number">1</span>] = argv[<span class="number">1</span>];</span><br><span class="line">            newargs[<span class="number">2</span>] = argv[<span class="number">2</span>];</span><br><span class="line">            newargs[<span class="number">3</span>] = shared.pxat;</span><br><span class="line">            newargs[<span class="number">4</span>] = createStringObjectFromLongLong(when);</span><br><span class="line">            buf = catAppendOnlyGenericCommand(buf,<span class="number">5</span>,newargs);</span><br><span class="line">            decrRefCount(newargs[<span class="number">4</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            buf = catAppendOnlyGenericCommand(buf,argc,argv);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* All the other commands don&#x27;t need translation or need the</span></span><br><span class="line"><span class="comment">         * same translation already operated in the command vector</span></span><br><span class="line"><span class="comment">         * for the replication itself. */</span></span><br><span class="line">        buf = catAppendOnlyGenericCommand(buf,argc,argv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Append to the AOF buffer. This will be flushed on disk just before</span></span><br><span class="line"><span class="comment">     * of re-entering the event loop, so before the client will get a</span></span><br><span class="line"><span class="comment">     * positive reply about the operation performed. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_state == AOF_ON)</span><br><span class="line">        server.aof_buf = sdscatlen(server.aof_buf,buf,sdslen(buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If a background append only file rewriting is in progress we want to</span></span><br><span class="line"><span class="comment">     * accumulate the differences between the child DB and the current one</span></span><br><span class="line"><span class="comment">     * in a buffer, so that when the child process will do its work we</span></span><br><span class="line"><span class="comment">     * can append the differences to the new append only file. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.child_type == CHILD_TYPE_AOF)</span><br><span class="line">        aofRewriteBufferAppend((<span class="type">unsigned</span> <span class="type">char</span>*)buf,sdslen(buf));</span><br><span class="line"></span><br><span class="line">    sdsfree(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="flushAppendOnlyFile"><a href="#flushAppendOnlyFile" class="headerlink" title="flushAppendOnlyFile"></a>flushAppendOnlyFile</h3><p>AOF日志同步到硬盘的策略有三种，第一种不同步，由内核自己决定Flush时机，另一种每次都同步，但是 <code>fsync</code> 是会阻塞的，因此还有第三种每秒同步，通过 <code>BIO</code> 子线程，每秒去同步 <code>fsync</code> 一次，其实说是 <code>fsync</code> 也不准确，在 <code>Linux</code> 下用的是 <code>fdatasync</code> 省去了写文件的元数据开销。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bioCreateFsyncJob</span><span class="params">(<span class="type">int</span> fd)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio_job</span> *<span class="title">job</span> =</span> zmalloc(<span class="keyword">sizeof</span>(*job));</span><br><span class="line">    job-&gt;fd = fd;</span><br><span class="line"></span><br><span class="line">    bioSubmitJob(BIO_AOF_FSYNC, job);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">aof_background_fsync</span><span class="params">(<span class="type">int</span> fd)</span> &#123;</span><br><span class="line">    bioCreateFsyncJob(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AOF日志重写-多进程"><a href="#AOF日志重写-多进程" class="headerlink" title="AOF日志重写 (多进程)"></a>AOF日志重写 (多进程)</h2><p>前面提到的 AOF追加日志 是利用了子线程去执行 <code>fsync</code> ，而这里则是用子进程去重写 AOF日志。重写日志主要是根据数据库现状重新创建一份新的 AOF日志，如果在主线程上操作，会导致很长时间不能处理客户端的请求。</p><p>AOF日志重写要么是由客户端发起 <code>BGREWRITEAOF</code>，要么是 <code>serverCron</code> 周期性判断是否触发了 <code>AOF重写</code> 。</p><p>当前没有其他子进程做事情，比如说 RDB快照，AOF重写，或者 loaded module。</p><p>同时默认要求大于 <code>64*1024*1024</code> 并且对比上一次重写后的文件大小是否增长了 <code>100%</code> 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Trigger an AOF rewrite if needed. */</span></span><br><span class="line"><span class="keyword">if</span> (server.aof_state == AOF_ON &amp;&amp;</span><br><span class="line">	!hasActiveChildProcess() &amp;&amp;</span><br><span class="line">	server.aof_rewrite_perc &amp;&amp;</span><br><span class="line">	server.aof_current_size &gt; server.aof_rewrite_min_size)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> base = server.aof_rewrite_base_size ?</span><br><span class="line">		server.aof_rewrite_base_size : <span class="number">1</span>;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> growth = (server.aof_current_size*<span class="number">100</span>/base) - <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">if</span> (growth &gt;= server.aof_rewrite_perc) &#123;</span><br><span class="line">		serverLog(LL_NOTICE,<span class="string">&quot;Starting automatic rewriting of AOF on %lld%% growth&quot;</span>,growth);</span><br><span class="line">		rewriteAppendOnlyFileBackground();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rewriteAppendOnlyFileBackground"><a href="#rewriteAppendOnlyFileBackground" class="headerlink" title="rewriteAppendOnlyFileBackground"></a>rewriteAppendOnlyFileBackground</h3><p><code>fork</code> 一个子进程，同时父进程在有子进程的时候， <code>dict</code> 不扩容，这主要是因为 <code>fork</code> 采用的 <code>copy on write</code> ，尽量不去改动进程的内存，避免物理页复制引起内存暴涨，同时一定不要开启 <code>huge page</code> ，原因同上。</p><p>最后子进程将数据库信息重写，并从父进程的管道中获取新的数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rewriteAppendOnlyFileBackground</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> childpid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasActiveChildProcess()) <span class="keyword">return</span> C_ERR;</span><br><span class="line">    <span class="keyword">if</span> (aofCreatePipes() != C_OK) <span class="keyword">return</span> C_ERR;</span><br><span class="line">    <span class="keyword">if</span> ((childpid = redisFork(CHILD_TYPE_AOF)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> tmpfile[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Child */</span></span><br><span class="line">        redisSetProcTitle(<span class="string">&quot;redis-aof-rewrite&quot;</span>);</span><br><span class="line">        redisSetCpuAffinity(server.aof_rewrite_cpulist);</span><br><span class="line">        <span class="built_in">snprintf</span>(tmpfile,<span class="number">256</span>,<span class="string">&quot;temp-rewriteaof-bg-%d.aof&quot;</span>, (<span class="type">int</span>) getpid());</span><br><span class="line">        <span class="keyword">if</span> (rewriteAppendOnlyFile(tmpfile) == C_OK) &#123;</span><br><span class="line">            sendChildCowInfo(CHILD_INFO_TYPE_AOF_COW_SIZE, <span class="string">&quot;AOF rewrite&quot;</span>);</span><br><span class="line">            exitFromChild(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            exitFromChild(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Parent */</span></span><br><span class="line">        <span class="keyword">if</span> (childpid == <span class="number">-1</span>) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">&quot;Can&#x27;t rewrite append only file in background: fork: %s&quot;</span>,</span><br><span class="line">                strerror(errno));</span><br><span class="line">            aofClosePipes();</span><br><span class="line">            <span class="keyword">return</span> C_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">        serverLog(LL_NOTICE,</span><br><span class="line">            <span class="string">&quot;Background append only file rewriting started by pid %ld&quot;</span>,(<span class="type">long</span>) childpid);</span><br><span class="line">        server.aof_rewrite_scheduled = <span class="number">0</span>;</span><br><span class="line">        server.aof_rewrite_time_start = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We set appendseldb to -1 in order to force the next call to the</span></span><br><span class="line"><span class="comment">         * feedAppendOnlyFile() to issue a SELECT command, so the differences</span></span><br><span class="line"><span class="comment">         * accumulated by the parent into server.aof_rewrite_buf will start</span></span><br><span class="line"><span class="comment">         * with a SELECT statement and it will be safe to merge. */</span></span><br><span class="line">        server.aof_selected_db = <span class="number">-1</span>;</span><br><span class="line">        replicationScriptCacheFlush();</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C_OK; <span class="comment">/* unreached */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子进程完成之后，父进程会在 <code>checkChildrenDone</code> 接受它的返回值。</p><h3 id="checkChildrenDone"><a href="#checkChildrenDone" class="headerlink" title="checkChildrenDone"></a>checkChildrenDone</h3><p><code>rename</code> AOF日志文件名，将原文件的文件描述符交给 <code>bio</code> 进行 <code>close</code> 避免阻塞。</p><p>可以从 <code>ModuleForkDoneHandler</code> 推论 <code>Module</code> 也预留了 <code>fork</code> 接口去多进程完成一些模块的自定义任务。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">checkChildrenDone</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> statloc;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = wait3(&amp;statloc,WNOHANG,<span class="literal">NULL</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> exitcode = WEXITSTATUS(statloc);</span><br><span class="line">        <span class="type">int</span> bysignal = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (WIFSIGNALED(statloc)) bysignal = WTERMSIG(statloc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* sigKillChildHandler catches the signal and calls exit(), but we</span></span><br><span class="line"><span class="comment">         * must make sure not to flag lastbgsave_status, etc incorrectly.</span></span><br><span class="line"><span class="comment">         * We could directly terminate the child process via SIGUSR1</span></span><br><span class="line"><span class="comment">         * without handling it, but in this case Valgrind will log an</span></span><br><span class="line"><span class="comment">         * annoying error. */</span></span><br><span class="line">        <span class="keyword">if</span> (exitcode == SERVER_CHILD_NOERROR_RETVAL) &#123;</span><br><span class="line">            bysignal = SIGUSR1;</span><br><span class="line">            exitcode = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">            serverLog(LL_WARNING,<span class="string">&quot;wait3() returned an error: %s. &quot;</span></span><br><span class="line">                <span class="string">&quot;child_type: %s, child_pid = %d&quot;</span>,</span><br><span class="line">                strerror(errno),</span><br><span class="line">                strChildType(server.child_type),</span><br><span class="line">                (<span class="type">int</span>) server.child_pid);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == server.child_pid) &#123;</span><br><span class="line">            <span class="keyword">if</span> (server.child_type == CHILD_TYPE_RDB) &#123;</span><br><span class="line">                backgroundSaveDoneHandler(exitcode, bysignal);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.child_type == CHILD_TYPE_AOF) &#123;</span><br><span class="line">                backgroundRewriteDoneHandler(exitcode, bysignal);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.child_type == CHILD_TYPE_MODULE) &#123;</span><br><span class="line">                ModuleForkDoneHandler(exitcode, bysignal);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                serverPanic(<span class="string">&quot;Unknown child type %d for child pid %d&quot;</span>, server.child_type, server.child_pid);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!bysignal &amp;&amp; exitcode == <span class="number">0</span>) receiveChildInfo();</span><br><span class="line">            resetChildState();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ldbRemoveChild(pid)) &#123;</span><br><span class="line">                serverLog(LL_WARNING,</span><br><span class="line">                          <span class="string">&quot;Warning, detected child with unmatched pid: %ld&quot;</span>,</span><br><span class="line">                          (<span class="type">long</span>) pid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* start any pending forks immediately. */</span></span><br><span class="line">        replicationStartPendingFork();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RDB-快照-多进程"><a href="#RDB-快照-多进程" class="headerlink" title="RDB 快照 (多进程)"></a>RDB 快照 (多进程)</h2><p>当使用 <code>bgsaveCommand</code> 命令时，类似 <code>AOF重写</code> ，也是通过 <code>fork</code> 子进程去完成，避免加锁或是减少内存拷贝。当然其也支持自动触发。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If there is not a background saving/rewrite in progress check if</span></span><br><span class="line"><span class="comment">* we have to save/rewrite now. */</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.saveparamslen; j++) &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> *<span class="title">sp</span> =</span> server.saveparams+j;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Save if we reached the given amount of changes,</span></span><br><span class="line"><span class="comment">	* the given amount of seconds, and if the latest bgsave was</span></span><br><span class="line"><span class="comment">	* successful or if, in case of an error, at least</span></span><br><span class="line"><span class="comment">	* CONFIG_BGSAVE_RETRY_DELAY seconds already elapsed. */</span></span><br><span class="line">	<span class="keyword">if</span> (server.dirty &gt;= sp-&gt;changes &amp;&amp;</span><br><span class="line">		server.unixtime-server.lastsave &gt; sp-&gt;seconds &amp;&amp;</span><br><span class="line">		(server.unixtime-server.lastbgsave_try &gt;</span><br><span class="line">		CONFIG_BGSAVE_RETRY_DELAY ||</span><br><span class="line">		server.lastbgsave_status == C_OK))</span><br><span class="line">	&#123;</span><br><span class="line">		serverLog(LL_NOTICE,<span class="string">&quot;%d changes in %d seconds. Saving...&quot;</span>,</span><br><span class="line">			sp-&gt;changes, (<span class="type">int</span>)sp-&gt;seconds);</span><br><span class="line">		rdbSaveInfo rsi, *rsiptr;</span><br><span class="line">		rsiptr = rdbPopulateSaveInfo(&amp;rsi);</span><br><span class="line">		rdbSaveBackground(server.rdb_filename,rsiptr);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个检查点，查看是否触发存盘。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rdbSaveBackground</span><span class="params">(<span class="type">char</span> *filename, rdbSaveInfo *rsi)</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> childpid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasActiveChildProcess()) <span class="keyword">return</span> C_ERR;</span><br><span class="line"></span><br><span class="line">    server.dirty_before_bgsave = server.dirty;</span><br><span class="line">    server.lastbgsave_try = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((childpid = redisFork(CHILD_TYPE_RDB)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Child */</span></span><br><span class="line">        redisSetProcTitle(<span class="string">&quot;redis-rdb-bgsave&quot;</span>);</span><br><span class="line">        redisSetCpuAffinity(server.bgsave_cpulist);</span><br><span class="line">        retval = rdbSave(filename,rsi);</span><br><span class="line">        <span class="keyword">if</span> (retval == C_OK) &#123;</span><br><span class="line">            sendChildCowInfo(CHILD_INFO_TYPE_RDB_COW_SIZE, <span class="string">&quot;RDB&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        exitFromChild((retval == C_OK) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Parent */</span></span><br><span class="line">        <span class="keyword">if</span> (childpid == <span class="number">-1</span>) &#123;</span><br><span class="line">            server.lastbgsave_status = C_ERR;</span><br><span class="line">            serverLog(LL_WARNING,<span class="string">&quot;Can&#x27;t save in background: fork: %s&quot;</span>,</span><br><span class="line">                strerror(errno));</span><br><span class="line">            <span class="keyword">return</span> C_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">&quot;Background saving started by pid %ld&quot;</span>,(<span class="type">long</span>) childpid);</span><br><span class="line">        server.rdb_save_time_start = time(<span class="literal">NULL</span>);</span><br><span class="line">        server.rdb_child_type = RDB_CHILD_TYPE_DISK;</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C_OK; <span class="comment">/* unreached */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于 <code>RDB快照</code> 传送，也是采用子进程生成，父进程发送，若采用无盘传输，则子进程直接序列化后通过管道发给父进程，父进程再发给从服务器，下一篇会比较详细讨论，这里就不细说了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Redis</code> 除了命令执行是单线程，其他的网络和耗时操作尽可能都转化为 多进程或多线程，简化了开发，这一点在游戏服务器上是非常值得借鉴的。</p><p>此外， <code>Redis</code> 通过子线程释放内存，这一点我认为可以将其引用到 <code>Lua</code> 的垃圾回收中，缩短 <code>stop the world</code> 的时间，找个时间，写个多线程垃圾回收的版本，看看其效果。<a target="_blank" rel="noopener" href="https://github.com/Yu2erer/LuaJIT-5.3.6">LuaJIT-5.3.6</a>(更新时间 2021年07月04日，已实现 Lua 多线程垃圾回收版本)</p></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Redis/" rel="tag"># Redis</a></div><div class="post-nav"><div class="post-nav-item"><a href="/Raft-%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90/" rel="prev" title="Raft 共识算法解析"><i class="fa fa-angle-left"></i> Raft 共识算法解析</a></div><div class="post-nav-item"><a href="/Redis-6-%E5%89%96%E6%9E%90(%E4%BA%8C)-%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/" rel="next" title="Redis 6 剖析(二) 主从同步">Redis 6 剖析(二) 主从同步 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Yuerer</span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://unpkg.com/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://unpkg.com/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/comments.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/utils.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/motion.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/sidebar.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/next-boot.min.js"></script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://yuerer-comment-xufei-0bea01e6f05-1307930306.ap-shanghai.app.tcloudbase.com","cssUrl":"https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.css","commentCount":true,"pageview":true,"libUrl":"https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.js","locale":{"placeholder":"有何高见？"},"emoji":["https://unpkg.com/@waline/emojis@1.0.1/qq"],"meta":["nick","mail"],"requiredMeta":[["nick","mail"]],"wordLimit":0,"login":"disable","pageSize":10,"el":"#waline","comment":true,"path":"/Redis-6-%E5%89%96%E6%9E%90(%E4%B8%80)-%E5%BC%82%E6%AD%A5%E6%9C%BA%E5%88%B6/"}</script><link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.css"><script>document.addEventListener("page:loaded",()=>{NexT.utils.loadComments(CONFIG.waline.el).then(()=>NexT.utils.getScript(CONFIG.waline.libUrl,{condition:window.Waline})).then(()=>Waline.init(Object.assign({},CONFIG.waline,{el:document.querySelector(CONFIG.waline.el)})))})</script></body></html>