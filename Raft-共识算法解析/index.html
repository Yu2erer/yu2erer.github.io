<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.jpeg"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.ico"><link rel="mask-icon" href="/images/avatar.jpeg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous"><link rel="stylesheet" href="https://unpkg.com/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"yuerer.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"hide","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":true,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/config.min.js"></script><meta name="description" content="前篇解析了 Gossip 协议，这篇主要看看 Raft 是如何实现的。 本文主要分为两个部分，首先是粗略讲解一遍 Raft 的设计思想，在这一部分不会将 RPC 的各种字段（因为没有意义，只会徒增心智负担），而在第二部分则是通过解析一份优质的 Raft 源码实现，在这个部分再深入到 RPC 各个字段。 如果看了一遍看不懂也没关系，建议多去看看 Raft 的论文，笔者也是反复看了两周才大致理解其指导"><meta property="og:type" content="article"><meta property="og:title" content="Raft 共识算法解析"><meta property="og:url" content="https://yuerer.com/Raft-%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90/index.html"><meta property="og:site_name" content="Yuerer&#39;s Blog"><meta property="og:description" content="前篇解析了 Gossip 协议，这篇主要看看 Raft 是如何实现的。 本文主要分为两个部分，首先是粗略讲解一遍 Raft 的设计思想，在这一部分不会将 RPC 的各种字段（因为没有意义，只会徒增心智负担），而在第二部分则是通过解析一份优质的 Raft 源码实现，在这个部分再深入到 RPC 各个字段。 如果看了一遍看不懂也没关系，建议多去看看 Raft 的论文，笔者也是反复看了两周才大致理解其指导"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2021-03-14T02:01:20.000Z"><meta property="article:modified_time" content="2025-10-21T13:50:52.259Z"><meta property="article:author" content="Yuerer"><meta property="article:tag" content="分布式"><meta property="article:tag" content="raft"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://yuerer.com/Raft-%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://yuerer.com/Raft-%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90/","path":"Raft-共识算法解析/","title":"Raft 共识算法解析"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Raft 共识算法解析 | Yuerer's Blog</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-129491388-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-129491388-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/third-party/analytics/google-analytics.min.js"></script><link rel="dns-prefetch" href="https://yuerer-comment-xufei-0bea01e6f05-1307930306.ap-shanghai.app.tcloudbase.com"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Yuerer's Blog</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">钰儿的Blog</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Raft"><span class="nav-text">Raft</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D%E8%A7%92%E8%89%B2"><span class="nav-text">三种角色</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%86%E5%AF%BC%E4%BA%BA-Leader"><span class="nav-text">领导人 Leader</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%80%99%E9%80%89%E4%BA%BA-Candidate"><span class="nav-text">候选人 Candidate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%9F%E9%9A%8F%E8%80%85-Follower"><span class="nav-text">跟随者 Follower</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%86%E5%AF%BC%E9%80%89%E4%B8%BE"><span class="nav-text">领导选举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6"><span class="nav-text">日志复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E5%8F%98%E5%8C%96"><span class="nav-text">集群变化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hashicorp-raft-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="nav-text">hashicorp&#x2F;raft 源码解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%A0%E4%B8%AA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">几个数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NewRaft"><span class="nav-text">NewRaft</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#run"><span class="nav-text">run</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#runFollower"><span class="nav-text">runFollower</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#runCandidate"><span class="nav-text">runCandidate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#runLeader"><span class="nav-text">runLeader</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E6%94%B9%E8%BF%9B"><span class="nav-text">一些改进</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Yuerer" src="/images/avatar.jpeg"><p class="site-author-name" itemprop="name">Yuerer</p><div class="site-description" itemprop="description">钰儿的Blog</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">65</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">16</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">90</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/Yu2erer" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Yu2erer" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:yu2erer#gmail.com" title="E-Mail → mailto:yu2erer#gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://yuerer.com/Raft-%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpeg"><meta itemprop="name" content="Yuerer"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Yuerer's Blog"><meta itemprop="description" content="钰儿的Blog"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Raft 共识算法解析 | Yuerer's Blog"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Raft 共识算法解析</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-03-14 10:01:20" itemprop="dateCreated datePublished" datetime="2021-03-14T10:01:20+08:00">2021-03-14</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a> </span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Waline：</span> <a title="waline" href="/Raft-%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/Raft-%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90/" itemprop="commentCount"></span> </a></span><span class="post-meta-item" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="waline-pageview-count" data-path="/Raft-%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90/"></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>前篇解析了 <code>Gossip</code> 协议，这篇主要看看 <code>Raft</code> 是如何实现的。</p><p>本文主要分为两个部分，首先是粗略讲解一遍 <code>Raft</code> 的设计思想，在这一部分不会将 <code>RPC</code> 的各种字段（因为没有意义，只会徒增心智负担），而在第二部分则是通过解析一份优质的 <code>Raft</code> 源码实现，在这个部分再深入到 <code>RPC</code> 各个字段。</p><p>如果看了一遍看不懂也没关系，建议多去看看 <code>Raft</code> 的论文，笔者也是反复看了两周才大致理解其指导思想。</p><h2 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h2><p>一提到共识算法，相信大部分人都能马上想到 <code>Paxos</code>，但是我认为它不是算法，它的论文里面顶多算是一个指导思想，很少有人能够读完它就实现出一个可靠的共识算法（关键是要验证其的正确性），但是 <code>Raft</code> 不一样，它的一些设计非常巧妙，能够令人非常好的理解其指导思想，同时比较容易的实现（因为 <code>Raft</code> 从诞生那一刻就是为了弥补 <code>Paxos</code> 的可理解性，看看人家的论文名字 <code>In Search of an Understandable Consensus Algorithm</code> 可理解的分布式共识算法）。</p><p>用过 <code>Zookeeper</code> 的可能知道其内部的协议就是根据 <code>Paxos</code> 的指导实现的一个 <code>Zab</code> 算法，之所以不用 <code>Raft</code> 是因为 <code>Raft</code> 那时候还没出世呢。</p><span id="more"></span><h3 id="三种角色"><a href="#三种角色" class="headerlink" title="三种角色"></a>三种角色</h3><p>Raft 中的节点只有三种类型。</p><ul><li>领导人，Leader</li><li>候选人，Candidate</li><li>跟随者，Follower</li></ul><h3 id="领导人-Leader"><a href="#领导人-Leader" class="headerlink" title="领导人 Leader"></a>领导人 Leader</h3><p>领导人主要是负责一切的写入操作，当领导人收到客户端的日志条目（请求）时，将其先记录下来（你可以理解为拿个小本本记下我收到了这个请求，但是不提交），然后广播复制（通过心跳）到其他的服务器上，当收到大多数服务器成功的响应后，就将其提交(Commit)到自身的状态机（这个时候才是真正的应用于kv存储），最后通过心跳广播到所有服务器，告诉他们你们也可以应用。</p><h3 id="候选人-Candidate"><a href="#候选人-Candidate" class="headerlink" title="候选人 Candidate"></a>候选人 Candidate</h3><p>如果领导人宕机了，这个时候就需要有候选人竞选领导，谁先收获到足够多的选票，谁就胜出。</p><h3 id="跟随者-Follower"><a href="#跟随者-Follower" class="headerlink" title="跟随者 Follower"></a>跟随者 Follower</h3><p>当领导人还在的时候，整个分布式只会有领导人和跟随者，他们之间通过心跳维持，当领导者宕机了，跟随者就会跳出来说我来当候选人，于是就切换到候选人的身份了。</p><h3 id="领导选举"><a href="#领导选举" class="headerlink" title="领导选举"></a>领导选举</h3><p><code>Raft</code> 和 <code>Paxos</code> 最大的异同点我认为是引入了 强领导 的机制，因为这会使得整个分布式系统变得简单，多领导的机制简直就是灾难，你很难保证整个系统指令的顺序。</p><p>初始阶段，所有的节点都应该是跟随者，因为这个时候没有领导者与其维持心跳，因此会有一个跟随者发生心跳超时的情况，谁先超时，谁就变身成候选人，之所以有个先字，主要是因为 <code>Raft</code> 设计心跳超时的时候，采用了一种随机超时的机制，这个机制我个人觉得是非常巧妙地，它大幅度的减少了整个系统的复杂度，不再需要优先级各种系统的设计，直接通过随机的形式，也避免了瓜分选票导致长时间不能服务的问题。</p><p>有了候选人之后，先给自己来一票，然后发起 <code>RequestVote</code> ，当选票足够的时候就进化为领导人，如果一直没选出来则进入选举超时，重来一轮，如果收到领导者的消息，则对比 <code>Term</code> 任期，比候选人大则乖乖退回跟随者，小则无视。</p><p>决定投不投它一票的流程也很简单，采用 <code>FIFO</code> 先来先服务的形式，大前提是候选人的信息要比我的新。</p><p>关于这块如果不能理解，建议看 <a target="_blank" rel="noopener" href="http://thesecretlivesofdata.com/raft/">thesecretlivesofdata</a> 这里的动画演示。</p><h3 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h3><p>首先要认识日志，日志由三部分组成，日志于哪个任期产生，日志的索引，日志的内容。</p><p>领导人收到客户端的请求之后，将请求组装成日志，然后先存储下来（不是应用，只是记录一下），接着通过广播发给其他节点，当大多数节点成功响应，则应用到自身的kv存储（或者说应用于自身的状态机），这个时候就可以返回了，同时心跳广播也会将最新的提交记录传递给所有节点，其他节点也会将其应用于自身，这里面的提前返回相当于是将二阶段提交给优化为了一阶段（因为它只要大多数节点回应就行了），降低了一半的消息延迟。</p><p>如果是跟随者收到客户端的写请求则有多种方法，比如拒绝并返回领导者的地址给客户端，或转发给领导者，将领导者的返回结果返回给客户端，充当代理身份。</p><p>为什么我只提到了写请求呢？因为读请求也是需要视情况而定的，我们知道 <code>Raft</code> 是一个共识算法，很多人一直以为它实现出来的就一定是强一致性，然而它是不是强一致性取决于你客户端怎么实现。比如说你想要强一致性，则强制读的时候一定在领导者上读，同时要经过半数节点确认，这样一定不会返回旧数据。如果无所谓强一致性，则可以设计成任意节点上读，这样很有可能是旧数据。还有一种模式是虽然在领导者身上读，但是不经过大多数节点的确认就直接返回，这样有可能会有旧数据（比如 新的 <del>风暴</del>（领导者） 已经出现，但是因为网络的关系，没能通过心跳广播通知到其退位，它觉得它还是个领导者就擅自返回了数据，殊不知这个数据很有可能被新的领导者已经修改了）。</p><p>以上的三种读操作的一致性模型其实就是 <code>Consul</code> 所实现的。</p><p>这么一看， <code>Raft</code> 的缺点很明显，因为强领导者导致写性能很弱，相当于单机，这也是为什么在分布式存储领域中，大多采用分片的形式去使用（相当于多个 <code>Raft</code> 组），而不是采用大分布式的形式。</p><p>日志复制的<code>安全性</code>来自于几个方面。</p><p>首先<code>领导者</code>不能删除和覆盖日志，只能够新增，如果跟随者和领导者不一致则强制让跟随者的日志与领导者同步。这么做之所以是安全的是因为，领导者的日志一定是最新最全的。</p><p>如何保证领导者的日志一定是最新的呢？前面也提到了 日志由 <code>Term</code> 任期， <code>index</code> 日志索引，日志内容所构成，每次复制都会去检查前一个日志的任期和索引是否相同，如果相同，我们则可以断定前面的日志也一定是相同的。</p><p>其次如果领导者复制给了跟随者日志，但是随后就宕机了，这个时候没有应用于状态机，怎么办？这个时候就依赖于 <code>Term</code> 任期字段，新的领导者首先通过上面的机制保证了它的日志一定是最全的，同时它的任期一定是更高的，于是就可以将其任期之前的未提交的直接提交了，然后同步给其他节点。再加上 <code>Raft</code> 整个系统实现是幂等性的，即使因为超时或者种种原因重新执行指令也不会发生任何副作用。</p><p>那么可能有的人就会想，日志一直在增加，我总不能一直存着所有的日志来和其他跟随者进行比对吧？论文里面的 <code>Snapshot</code> 就是做这块功能，将日志进行快照压缩，其实和 <code>Redis</code> aof重写挺像的，然后将快照同步出去即可。</p><p>关于日志复制，如果有疑惑的可以参阅 <a target="_blank" rel="noopener" href="https://raft.github.io/">Raft Visualization</a> 一个非常详细的动画演示。</p><h3 id="集群变化"><a href="#集群变化" class="headerlink" title="集群变化"></a>集群变化</h3><p><code>Raft</code> 通过单节点变更，避免了集群变化时出现的脑裂情况，每次只添加单个节点不会形成另一个大多数，从而避免多个领导者。除了单节点变更还可以用 <code>联合共识</code> （其实就是个二阶段的规则，集群之间互相试探），但是难实现啊。</p><h2 id="hashicorp-raft-源码解析"><a href="#hashicorp-raft-源码解析" class="headerlink" title="hashicorp&#x2F;raft 源码解析"></a>hashicorp&#x2F;raft 源码解析</h2><p>有了以上的前置知识，我们就可以通过阅读知名的 <a target="_blank" rel="noopener" href="https://github.com/hashicorp/raft">hashicorp&#x2F;raft</a> 实现来更深入的理解 <code>Raft</code>。</p><h3 id="几个数据结构"><a href="#几个数据结构" class="headerlink" title="几个数据结构"></a>几个数据结构</h3><p><code>RaftState</code> 是 <code>Raft</code> 当前所处的状态，如上所说有三种状态。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RaftState <span class="type">uint32</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// Follower is the initial state of a Raft node.</span></span><br><span class="line">	Follower RaftState = <span class="literal">iota</span></span><br><span class="line">	<span class="comment">// Candidate is one of the valid states of a Raft node.</span></span><br><span class="line">	Candidate</span><br><span class="line">	<span class="comment">// Leader is one of the valid states of a Raft node.</span></span><br><span class="line">	Leader</span><br><span class="line">	<span class="comment">// Shutdown is the terminal state of a Raft node.</span></span><br><span class="line">	Shutdown <span class="comment">// 关闭状态</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>raftState</code> 则代表 <code>Raft</code> 节点信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> raftState <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// The current term, cache of StableStore</span></span><br><span class="line">	currentTerm <span class="type">uint64</span> <span class="comment">// 当前任期</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Highest committed log entry</span></span><br><span class="line">	commitIndex <span class="type">uint64</span> <span class="comment">// 最高提交的日志索引</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Last applied log to the FSM</span></span><br><span class="line">	lastApplied <span class="type">uint64</span> <span class="comment">// 最后一条应用到状态机的索引</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Cache the latest snapshot index/term</span></span><br><span class="line">	lastSnapshotIndex <span class="type">uint64</span> <span class="comment">// 快照索引</span></span><br><span class="line">	lastSnapshotTerm  <span class="type">uint64</span> <span class="comment">// 快照任期</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Cache the latest log from LogStore</span></span><br><span class="line">	lastLogIndex <span class="type">uint64</span> <span class="comment">// 最后一条索引</span></span><br><span class="line">	lastLogTerm  <span class="type">uint64</span> <span class="comment">// 最后一条日志任期</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// The current state</span></span><br><span class="line">	state RaftState <span class="comment">// 节点状态，前面的三态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>附加日志 RPC 请求，这里可以对照着论文看了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AppendEntriesRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">	RPCHeader <span class="comment">// 协议版本</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Provide the current term and leader</span></span><br><span class="line">	Term   <span class="type">uint64</span> <span class="comment">// 任期</span></span><br><span class="line">	Leader []<span class="type">byte</span> <span class="comment">// 领导者信息</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Provide the previous entries for integrity checking</span></span><br><span class="line">	PrevLogEntry <span class="type">uint64</span> <span class="comment">// 前一个日志的索引</span></span><br><span class="line">	PrevLogTerm  <span class="type">uint64</span> <span class="comment">// 前一个日志的任期</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// New entries to commit</span></span><br><span class="line">	Entries []*Log <span class="comment">// 新的日志</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Commit index on the leader</span></span><br><span class="line">	LeaderCommitIndex <span class="type">uint64</span> <span class="comment">// 已提交的最大编号，心跳带出，让跟随者也附加</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>附加日志 RPC 响应。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AppendEntriesResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">	RPCHeader</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Newer term if leader is out of date</span></span><br><span class="line">	Term <span class="type">uint64</span> <span class="comment">// 当前任期</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Last Log is a hint to help accelerate rebuilding slow nodes</span></span><br><span class="line">	LastLog <span class="type">uint64</span> <span class="comment">// 最后一条日志索引 用于快速找到缺失的日志（论文里没有）</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// We may not succeed if we have a conflicting entry</span></span><br><span class="line">	Success <span class="type">bool</span> <span class="comment">// 是否成功 如果不匹配就不成功</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// There are scenarios where this request didn&#x27;t succeed</span></span><br><span class="line">	<span class="comment">// but there&#x27;s no need to wait/back-off the next attempt.</span></span><br><span class="line">	NoRetryBackoff <span class="type">bool</span> <span class="comment">// 是否不等待直接重试，论文没有 属于扩充项 加速用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>投票 RPC 请求。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RequestVoteRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">	RPCHeader</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Provide the term and our id</span></span><br><span class="line">	Term      <span class="type">uint64</span> <span class="comment">// 任期</span></span><br><span class="line">	Candidate []<span class="type">byte</span> <span class="comment">// 候选人信息</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Used to ensure safety</span></span><br><span class="line">	LastLogIndex <span class="type">uint64</span> <span class="comment">// 最后一条日志索引</span></span><br><span class="line">	LastLogTerm  <span class="type">uint64</span> <span class="comment">// 最后一条日志任期</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Used to indicate to peers if this vote was triggered by a leadership</span></span><br><span class="line">	<span class="comment">// transfer. It is required for leadership transfer to work, because servers</span></span><br><span class="line">	<span class="comment">// wouldn&#x27;t vote otherwise if they are aware of an existing leader.</span></span><br><span class="line">	LeadershipTransfer <span class="type">bool</span> <span class="comment">// hashicorp 实现的一种主动转移领导的快速项，论文没有</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>投票 RPC 响应。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RequestVoteResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">	RPCHeader</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Newer term if leader is out of date.</span></span><br><span class="line">	Term <span class="type">uint64</span> <span class="comment">// 任期</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Is the vote granted.</span></span><br><span class="line">	Granted <span class="type">bool</span> <span class="comment">// 投我吗</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>安装快照 RPC 请求。</p><p>快照主要是当 日志项太多的时候，将其合并成一个快照复制。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> InstallSnapshotRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">	RPCHeader</span><br><span class="line">	SnapshotVersion SnapshotVersion <span class="comment">// 快照版本 扩展</span></span><br><span class="line"></span><br><span class="line">	Term   <span class="type">uint64</span> <span class="comment">// 任期</span></span><br><span class="line">	Leader []<span class="type">byte</span> <span class="comment">// 领导信息</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// These are the last index/term included in the snapshot</span></span><br><span class="line">	LastLogIndex <span class="type">uint64</span> <span class="comment">// 快照中最后一条日志索引</span></span><br><span class="line">	LastLogTerm  <span class="type">uint64</span> <span class="comment">// 快照中最后一条日志任期</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Cluster membership.</span></span><br><span class="line">	Configuration []<span class="type">byte</span> <span class="comment">// 配置</span></span><br><span class="line">	<span class="comment">// Log index where &#x27;Configuration&#x27; entry was originally written.</span></span><br><span class="line">	ConfigurationIndex <span class="type">uint64</span> <span class="comment">// 配置项索引</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Size of the snapshot</span></span><br><span class="line">	Size <span class="type">int64</span> <span class="comment">// 大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>安装快照 RPC 响应。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> InstallSnapshotResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">	RPCHeader</span><br><span class="line"></span><br><span class="line">	Term    <span class="type">uint64</span> <span class="comment">// 任期</span></span><br><span class="line">	Success <span class="type">bool</span> <span class="comment">// 是否成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NewRaft"><a href="#NewRaft" class="headerlink" title="NewRaft"></a>NewRaft</h3><p>这里就是创建一个 <code>Raft</code> 节点的方法，其实就是验证一下配置，初始化日志，从db中拿出旧的数据（如果有），默认是一个 <code>Follower</code> 的状态，就开着三个协程去跑了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRaft</span><span class="params">(conf *Config, fsm FSM, logs LogStore, stable StableStore, snaps SnapshotStore, trans Transport)</span></span> (*Raft, <span class="type">error</span>) &#123;</span><br><span class="line">	....</span><br><span class="line">	<span class="comment">// Initialize as a follower.</span></span><br><span class="line">	r.setState(Follower)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Start as leader if specified. This should only be used</span></span><br><span class="line">	<span class="comment">// for testing purposes.</span></span><br><span class="line">	<span class="keyword">if</span> conf.StartAsLeader &#123;</span><br><span class="line">		r.setState(Leader)</span><br><span class="line">		r.setLeader(r.localAddr)</span><br><span class="line">	&#125;</span><br><span class="line">	....</span><br><span class="line">	<span class="comment">// Start the background work.</span></span><br><span class="line">	r.goFunc(r.run)</span><br><span class="line">	r.goFunc(r.runFSM)</span><br><span class="line">	r.goFunc(r.runSnapshots)</span><br><span class="line">	<span class="keyword">return</span> r, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下围绕着三个协程去讨论。</p><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><p>协程 <code>run</code> 则根据节点状态跑相应的函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span></span> run() &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// Check if we are doing a shutdown</span></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-r.shutdownCh:</span><br><span class="line">			<span class="comment">// Clear the leader to prevent forwarding</span></span><br><span class="line">			r.setLeader(<span class="string">&quot;&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Enter into a sub-FSM</span></span><br><span class="line">		<span class="keyword">switch</span> r.getState() &#123;</span><br><span class="line">		<span class="keyword">case</span> Follower:</span><br><span class="line">			r.runFollower()</span><br><span class="line">		<span class="keyword">case</span> Candidate:</span><br><span class="line">			r.runCandidate()</span><br><span class="line">		<span class="keyword">case</span> Leader:</span><br><span class="line">			r.runLeader()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="runFollower"><a href="#runFollower" class="headerlink" title="runFollower"></a>runFollower</h3><p>跟随者下接收RPC请求，这里有一个 <code>bootstrapCh</code>，用于启动时接收集群信息。</p><p>除了接收附加日志，投票，安装快照请求，其他请求都不支持（代码已省略）。</p><p>心跳超时之后会变为候选者，即 <code>Candidate</code> 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span></span> runFollower() &#123;</span><br><span class="line">	heartbeatTimer := randomTimeout(r.conf.HeartbeatTimeout)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> r.getState() == Follower &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> rpc := &lt;-r.rpcCh:</span><br><span class="line">			r.processRPC(rpc)</span><br><span class="line"></span><br><span class="line">		....</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> b := &lt;-r.bootstrapCh:</span><br><span class="line">			b.respond(r.liveBootstrap(b.configuration))</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> &lt;-heartbeatTimer:</span><br><span class="line">			<span class="comment">// Restart the heartbeat timer</span></span><br><span class="line">			heartbeatTimer = randomTimeout(r.conf.HeartbeatTimeout)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Check if we have had a successful contact</span></span><br><span class="line">			lastContact := r.LastContact()</span><br><span class="line">			<span class="keyword">if</span> time.Now().Sub(lastContact) &lt; r.conf.HeartbeatTimeout &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Heartbeat failed! Transition to the candidate state</span></span><br><span class="line">			lastLeader := r.Leader()</span><br><span class="line">			r.setLeader(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> r.configurations.latestIndex == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> !didWarn &#123;</span><br><span class="line">					r.logger.Warn(<span class="string">&quot;no known peers, aborting election&quot;</span>)</span><br><span class="line">					didWarn = <span class="literal">true</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> r.configurations.latestIndex == r.configurations.committedIndex &amp;&amp;</span><br><span class="line">				!hasVote(r.configurations.latest, r.localID) &#123;</span><br><span class="line">				<span class="keyword">if</span> !didWarn &#123;</span><br><span class="line">					r.logger.Warn(<span class="string">&quot;not part of stable configuration, aborting election&quot;</span>)</span><br><span class="line">					didWarn = <span class="literal">true</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				r.logger.Warn(fmt.Sprintf(<span class="string">&quot;Heartbeat timeout from %q reached, starting election&quot;</span>, lastLeader))</span><br><span class="line">				r.setState(Candidate)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> &lt;-r.shutdownCh:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="runCandidate"><a href="#runCandidate" class="headerlink" title="runCandidate"></a>runCandidate</h3><p>候选人默认先给自己来上一票，然后就到处要票，视情况决定是退回到跟随者，还是当上领导者。</p><p>除了日志和投票的请求，其他都是直接返回错误，选举超时则退回到跟随者，等待新一轮选举。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span></span> runCandidate() &#123;</span><br><span class="line">	<span class="comment">// Start vote for us, and set a timeout</span></span><br><span class="line">	voteCh := r.electSelf()</span><br><span class="line">	....</span><br><span class="line">	electionTimer := randomTimeout(r.conf.ElectionTimeout)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Tally the votes, need a simple majority</span></span><br><span class="line">	grantedVotes := <span class="number">0</span></span><br><span class="line">	votesNeeded := r.quorumSize()</span><br><span class="line">	r.logger.Debug(fmt.Sprintf(<span class="string">&quot;Votes needed: %d&quot;</span>, votesNeeded))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> r.getState() == Candidate &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> rpc := &lt;-r.rpcCh:</span><br><span class="line">			r.processRPC(rpc)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> vote := &lt;-voteCh:</span><br><span class="line">			<span class="comment">// Check if the term is greater than ours, bail</span></span><br><span class="line">			<span class="keyword">if</span> vote.Term &gt; r.getCurrentTerm() &#123;</span><br><span class="line">				r.logger.Debug(<span class="string">&quot;Newer term discovered, fallback to follower&quot;</span>)</span><br><span class="line">				r.setState(Follower)</span><br><span class="line">				r.setCurrentTerm(vote.Term)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Check if the vote is granted</span></span><br><span class="line">			<span class="keyword">if</span> vote.Granted &#123;</span><br><span class="line">				grantedVotes++</span><br><span class="line">				r.logger.Debug(fmt.Sprintf(<span class="string">&quot;Vote granted from %s in term %v. Tally: %d&quot;</span>,</span><br><span class="line">					vote.voterID, vote.Term, grantedVotes))</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Check if we&#x27;ve become the leader</span></span><br><span class="line">			<span class="keyword">if</span> grantedVotes &gt;= votesNeeded &#123;</span><br><span class="line">				r.logger.Info(fmt.Sprintf(<span class="string">&quot;Election won. Tally: %d&quot;</span>, grantedVotes))</span><br><span class="line">				r.setState(Leader)</span><br><span class="line">				r.setLeader(r.localAddr)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> c := &lt;-r.configurationChangeCh:</span><br><span class="line">			<span class="comment">// Reject any operations since we are not the leader</span></span><br><span class="line">			c.respond(ErrNotLeader)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> a := &lt;-r.applyCh:</span><br><span class="line">			<span class="comment">// Reject any operations since we are not the leader</span></span><br><span class="line">			a.respond(ErrNotLeader)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> v := &lt;-r.verifyCh:</span><br><span class="line">			<span class="comment">// Reject any operations since we are not the leader</span></span><br><span class="line">			v.respond(ErrNotLeader)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> r := &lt;-r.userRestoreCh:</span><br><span class="line">			<span class="comment">// Reject any restores since we are not the leader</span></span><br><span class="line">			r.respond(ErrNotLeader)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> c := &lt;-r.configurationsCh:</span><br><span class="line">			c.configurations = r.configurations.Clone()</span><br><span class="line">			c.respond(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> b := &lt;-r.bootstrapCh:</span><br><span class="line">			b.respond(ErrCantBootstrap)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> &lt;-electionTimer:</span><br><span class="line">			<span class="comment">// Election failed! Restart the election. We simply return,</span></span><br><span class="line">			<span class="comment">// which will kick us back into runCandidate</span></span><br><span class="line">			r.logger.Warn(<span class="string">&quot;Election timeout reached, restarting election&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> &lt;-r.shutdownCh:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="runLeader"><a href="#runLeader" class="headerlink" title="runLeader"></a>runLeader</h3><p>领导者主要是初始化多个拷贝协程，然后新建一个 <code>noop</code> 的日志项（就是不应用到状态机的日志），非常重要，相当于领导者一当选就马上告诉其他跟随者你们给我把之前任期未提交的日志给我提交了（隐式提交）。</p><p><code>noop</code> 日志相当于一条分界线，只有其他节点同步到了这个日志，才正式提供服务，避免客户端从其他节点读到未 <code>Commit</code> 的数据（过时数据）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span></span> runLeader() &#123;</span><br><span class="line">	....</span><br><span class="line">	<span class="comment">// setup leader state. This is only supposed to be accessed within the</span></span><br><span class="line">	<span class="comment">// leaderloop.</span></span><br><span class="line">	r.setupLeaderState()</span><br><span class="line">	....</span><br><span class="line">	<span class="comment">// Start a replication routine for each peer</span></span><br><span class="line">	r.startStopReplication()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Dispatch a no-op log entry first. This gets this leader up to the latest</span></span><br><span class="line">	<span class="comment">// possible commit index, even in the absence of client commands. This used</span></span><br><span class="line">	<span class="comment">// to append a configuration entry instead of a noop. However, that permits</span></span><br><span class="line">	<span class="comment">// an unbounded number of uncommitted configurations in the log. We now</span></span><br><span class="line">	<span class="comment">// maintain that there exists at most one uncommitted configuration entry in</span></span><br><span class="line">	<span class="comment">// any log, so we have to do proper no-ops here.</span></span><br><span class="line">	noop := &amp;logFuture&#123;</span><br><span class="line">		log: Log&#123;</span><br><span class="line">			Type: LogNoop,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	r.dispatchLogs([]*logFuture&#123;noop&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Sit in the leader loop until we step down</span></span><br><span class="line">	r.leaderLoop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩余的 <code>RPC</code> 请求处理，就不继续解析了，无非就是根据当前身上的信息和心跳发来的信息进行比对。</p><h2 id="一些改进"><a href="#一些改进" class="headerlink" title="一些改进"></a>一些改进</h2><ol><li>流水线传输日志。</li><li>采用 <code>MultiRaft</code>， 因为 <code>Raft</code> 是强领导者类型的，性能相当于单点。</li><li>跟随者变为候选者之前先与集群中确认是否真的没有 <code>Leader</code> 这有助于避免在对称网络分区错误（三节点，两机房，两节点在同一个机房）的时候把一个明明有 <code>Leader</code> 的集群转换为选举状态。</li><li>非对称网络分区错误（三节点，三机房，都在不同的机房），导致一直重新选举，通过检查上次 <code>Leader</code> 到当前的通信时间是否超过重新选举的时间可避免这一问题。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Raft</code> 把 <code>超时</code> 玩出了花，通过引入超时机制（心跳超时选举领导，选举超时重新选举领导）把整个系统的复杂性降低，同时通过心跳来附加日志和提交日志，不需要等待完全确认，将 二阶段的提交过程优化为了一阶段。 <code>Leader</code> 上位后通过 <code>noop</code> 日志巧妙的避免了即日志不一致，旧读的问题。关于成员变更，则是采用单节点变更的形式，避免了 <code>脑裂</code>，不得不说 <code>Raft</code> 真的是把可理解这一特性发挥到了极致。</p></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag"># 分布式</a> <a href="/tags/raft/" rel="tag"># raft</a></div><div class="post-nav"><div class="post-nav-item"><a href="/Gossip-%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/" rel="prev" title="Gossip 协议解析"><i class="fa fa-angle-left"></i> Gossip 协议解析</a></div><div class="post-nav-item"><a href="/Redis-6-%E5%89%96%E6%9E%90(%E4%B8%80)-%E5%BC%82%E6%AD%A5%E6%9C%BA%E5%88%B6/" rel="next" title="Redis 6 剖析(一) 异步机制">Redis 6 剖析(一) 异步机制 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Yuerer</span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://unpkg.com/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://unpkg.com/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/comments.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/utils.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/motion.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/sidebar.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/next-boot.min.js"></script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://yuerer-comment-xufei-0bea01e6f05-1307930306.ap-shanghai.app.tcloudbase.com","cssUrl":"https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.css","commentCount":true,"pageview":true,"libUrl":"https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.js","locale":{"placeholder":"有何高见？"},"emoji":["https://unpkg.com/@waline/emojis@1.0.1/qq"],"meta":["nick","mail"],"requiredMeta":[["nick","mail"]],"wordLimit":0,"login":"disable","pageSize":10,"el":"#waline","comment":true,"path":"/Raft-%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90/"}</script><link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.css"><script>document.addEventListener("page:loaded",()=>{NexT.utils.loadComments(CONFIG.waline.el).then(()=>NexT.utils.getScript(CONFIG.waline.libUrl,{condition:window.Waline})).then(()=>Waline.init(Object.assign({},CONFIG.waline,{el:document.querySelector(CONFIG.waline.el)})))})</script></body></html>