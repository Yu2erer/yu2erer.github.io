<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.jpeg"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.ico"><link rel="mask-icon" href="/images/avatar.jpeg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous"><link rel="stylesheet" href="https://unpkg.com/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"yuerer.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"hide","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":true,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/config.min.js"></script><meta name="description" content="为什么需要虚拟存储?计算机系统常出现内存空间不够用 如何解决内存空间不够用? 覆盖(Overlay)  应用程序 手动 把需要的指令和数据保存在内存中 (将代码分成若干模块 彼此无调用关系的 将其附庸到一块区域 需要用户自己来确定何时将其模块加入程序 开发难度高)  交换(对换 Swapping)  操作系统 自动 把暂时不能执行的程序保存到外存中 (因为对换的是一个进程的整个地址空间 所以开销会"><meta property="og:type" content="article"><meta property="og:title" content="操作系统之 虚拟存储概念"><meta property="og:url" content="https://yuerer.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E6%A6%82%E5%BF%B5/index.html"><meta property="og:site_name" content="Yuerer&#39;s Blog"><meta property="og:description" content="为什么需要虚拟存储?计算机系统常出现内存空间不够用 如何解决内存空间不够用? 覆盖(Overlay)  应用程序 手动 把需要的指令和数据保存在内存中 (将代码分成若干模块 彼此无调用关系的 将其附庸到一块区域 需要用户自己来确定何时将其模块加入程序 开发难度高)  交换(对换 Swapping)  操作系统 自动 把暂时不能执行的程序保存到外存中 (因为对换的是一个进程的整个地址空间 所以开销会"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://yuerer.com/images/overlay.png"><meta property="og:image" content="https://yuerer.com/images/swapping.png"><meta property="og:image" content="https://yuerer.com/images/principleoflocality.png"><meta property="og:image" content="https://yuerer.com/images/logaddr2phyaddr0.png"><meta property="og:image" content="https://yuerer.com/images/X86pagetable.png"><meta property="og:image" content="https://yuerer.com/images/pagetableentries.png"><meta property="og:image" content="https://yuerer.com/images/pagefault.png"><meta property="article:published_time" content="2018-11-21T10:47:20.000Z"><meta property="article:modified_time" content="2025-10-21T13:50:52.276Z"><meta property="article:author" content="Yuerer"><meta property="article:tag" content="操作系统"><meta property="article:tag" content="虚拟存储"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://yuerer.com/images/overlay.png"><link rel="canonical" href="https://yuerer.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E6%A6%82%E5%BF%B5/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://yuerer.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E6%A6%82%E5%BF%B5/","path":"操作系统之-虚拟存储概念/","title":"操作系统之 虚拟存储概念"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>操作系统之 虚拟存储概念 | Yuerer's Blog</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-129491388-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-129491388-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/third-party/analytics/google-analytics.min.js"></script><link rel="dns-prefetch" href="https://yuerer-comment-xufei-0bea01e6f05-1307930306.ap-shanghai.app.tcloudbase.com"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Yuerer's Blog</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">钰儿的Blog</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8"><span class="nav-text">为什么需要虚拟存储?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E4%B8%8D%E5%A4%9F%E7%94%A8"><span class="nav-text">如何解决内存空间不够用?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%E5%92%8C%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF"><span class="nav-text">覆盖和交换技术</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF%E7%9B%AE%E6%A0%87"><span class="nav-text">覆盖技术目标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="nav-text">覆盖技术实现方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF%E7%9A%84%E4%B8%8D%E8%B6%B3"><span class="nav-text">覆盖技术的不足</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF%E7%9B%AE%E6%A0%87"><span class="nav-text">交换技术目标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="nav-text">交换技术实现方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="nav-text">交换技术有什么问题?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-text">覆盖与交换的比较</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86-Principle-of-locality"><span class="nav-text">局部性原理 (Principle of locality)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E7%A8%8B%E5%BA%8F%E7%BC%96%E5%86%99%E6%96%B9%E6%B3%95%E7%9A%84%E5%B1%80%E9%83%A8%E6%80%A7%E7%89%B9%E5%BE%81"><span class="nav-text">不同程序编写方法的局部性特征</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8"><span class="nav-text">虚拟存储</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="nav-text">虚拟存储的目标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E6%80%9D%E8%B7%AF"><span class="nav-text">虚拟存储思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-text">虚拟存储实现方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81"><span class="nav-text">虚拟存储基本特征</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E7%9A%84%E6%94%AF%E6%8C%81%E6%8A%80%E6%9C%AF"><span class="nav-text">虚拟存储的支持技术</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="nav-text">虚拟页式存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="nav-text">虚拟页式存储地址转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E9%A1%B5%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%BE%8B%E7%A8%8B"><span class="nav-text">缺页异常的处理例程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%AD%E7%9A%84%E5%A4%96%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-text">虚拟页式存储中的外存管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E6%80%A7%E8%83%BD"><span class="nav-text">虚拟页式存储管理的性能</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Yuerer" src="/images/avatar.jpeg"><p class="site-author-name" itemprop="name">Yuerer</p><div class="site-description" itemprop="description">钰儿的Blog</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">65</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">16</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">90</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/Yu2erer" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Yu2erer" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:yu2erer#gmail.com" title="E-Mail → mailto:yu2erer#gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://yuerer.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E6%A6%82%E5%BF%B5/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpeg"><meta itemprop="name" content="Yuerer"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Yuerer's Blog"><meta itemprop="description" content="钰儿的Blog"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="操作系统之 虚拟存储概念 | Yuerer's Blog"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">操作系统之 虚拟存储概念</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-11-21 18:47:20" itemprop="dateCreated datePublished" datetime="2018-11-21T18:47:20+08:00">2018-11-21</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a> </span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Waline：</span> <a title="waline" href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E6%A6%82%E5%BF%B5/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E6%A6%82%E5%BF%B5/" itemprop="commentCount"></span> </a></span><span class="post-meta-item" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="waline-pageview-count" data-path="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E6%A6%82%E5%BF%B5/"></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h3 id="为什么需要虚拟存储"><a href="#为什么需要虚拟存储" class="headerlink" title="为什么需要虚拟存储?"></a>为什么需要虚拟存储?</h3><p>计算机系统常出现内存空间不够用</p><h3 id="如何解决内存空间不够用"><a href="#如何解决内存空间不够用" class="headerlink" title="如何解决内存空间不够用?"></a>如何解决内存空间不够用?</h3><ul><li>覆盖(Overlay)</li></ul><p>应用程序 手动 把需要的指令和数据保存在内存中 (将代码分成若干模块 彼此无调用关系的 将其附庸到一块区域 需要用户自己来确定何时将其模块加入程序 开发难度高)</p><ul><li>交换(对换 Swapping)</li></ul><p>操作系统 自动 把暂时不能执行的程序保存到外存中 (因为对换的是一个进程的整个地址空间 所以开销会比较大)</p><ul><li>虚拟存储</li></ul><p>在有限容量的内存中 以页为单位自动装入更多更大的程序</p><span id="more"></span><h3 id="覆盖和交换技术"><a href="#覆盖和交换技术" class="headerlink" title="覆盖和交换技术"></a>覆盖和交换技术</h3><h4 id="覆盖技术目标"><a href="#覆盖技术目标" class="headerlink" title="覆盖技术目标"></a>覆盖技术目标</h4><p>在较小的可用内存中运行较大的程序 (一个程序的运行内存空间都不够)</p><h4 id="覆盖技术实现方法"><a href="#覆盖技术实现方法" class="headerlink" title="覆盖技术实现方法"></a>覆盖技术实现方法</h4><p>依据程序的逻辑结构 将程序模块划分为若干功能相对独立的模块<br>将不会同时执行的模块共享同一块内存区域</p><ul><li>必要部分(常用功能)的代码和数据常驻内存</li><li>可选部分(非常用功能)放在其他程序模块中 只在需要的时候装入内存</li><li>不存在调用关系的模块可相互覆盖 共用同一块内存区域</li></ul><p><img data-src="/images/overlay.png" alt="overlay"></p><h5 id="覆盖技术的不足"><a href="#覆盖技术的不足" class="headerlink" title="覆盖技术的不足"></a>覆盖技术的不足</h5><ul><li>增加编程难度<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需要程序员 划分功能模块 并确定模块间的覆盖关系</span><br></pre></td></tr></table></figure></li><li>增加执行时间<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从外存 装入覆盖 模块 时间换空间</span><br></pre></td></tr></table></figure></li></ul><h4 id="交换技术目标"><a href="#交换技术目标" class="headerlink" title="交换技术目标"></a>交换技术目标</h4><p>增加正在运行或需要运行的程序的内存 (一个程序的运行内存空间足够了 但是想要运行更多的进程)</p><h4 id="交换技术实现方法"><a href="#交换技术实现方法" class="headerlink" title="交换技术实现方法"></a>交换技术实现方法</h4><ul><li>将暂时不能运行的程序放到外存</li><li>换入换出基本单位 整个进程的地址空间</li><li>换出(Swap out) 把一个进程的整个地址空间保存到外存</li><li>换入(Swap in) 把外存中的某进程的地址空间读入到内存</li></ul><p><img data-src="/images/swapping.png" alt="swapping"></p><h4 id="交换技术有什么问题"><a href="#交换技术有什么问题" class="headerlink" title="交换技术有什么问题?"></a>交换技术有什么问题?</h4><ul><li>交换时机<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当内存不够 或 有不够的可能时换出</span><br></pre></td></tr></table></figure></li><li>交换区大小<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">存放所有用户进程的所有内存映像的拷贝</span><br></pre></td></tr></table></figure></li><li>程序换入时的重定位 换出时再换入时要放在原处吗?<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">采用动态地址映射的方法</span><br></pre></td></tr></table></figure></li></ul><h4 id="覆盖与交换的比较"><a href="#覆盖与交换的比较" class="headerlink" title="覆盖与交换的比较"></a>覆盖与交换的比较</h4><ul><li>覆盖<ul><li>只能发生在没有调用关系的模块间</li><li>程序员必须知道这种逻辑覆盖结构</li><li>发生在运行程序的内部模块间</li></ul></li><li>交换<ul><li>以进程为单位</li><li>不需要模块间的逻辑覆盖结构</li><li>发生在内存进程间</li></ul></li></ul><p>虚拟存储 使用的就是 交换的思路 只不过它是以页来做单位 且 是操作系统来完成的交换</p><h3 id="局部性原理-Principle-of-locality"><a href="#局部性原理-Principle-of-locality" class="headerlink" title="局部性原理 (Principle of locality)"></a>局部性原理 (Principle of locality)</h3><p>程序在执行过程中的一个较短时期 所执行的指令地址和指令的操作数地址 分别局限于一定区域</p><ul><li>时间局部性<ul><li>一条指令的一次执行和下一次执行 一个数据的一次访问和下次访问 都集中在一个较短时期</li></ul></li><li>空间局部性<ul><li>当前指令和邻近的几条指令 当前访问的数据和邻近的几个数据 都集中在一个较小的区域</li></ul></li><li>分支局部性<ul><li>一条跳转指令的两次执行 很可能跳转到相同的内存位置</li></ul></li><li>局部性原理意义<ul><li>从理论上来说 虚拟存储是能够实现的 并且可以取得满意的成果</li></ul></li></ul><h4 id="不同程序编写方法的局部性特征"><a href="#不同程序编写方法的局部性特征" class="headerlink" title="不同程序编写方法的局部性特征"></a>不同程序编写方法的局部性特征</h4><p>例子：页面大小为4K，分配给每个进程的物理页面数为1。在一个进程中，定义了如下的二维数组int A[1024][1024]，该数组按行存放在内存，每一行放在一个页面中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">程序编写方法<span class="number">1</span>：</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">1024</span>; j++)</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++)</span><br><span class="line">    A[i][j] = <span class="number">0</span>; <span class="comment">// 按行 清 0</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">程序编写方法<span class="number">2</span>：</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">1024</span>; j++)</span><br><span class="line">    A[i][j] = <span class="number">0</span>; <span class="comment">// 按列 清 0</span></span><br></pre></td></tr></table></figure><p><img data-src="/images/principleoflocality.png" alt="principle_of_locality"></p><p>第一种编程方法 按行 清 0 按照题目所说 分配给每个进程的物理页面数为 1 就会产生 1024 x 1024 次缺页异常 因为 不断的在换页</p><p>第二种编程方法 按列 清 0 从 0 ~ 1023 都是在同一页 只有换行的时候 才会换页 故会 产生 1024 次 缺页异常</p><p>如果物理内存小 这两种编程方法的性能差距是巨大的</p><h3 id="虚拟存储"><a href="#虚拟存储" class="headerlink" title="虚拟存储"></a>虚拟存储</h3><p>将不常用的部分内存暂存到外存</p><h4 id="虚拟存储的目标"><a href="#虚拟存储的目标" class="headerlink" title="虚拟存储的目标"></a>虚拟存储的目标</h4><ul><li>只把部分程序放到内存中 从而运行比物理内存大的程序</li><li>由操作系统自动完成</li><li>在内存与外存之间只交换进程的部分内容</li></ul><h4 id="虚拟存储思路"><a href="#虚拟存储思路" class="headerlink" title="虚拟存储思路"></a>虚拟存储思路</h4><ul><li>加载程序时 只将当前执行所需要的部分页面或段装入内存</li><li>指令执行时中需要的指令或数据不在内存中时 处理器通知操作系统将相应的页面或段调入内存</li><li>操作系统将内存中暂时不用的页面或段保存到外存</li></ul><h4 id="虚拟存储实现方式"><a href="#虚拟存储实现方式" class="headerlink" title="虚拟存储实现方式"></a>虚拟存储实现方式</h4><ul><li>虚拟段式存储</li><li>虚拟页式存储</li></ul><h4 id="虚拟存储基本特征"><a href="#虚拟存储基本特征" class="headerlink" title="虚拟存储基本特征"></a>虚拟存储基本特征</h4><ul><li>不连续性<ul><li>物理内存分配非连续</li><li>虚拟地址空间使用非连续</li></ul></li><li>大用户空间<ul><li>提供给用户的虚拟内存可大于实际的物理内存</li></ul></li><li>部分交换<ul><li>虚拟存储只对部分虚拟地址空间的换入和换出</li></ul></li></ul><h4 id="虚拟存储的支持技术"><a href="#虚拟存储的支持技术" class="headerlink" title="虚拟存储的支持技术"></a>虚拟存储的支持技术</h4><ul><li>硬件<ul><li>页式或短时存储中的地址转换机制 (硬件要知道它在内存里还是在外存里)</li></ul></li><li>操作系统<ul><li>管理内存和外存间页面或段的换入换出 (操作系统要知道它要换的页面或段是哪些)</li></ul></li></ul><h4 id="虚拟页式存储"><a href="#虚拟页式存储" class="headerlink" title="虚拟页式存储"></a>虚拟页式存储</h4><p>在页式存储管理的基础上 增加请求调页和页面置换</p><ul><li>思路<ul><li>当用户进程要加载到内存运行时 只装入部分页面 就启动程序运行</li><li>进程在运行中发现有需要的代码或数据不在内存中 则向系统发起缺页异常请求 然后就进入了 中断服务例程</li><li>操作系统在处理缺页异常时 将外存的页面调入内存 使进程能够继续运行</li></ul></li></ul><h4 id="虚拟页式存储地址转换"><a href="#虚拟页式存储地址转换" class="headerlink" title="虚拟页式存储地址转换"></a>虚拟页式存储地址转换</h4><p>其实和之前 非虚拟页式存储地址转换 是一样的 只不过页表项里会有一个 P 位 表示这个页是否存在 若不存在 就会发起缺页异常中断</p><p><img data-src="/images/logaddr2phyaddr0.png" alt="logaddr2phyaddr0"></p><p><img data-src="/images/X86pagetable.png" alt="x86pagetable"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">地址转换依然是 逻辑地址的 前 10 位 加上 cr3 寄存器里面的 页目录表基址 找到 PDE </span><br><span class="line">读出 PDE 找到 页表项基址 加上 逻辑地址的中间 10位 找到 PTE</span><br><span class="line">再将 从 PTE 读出的 物理页面帧号 + 逻辑地址的 低 12 位 找到 物理地址</span><br></pre></td></tr></table></figure><p>页表项 结构和之前说的一样<br><img data-src="/images/pagetableentries.png" alt="pagetable_entries"></p><ul><li>AVL CPU 不理会这个属性 可以不管 (有可能在32位系统使用大过 4G内存的时候 用到这几位)</li><li>G Global 全局位 表示是否将虚拟地址与物理地址的转换结果缓存到 TLB 中</li><li>D Dirty 脏页位 当 CPU 对这个页进行写操作时 会置 1</li><li>PAT Page Attribute Table 页属性表位 置 0</li><li>A Accessed 访问位 若为 1 则 说明 CPU 访问过了 CPU 会定时清 0 记录被置 1 的频率 当内存不足时 会将 使用频率较低的页面换出到外存 同时将 P位 置 0 下次访问 该页时 会引起 Pagefault 异常 中断处理程序再将此页换上</li><li>PCD Page-level Cache Disable 页级高速缓存位 置 0 即可 读的时候 高速缓存是否有效 若有效则直接从高速缓存中读出 若无效的话 则必须实实在在的从 I&#x2F;O 端口去读数据</li><li>PWT Page-level Write-Through 页级通写位 控制是先写到高速缓存里再慢慢回写到内存里 还是 直接慢慢写到内存里</li><li>US User&#x2F;Superviosr 普通用户&#x2F;超级用户位</li><li>RW Read&#x2F;Write 读写位</li><li>P Present 存在位 (虚拟页式存储的关键位 若为 0 则发起缺页异常)</li></ul><h4 id="缺页异常的处理例程"><a href="#缺页异常的处理例程" class="headerlink" title="缺页异常的处理例程"></a>缺页异常的处理例程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CPU 执行 Load M</span><br><span class="line">这条指令会去找 M 对应的 页表项 若 这个页表项有效(P 位 为 1) 则直接访问</span><br><span class="line">若无效 就会产生缺页异常 导致操作系统的缺页异常的服务例程会执行</span><br><span class="line">缺页异常服务例程 会去找外存中的那个页面 若找到 就将其读入内存</span><br><span class="line">读入内存之前 还要先判断物理内存中是否有空闲页 若找到空闲页 就将这页读进来 并修改页表项 最后重新执行 一开始的那条指令</span><br><span class="line">若找不到空闲页 依据页面置换算法 找一页不常用的页 若这一页被修改过 则将其写到外存 </span><br><span class="line">若未修改过 则将其丢弃 且 修改 这一页的 P 位 为 0 使其失效</span><br><span class="line">将需要访问的页装入被替换掉的页 且 修改 页表项的 P 位 为 1</span><br></pre></td></tr></table></figure><p><img data-src="/images/pagefault.png" alt="pagefault"></p><h4 id="虚拟页式存储中的外存管理"><a href="#虚拟页式存储中的外存管理" class="headerlink" title="虚拟页式存储中的外存管理"></a>虚拟页式存储中的外存管理</h4><p>在何处保存未被映射的页?</p><ul><li>应能方便地找到在外存中的页面内容 (直接做一个分区做对换区 Linux Unix)</li><li>交换空间 (磁盘或者文件)<ul><li>采用特殊格式存储未被映射的页面 (用一个文件来存)</li></ul></li></ul><p>虚拟页式存储中的外存怎么选择?</p><ul><li>代码段 它就是可执行的二进制文件 没必要复制</li><li>代码加载的共享库程序段 也是不会变的 没必要复制</li><li>其他段 可以放到交换空间里去</li></ul><h4 id="虚拟页式存储管理的性能"><a href="#虚拟页式存储管理的性能" class="headerlink" title="虚拟页式存储管理的性能"></a>虚拟页式存储管理的性能</h4><p>有效存储访问时间 (Effective memory access time EAT)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EAT = 访存时间 * (1 - p) + 缺页异常处理时间 * 缺页率p * (1 + 页修改概率q) (若不开启虚拟页式存储 则 EAT = 访存时间)</span><br><span class="line">加多一个 页修改概率q 是因为被替换的页被修改过的话 还要写到外存里保存起来</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"># 操作系统</a> <a href="/tags/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8/" rel="tag"># 虚拟存储</a></div><div class="post-nav"><div class="post-nav-item"><a href="/%E5%BE%AE%E4%BF%A1%E6%91%87%E4%B8%80%E6%91%87%E7%AD%BE%E5%88%B0-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" rel="prev" title="微信摇一摇签到 解决方案"><i class="fa fa-angle-left"></i> 微信摇一摇签到 解决方案</a></div><div class="post-nav-item"><a href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/" rel="next" title="操作系统之 虚拟存储页面置换算法">操作系统之 虚拟存储页面置换算法 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Yuerer</span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://unpkg.com/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://unpkg.com/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/comments.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/utils.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/motion.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/sidebar.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/next-boot.min.js"></script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://yuerer-comment-xufei-0bea01e6f05-1307930306.ap-shanghai.app.tcloudbase.com","cssUrl":"https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.css","commentCount":true,"pageview":true,"libUrl":"https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.js","locale":{"placeholder":"有何高见？"},"emoji":["https://unpkg.com/@waline/emojis@1.0.1/qq"],"meta":["nick","mail"],"requiredMeta":[["nick","mail"]],"wordLimit":0,"login":"disable","pageSize":10,"el":"#waline","comment":true,"path":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E6%A6%82%E5%BF%B5/"}</script><link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.css"><script>document.addEventListener("page:loaded",()=>{NexT.utils.loadComments(CONFIG.waline.el).then(()=>NexT.utils.getScript(CONFIG.waline.libUrl,{condition:window.Waline})).then(()=>Waline.init(Object.assign({},CONFIG.waline,{el:document.querySelector(CONFIG.waline.el)})))})</script></body></html>