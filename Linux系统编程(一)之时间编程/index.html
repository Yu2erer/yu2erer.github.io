<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.jpeg"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.ico"><link rel="mask-icon" href="/images/avatar.jpeg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous"><link rel="stylesheet" href="https://unpkg.com/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"yuerer.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"hide","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":true,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/config.min.js"></script><meta name="description" content="这是 Linux 系统编程系列 中的第一篇, 在这个系列里面, 我想以这么个顺序来讲述每一篇的内容, 先是快速简单地了解一下 常见的使用方法, 即API如何使用, 接着再深入其中, 了解内核为API提供的帮助, 大致是 C标准库 → 系统调用 这么个学习路线. 时间的定义首先要记住 计算机的起始时间 为 (格林威治时间)1970年1月1日0点, 被称作 GMT时间 是时区时间, 不过它是根据地球公"><meta property="og:type" content="article"><meta property="og:title" content="Linux系统编程(一) 之时间编程"><meta property="og:url" content="https://yuerer.com/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B(%E4%B8%80)%E4%B9%8B%E6%97%B6%E9%97%B4%E7%BC%96%E7%A8%8B/index.html"><meta property="og:site_name" content="Yuerer&#39;s Blog"><meta property="og:description" content="这是 Linux 系统编程系列 中的第一篇, 在这个系列里面, 我想以这么个顺序来讲述每一篇的内容, 先是快速简单地了解一下 常见的使用方法, 即API如何使用, 接着再深入其中, 了解内核为API提供的帮助, 大致是 C标准库 → 系统调用 这么个学习路线. 时间的定义首先要记住 计算机的起始时间 为 (格林威治时间)1970年1月1日0点, 被称作 GMT时间 是时区时间, 不过它是根据地球公"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://yuerer.com/images/unixTimePhoto.png"><meta property="article:published_time" content="2020-07-29T05:14:20.000Z"><meta property="article:modified_time" content="2025-10-21T13:50:52.252Z"><meta property="article:author" content="Yuerer"><meta property="article:tag" content="Linux"><meta property="article:tag" content="系统编程"><meta property="article:tag" content="时间"><meta property="article:tag" content="时间编程"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://yuerer.com/images/unixTimePhoto.png"><link rel="canonical" href="https://yuerer.com/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B(%E4%B8%80)%E4%B9%8B%E6%97%B6%E9%97%B4%E7%BC%96%E7%A8%8B/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://yuerer.com/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B(%E4%B8%80)%E4%B9%8B%E6%97%B6%E9%97%B4%E7%BC%96%E7%A8%8B/","path":"Linux系统编程(一)之时间编程/","title":"Linux系统编程(一) 之时间编程"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Linux系统编程(一) 之时间编程 | Yuerer's Blog</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-129491388-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-129491388-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/third-party/analytics/google-analytics.min.js"></script><link rel="dns-prefetch" href="https://yuerer-comment-xufei-0bea01e6f05-1307930306.ap-shanghai.app.tcloudbase.com"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Yuerer's Blog</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">钰儿的Blog</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">时间的定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%97%B6%E9%97%B4"><span class="nav-text">获取时间</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#time-%E7%A7%92"><span class="nav-text">time() 秒</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gettimeofday-%E5%BE%AE%E7%A7%92"><span class="nav-text">gettimeofday() 微秒</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RDTSC-%E8%AF%BB%E5%8F%96-TSC-Time-Stamp-Counter"><span class="nav-text">RDTSC 读取 TSC (Time Stamp Counter)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#POSIX-Timer-%E7%BA%B3%E7%A7%92"><span class="nav-text">POSIX Timer 纳秒</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CLOCK-ID"><span class="nav-text">CLOCK_ID</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%95%E7%A4%BA%E6%97%B6%E9%97%B4"><span class="nav-text">展示时间</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#gmtime-%E5%92%8C-localtime"><span class="nav-text">gmtime() 和 localtime()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mktime"><span class="nav-text">mktime()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#strftime"><span class="nav-text">strftime()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#strptime"><span class="nav-text">strptime()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E6%97%B6%E5%99%A8"><span class="nav-text">计时器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#alarm"><span class="nav-text">alarm()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#setitimer"><span class="nav-text">setitimer()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#timerfd-create"><span class="nav-text">timerfd_create()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E7%9A%84%E6%9C%AC%E9%A2%86"><span class="nav-text">硬件的本领</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux-%E4%B8%AD%E7%9A%84%E6%97%B6%E9%97%B4"><span class="nav-text">Linux 中的时间</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4"><span class="nav-text">系统时间</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E6%97%B6%E5%99%A8%E5%AE%9E%E7%8E%B0"><span class="nav-text">计时器实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#alarm-%E5%AE%9E%E7%8E%B0"><span class="nav-text">alarm() 实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81-Timer"><span class="nav-text">动态 Timer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%B4%E9%9A%94-Timer-setitimer"><span class="nav-text">间隔 Timer setitimer()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#POSIX-Timer"><span class="nav-text">POSIX Timer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%8E%E7%B2%BE%E5%BA%A6%E7%89%88%E6%9C%AC-%E6%97%B6%E9%97%B4%E8%BD%AE"><span class="nav-text">低精度版本 时间轮</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%89%88%E6%9C%AC-Hrtimer"><span class="nav-text">高精度版本 Hrtimer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Yuerer" src="/images/avatar.jpeg"><p class="site-author-name" itemprop="name">Yuerer</p><div class="site-description" itemprop="description">钰儿的Blog</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">65</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">16</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">90</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/Yu2erer" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Yu2erer" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:yu2erer#gmail.com" title="E-Mail → mailto:yu2erer#gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://yuerer.com/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B(%E4%B8%80)%E4%B9%8B%E6%97%B6%E9%97%B4%E7%BC%96%E7%A8%8B/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpeg"><meta itemprop="name" content="Yuerer"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Yuerer's Blog"><meta itemprop="description" content="钰儿的Blog"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Linux系统编程(一) 之时间编程 | Yuerer's Blog"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Linux系统编程(一) 之时间编程</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-07-29 13:14:20" itemprop="dateCreated datePublished" datetime="2020-07-29T13:14:20+08:00">2020-07-29</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Linux系统编程</span></a> </span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Waline：</span> <a title="waline" href="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B(%E4%B8%80)%E4%B9%8B%E6%97%B6%E9%97%B4%E7%BC%96%E7%A8%8B/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B(%E4%B8%80)%E4%B9%8B%E6%97%B6%E9%97%B4%E7%BC%96%E7%A8%8B/" itemprop="commentCount"></span> </a></span><span class="post-meta-item" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="waline-pageview-count" data-path="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B(%E4%B8%80)%E4%B9%8B%E6%97%B6%E9%97%B4%E7%BC%96%E7%A8%8B/"></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>这是 Linux 系统编程系列 中的第一篇, 在这个系列里面, 我想以这么个顺序来讲述每一篇的内容, 先是快速简单地了解一下 常见的使用方法, 即API如何使用, 接着再深入其中, 了解内核为API提供的帮助, 大致是 C标准库 → 系统调用 这么个学习路线.</p><h2 id="时间的定义"><a href="#时间的定义" class="headerlink" title="时间的定义"></a>时间的定义</h2><p>首先要记住 计算机的起始时间 为 (格林威治时间)1970年1月1日0点, 被称作 GMT时间 是时区时间, 不过它是根据地球公转和自转来计算的, 不是特别准确. 在计算机世界中, 往往被称作 UTC时间, 它是以原子钟来计算时间, 简单来说就是 UTC时间 比 GMT时间要准确, 同时两个时间又恰好没有时差, 但是UTC时间又不是时区时间, 因此容易被人弄混.</p><span id="more"></span><h2 id="获取时间"><a href="#获取时间" class="headerlink" title="获取时间"></a>获取时间</h2><h3 id="time-秒"><a href="#time-秒" class="headerlink" title="time() 秒"></a>time() 秒</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="comment">// 结果可以通过返回值得到 也可以通过传入指针得到</span></span><br><span class="line"><span class="type">time_t</span> <span class="title function_">time</span><span class="params">(<span class="type">time_t</span> *calptr)</span>;</span><br></pre></td></tr></table></figure><h3 id="gettimeofday-微秒"><a href="#gettimeofday-微秒" class="headerlink" title="gettimeofday() 微秒"></a>gettimeofday() 微秒</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">gettimeofday</span><span class="params">(<span class="keyword">struct</span> timeval *<span class="keyword">restrict</span> tp, <span class="type">void</span> *<span class="keyword">restrict</span> tzp <span class="comment">/*一般为NULL表示时区*/</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li>很多人说其性能不高 因为本质是系统调用 会频繁陷入内核</li><li>不过 在 x86_64下 采用了 vsyscall 并没有 陷入内核中</li><li>比 clock_gettime 性能高</li><li>兼容性不高(部分系统下 被弃用)</li></ul><h3 id="RDTSC-读取-TSC-Time-Stamp-Counter"><a href="#RDTSC-读取-TSC-Time-Stamp-Counter" class="headerlink" title="RDTSC 读取 TSC (Time Stamp Counter)"></a>RDTSC 读取 TSC (Time Stamp Counter)</h3><ul><li>非特权指令 可以避免 用户态和内核态的开销</li><li>只能在 Intel 平台下使用</li><li>奔腾处理器引入了乱序执行, 可能会导致想测的指令在 RDTSC之外 执行, 如果有RDTSCP 最好用这个</li><li>当然如果没有的话, 那就只能用 cpuid指令 来保序</li><li>CPU频率可能会被改变, 比如说开启了节能模式, 如果是比较新的Intel处理器 则可以采用 grep tsc &#x2F;proc&#x2F;cpuinfo，有constant_tsc 和 nonstop_tsc 也就足够了</li><li>各个CPU的核心中得TSC寄存器不一定同步, 同步的话开销太大, 用 RDTSC 指令没啥意义了</li></ul><h3 id="POSIX-Timer-纳秒"><a href="#POSIX-Timer-纳秒" class="headerlink" title="POSIX Timer 纳秒"></a>POSIX Timer 纳秒</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">clock_gettime</span><span class="params">(<span class="type">clockid_t</span> clock_id, <span class="keyword">struct</span> timespec *tsp)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">clock_settime</span><span class="params">(<span class="type">clockid_t</span> clock_id, <span class="type">const</span> <span class="keyword">struct</span> timespec *tsp)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">clock_getres</span><span class="params">(<span class="type">clockid_t</span> clock_id, <span class="keyword">struct</span> timespec *tsp)</span>;</span><br></pre></td></tr></table></figure><ul><li>当在 Intel x86_64 平台下获取 CLOCK_PROCESS_CPUTIME_ID 和 CLOCK_THREAD_CPUTIME_ID 本质上就是 用的 RDTSC 的 TSC(time stamp counter寄存器) 每个时间中断 + 1</li><li>总而言之, 大部分情况下 clock_gettime() 就够了, 如果要测纳秒上的结果, 再去用 RDTSC&#x2F;RDTSCP指令.</li></ul><p>可以看到 这几个函数 有一个 clock_id 的参数 这都属于 POSIX CLOCKS 中的内容.</p><h3 id="CLOCK-ID"><a href="#CLOCK-ID" class="headerlink" title="CLOCK_ID"></a>CLOCK_ID</h3><ul><li>CLOCK_REALTIME<ul><li>系统真实时间 俗称墙上时间 可能会被用户修改, 受 NTP 影响</li></ul></li><li>CLOCK_MONOTONIC<ul><li>与系统真实时间无关的时间, 单调时间, 受 NTP 影响</li></ul></li><li>CLOCK_PROCESS_CPUTIME_ID<ul><li>进程所耗费时间</li></ul></li><li>CLOCK_THREAD_CPUTIME_ID<ul><li>线程为单位耗费时间</li></ul></li><li>CLOCK_MONOTONIC_RAW<ul><li>与 CLOCK_MONOTONIC 相似 不过不会被 NTP影响到其频率</li></ul></li><li>CLOCK_REALTIME_COARSE<ul><li>CLOCK_REALTIME 低精度版本 即以Tick为单位, 受 NTP 影响</li></ul></li><li>CLOCK_MONOTONIC_COARSE<ul><li>CLOCK_MONOTONIC 低精度版本 即以Tick为单位, 受 NTP 影响</li></ul></li><li>CLOCK_BOOTTIME<ul><li>与 CLOCK_MONOTONIC 类似 但是会包含suspended时间</li></ul></li><li>CLOCK_REALTIME_ALARM<ul><li>基于 RTC (Real Time Clock), 系统暂停也能运作</li></ul></li><li>CLOCK_BOOTTIME_ALARM<ul><li>基于 RTC (Real Time Clock), 系统暂停也能运作</li></ul></li><li>CLOCK_TAI<ul><li>原子钟时间 没有闰秒, 以上都受闰秒影响, 唯独这个不受.</li></ul></li></ul><p>原子秒 是各界大佬发现铯133基态的两个超精细能级之间跃迁所对应的辐射（电磁波）的9 192 631 770个周期持续的时间 非常稳定, 因此就拿它来定义 秒的概念. 物极必反, 原子秒非常精确,但与地球公转和自转存在时间差, 因此需要加入闰秒进行适当调整.</p><h2 id="展示时间"><a href="#展示时间" class="headerlink" title="展示时间"></a>展示时间</h2><h3 id="gmtime-和-localtime"><a href="#gmtime-和-localtime" class="headerlink" title="gmtime() 和 localtime()"></a>gmtime() 和 localtime()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="comment">// 转为 GMT时间</span></span><br><span class="line"><span class="keyword">struct</span> tm *<span class="title function_">gmtime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *calptr)</span>;</span><br><span class="line"><span class="comment">// 转为 当前时区时间</span></span><br><span class="line"><span class="keyword">struct</span> tm *<span class="title function_">localtime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *calptr)</span>;</span><br></pre></td></tr></table></figure><h3 id="mktime"><a href="#mktime" class="headerlink" title="mktime()"></a>mktime()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span> </span></span><br><span class="line"><span class="comment">// 将 tm时间转化为 time_t</span></span><br><span class="line"><span class="type">time_t</span> <span class="title function_">mktime</span><span class="params">(<span class="keyword">struct</span> tm *tmptr)</span>;</span><br></pre></td></tr></table></figure><h3 id="strftime"><a href="#strftime" class="headerlink" title="strftime()"></a>strftime()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 格式化 tm 结构体来打印时间</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strftime</span><span class="params">(<span class="type">char</span> *<span class="keyword">restrict</span> buf, <span class="type">size_t</span> maxsize, </span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> format, </span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="keyword">struct</span> tm *<span class="keyword">restrict</span> tmptr)</span>;</span><br></pre></td></tr></table></figure><h3 id="strptime"><a href="#strptime" class="headerlink" title="strptime()"></a>strptime()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="comment">// 字符串 转化为 tm结构体 与上面 恰好相反</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strptime</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> buf, <span class="type">const</span> <span class="type">char</span> *<span class="keyword">restrict</span> format, </span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> tm *<span class="keyword">restrict</span> tmptr)</span>;</span><br></pre></td></tr></table></figure><p>附上 Unix 环境高级编程 中的一张图.</p><p><img data-src="/images/unixTimePhoto.png" alt="unixTimePhoto.png"></p><h2 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h2><h3 id="alarm"><a href="#alarm" class="headerlink" title="alarm()"></a>alarm()</h3><p>sleep(), usleep() 都是用 SIGALRM实现</p><p>以秒为精度, 每个进程只能设置一个, 可以猜想到 PCB中只有一个 alarm(事实也是如此)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 到期则发出 SIGALRM(默认动作终止进程)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br><span class="line"><span class="comment">// 挂起直到接收到一个信号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pause</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="setitimer"><a href="#setitimer" class="headerlink" title="setitimer()"></a>setitimer()</h3><p>也是用信号实现 不适合 多线程编程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setitimer</span><span class="params">(<span class="type">int</span> which, <span class="type">const</span> <span class="keyword">struct</span> itimerval *value, <span class="keyword">struct</span> itimerval *ovalue)</span>;</span><br></pre></td></tr></table></figure><p>which 有 3种</p><ul><li>ITIMER_REAL 减少实际时间<ul><li>发出 SIGALRM 信号</li></ul></li><li>ITIMER_VIRTUAL 减少进程所执行的时间(不包含进程调度时间)<ul><li>发出 SIGVTALRM 信号</li></ul></li><li>ITIMER_PROF 减少进程所执行时间和进程调度所用时间<ul><li>发出 SIGPROF 信号</li></ul></li></ul><h3 id="timerfd-create"><a href="#timerfd-create" class="headerlink" title="timerfd_create()"></a>timerfd_create()</h3><p>将时间当做文件描述符, 在超时的时候, 文件变为可读, 适于多线程编程, 能很好融入 poll, epoll</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">timerfd_create</span><span class="params">(<span class="type">int</span> clockid, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure><h2 id="硬件的本领"><a href="#硬件的本领" class="headerlink" title="硬件的本领"></a>硬件的本领</h2><p>可以总结一下, 硬件有很多种, 有关时间的硬件无非要么提供时间中断功能, 要么提供了存储时间供用户读取的功能, 要么两者皆有.</p><ul><li>RTC(Real Time Clock) 实时时钟<ul><li>顾名思义 记录当前时间, 同时断电的时候 主板有个电池, 维持正确的时间, 精度到秒</li><li>既可以存储 LCT 也可以存储 UTC 凭借系统的配置文件进行配置</li></ul></li><li>TSC(Time Stamp Counter)<ul><li>就是上面讲到的 RDTSC 汇编指令所度的硬件, 只存在于 Intel 处理器, 每个Tick 都会 加 1, 即每次时钟中断都会 + 1, 纳秒级别时间精度.</li></ul></li></ul><p>还有更多的硬件, 就不一一解释了, 只要记住 硬件主要是 提供中断 和 存储时间的能力, 哪怕上层函数提供的时间精度再精细, 本质上也是因为硬件的计时单位精度提高了.</p><h2 id="Linux-中的时间"><a href="#Linux-中的时间" class="headerlink" title="Linux 中的时间"></a>Linux 中的时间</h2><p>这一小节, 将讲解 Linux 0.12 中是如何实现时间系统的.</p><h3 id="系统时间"><a href="#系统时间" class="headerlink" title="系统时间"></a>系统时间</h3><p>顾名思义, 就是维护系统时间的, 前面提到过 RTC 有一块电池, 始终保持系统时间, Linux 在 time_init 函数那, 会读取 RTC 硬件上的信息, 并将其初始化到 startup_time, 此后直到重启系统, 都不会再去读取 RTC了.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内核中还会有这个宏, 来维护当前时间 每个jiffies 为一个Tick</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CURRENT_TIME (startup_time+(jiffies+jiffies_offset)/HZ)	<span class="comment">/* 当前时间(秒数) */</span></span></span><br></pre></td></tr></table></figure><p>每一次 发起时钟中断, 内核会调用到 do_timer() 这一函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">简单来说 每次时钟中断的时候 都会去 判断当前特权级 即 CPL</span></span><br><span class="line"><span class="comment">如果在用户态 则 相应的 进程PCB utime ++, 否则 stime ++</span></span><br><span class="line"><span class="comment">这个版本是早期 Linux 0.12的 因此 这里面的 timer 即 计时器实现的略为粗浅</span></span><br><span class="line"><span class="comment">是将 计时器做成一个数组, 每次去遍历 哪个 timer 的时间到了</span></span><br><span class="line"><span class="comment"> 再去执行相应的操作(当讲到计时器的时候再展开)</span></span><br><span class="line"><span class="comment">接着减少 当前占用CPU的进程的时间片</span></span><br><span class="line"><span class="comment">接着再去执行调度函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_timer</span><span class="params">(<span class="type">long</span> cpl)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> blanked = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (blankcount || !blankinterval) &#123;</span><br><span class="line">		<span class="keyword">if</span> (blanked) &#123;</span><br><span class="line">			unblank_screen();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (blankcount) &#123;</span><br><span class="line">			blankcount--;</span><br><span class="line">		&#125;</span><br><span class="line">		blanked = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!blanked) &#123;</span><br><span class="line">		blank_screen();</span><br><span class="line">		blanked = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (hd_timeout) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!--hd_timeout) &#123;</span><br><span class="line">			hd_times_out();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (beepcount) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!--beepcount) &#123;</span><br><span class="line">			sysbeepstop();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (cpl) &#123;</span><br><span class="line">		current-&gt;utime++;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		current-&gt;stime++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (next_timer) &#123;</span><br><span class="line">		next_timer-&gt;jiffies--;</span><br><span class="line">		<span class="keyword">while</span> (next_timer &amp;&amp; next_timer-&gt;jiffies &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="type">void</span> (*fn)(<span class="type">void</span>);</span><br><span class="line">			</span><br><span class="line">			fn = next_timer-&gt;fn;</span><br><span class="line">			next_timer-&gt;fn = <span class="literal">NULL</span>;</span><br><span class="line">			next_timer = next_timer-&gt;next;</span><br><span class="line">			(fn)();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (current_DOR &amp; <span class="number">0xf0</span>) &#123;</span><br><span class="line">		do_floppy_timer();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((--current-&gt;counter)&gt;<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	current-&gt;counter=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!cpl) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	schedule();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看完上面, 细心地观众可能会在想 jiffies 没有++啊? 那怎么维护 CURRENT_TIME 这个宏呢?</p><p>其实是在 系统调用的时候, 已经加了.</p><figure class="highlight wasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">timer_interrupt:</span><br><span class="line">	# ***</span><br><span class="line">	incl jiffies # 就在这</span><br><span class="line">	***</span><br><span class="line">	<span class="keyword">call</span> do_timer		# &#x27;do_timer<span class="punctuation">(</span>long CPL<span class="punctuation">)</span>&#x27; does everything from</span><br><span class="line">	# ***</span><br><span class="line">	jmp ret_from_sys_call</span><br></pre></td></tr></table></figure><p>以上都是最基础的 Linux 0.12 版本的实现, 至于其他 clock_gettime 上面也提到过, 在大多数情况直接用的是 RDTSC 这一汇编指令.</p><h2 id="计时器实现"><a href="#计时器实现" class="headerlink" title="计时器实现"></a>计时器实现</h2><h3 id="alarm-实现"><a href="#alarm-实现" class="headerlink" title="alarm() 实现"></a>alarm() 实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个系统调用 设置PCB的 alarm数值</span></span><br><span class="line"><span class="comment">// sleep() 调用的就是这个系统调用</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_alarm</span><span class="params">(<span class="type">long</span> seconds)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> old = current-&gt;alarm;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (old) &#123;</span><br><span class="line">		old = (old - jiffies) / HZ;</span><br><span class="line">	&#125;</span><br><span class="line">	current-&gt;alarm = (seconds &gt; <span class="number">0</span>) ? (jiffies + HZ * seconds) : <span class="number">0</span>; </span><br><span class="line">	<span class="comment">// 以 当前jiffies为基数</span></span><br><span class="line">	<span class="comment">// 在 schedule() 调度的时候 会去判断 如果 大于 此时的 jiffies 则发送 SIGALARM 信号</span></span><br><span class="line">	<span class="keyword">return</span> (old);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先暂时略过 信号的工作原理, 等有机会再讲, 现在只要知道它发送了 SIGALARM 信号就行了.</p><h3 id="动态-Timer"><a href="#动态-Timer" class="headerlink" title="动态 Timer"></a>动态 Timer</h3><p>其实就是内核里面用到的Timer, 也是用户态计时器的基础.</p><p>这可以理解为最早期的时间轮算法, 不过在后期 Linux 使用了 Hierarchy 时间轮, 它本身是按照 时&#x2F;分&#x2F;秒 分为三个层级, 每个层级又根据 24&#x2F;60&#x2F;60 来分桶, 每次时钟中断的时候, 就将到期的移除, 且进行触发通知, Hierarchy 时间轮的 添加删除触发都是O(1), 但是维护起来非常费时, 比如当 分 走回0的时候, 就需要对 时 做移动, 通常我们的 Timer 达不到 60个那么多, 所以比较耗时.</p><p>也因此, Linux 采用的是 将 jiffies 分为 5个部分, Linux中称作 Timer Vector, 用来进行索引, 也有上面处理的缺点, 会带来不确定的延时.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此为最早期的 时间轮, 并非是 Hierarchy 时间轮</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_REQUESTS 64</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> &#123;</span></span><br><span class="line">	<span class="type">long</span> jiffies;</span><br><span class="line">	<span class="type">void</span> (*fn)();</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125; timer_list[TIME_REQUESTS], * next_timer = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>可以看出 最多只能支持到 64 个 Timer, 每次发生时钟中断的时候 就遍历一下 timer_list.</p><h3 id="间隔-Timer-setitimer"><a href="#间隔-Timer-setitimer" class="headerlink" title="间隔 Timer setitimer()"></a>间隔 Timer setitimer()</h3><ul><li>ITIMER_REAL 实际时间<ul><li>因为是实际时间 可以直接用 内核中的 Timer实现</li></ul></li><li>ITIMER_VIRTUAL 进程真实执行时间<ul><li>由于参照的是进程时间, 要判断处于内核态还是用户态, 再修改相应数值 比如 utime, stime</li></ul></li><li>ITIMER_PROF 进程执行时间+进程调度时间<ul><li>和上面一样 也要考虑到当前内核态还是用户态</li></ul></li></ul><h3 id="POSIX-Timer"><a href="#POSIX-Timer" class="headerlink" title="POSIX Timer"></a>POSIX Timer</h3><h3 id="低精度版本-时间轮"><a href="#低精度版本-时间轮" class="headerlink" title="低精度版本 时间轮"></a>低精度版本 时间轮</h3><p>这其实就是上面 讲的 与 CLOCK_ID 相关的一类的接口, 其中 CLOCK_REALTIME 与 CLOCK_MONOTONIC 实现起来较为简单, 直接建立在 内核动态 Timer之上, 以 Tick 为单位.</p><p>然后 CLOCK_PROCESS_CPUTIME_ID 和 CLOCK_THREAD_CPUTIME_ID 这两个是和进程线程相关, 理所当然的是要在 PCB 下进行维护, Linux 做法是在PCB 下面加两个数组, 其中每个数组又做成了链表的形式, 有点像桶, 来维护 PROCESS 和 THREAD 的CPU Timer.</p><p>现在有了高精度版本的计时器, 基本上就只有内核和一些旧的驱动程序还在用了.</p><h3 id="高精度版本-Hrtimer"><a href="#高精度版本-Hrtimer" class="headerlink" title="高精度版本 Hrtimer"></a>高精度版本 Hrtimer</h3><p>要想提高精度, 自然要先将硬件上的HZ提高, 同时又不能太高, 高过1000的话, 时钟中断太频繁了, 性能会下降.</p><p>由于之前那套时间轮算法, 调整的过程 必然会有开销(因为你要重新排列位置), 因此引入了一个新的计时器 Hrtimer.</p><p>Hrtimer 的实现还是很简单的</p><ul><li>用红黑树以到期时间为key进行排序<ul><li>猜测使用红黑树的原因是 内核里面本身就有, 而且测试后特别好</li></ul></li><li>不用 jiffies 为计时单位, jiffies &#x3D; 10ms 精度不够, 以 纳秒为计时单位</li></ul><p>在 多处理器的情况下, 每个CPU 都要维护 两个数据结构, 一个为 Monotonic 另一个是 Real time.</p><p>在高精度计时器中, 是直接有硬件计时器进行中断触发, 而不再是使用 Tick, 不过始终有误差, 因为始终还是通过中断机制去修改 Hrtimer 的红黑树嘛, 只不过 Hrtimer 的中断处理函数只醉心于 计时, 那原先的时钟中断所做的进程调度之类的事情, 则是由 Hrtimer 开一个计时器, 然后设置好间隔的 Tick, 最后设置 计时回调函数, 当时间到了, 就到计时回调函数那处理 进程调度.</p><p>换一句话说就是 Hrtimer 开了一个计时器 模拟了 时钟中断.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过上面的洗礼,相信读者已经对 Linux 下的时间编程原理有了一个新的认识, 用起来就按需要的精度来选择, 原理 无非就是 将时间分为5个部分 做成一个时间轮 或者 用红黑树将到期时间进行排序, 本质上都离不开中断机制.</p></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Linux/" rel="tag"># Linux</a> <a href="/tags/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" rel="tag"># 系统编程</a> <a href="/tags/%E6%97%B6%E9%97%B4/" rel="tag"># 时间</a> <a href="/tags/%E6%97%B6%E9%97%B4%E7%BC%96%E7%A8%8B/" rel="tag"># 时间编程</a></div><div class="post-nav"><div class="post-nav-item"><a href="/C++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E4%B9%8B-Loki-Allocator/" rel="prev" title="C++ 内存管理 之 Loki Allocator"><i class="fa fa-angle-left"></i> C++ 内存管理 之 Loki Allocator</a></div><div class="post-nav-item"><a href="/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" rel="next" title="Linux网络编程 I/O多路复用">Linux网络编程 I/O多路复用 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Yuerer</span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://unpkg.com/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://unpkg.com/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/comments.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/utils.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/motion.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/sidebar.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/next-boot.min.js"></script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://yuerer-comment-xufei-0bea01e6f05-1307930306.ap-shanghai.app.tcloudbase.com","cssUrl":"https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.css","commentCount":true,"pageview":true,"libUrl":"https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.js","locale":{"placeholder":"有何高见？"},"emoji":["https://unpkg.com/@waline/emojis@1.0.1/qq"],"meta":["nick","mail"],"requiredMeta":[["nick","mail"]],"wordLimit":0,"login":"disable","pageSize":10,"el":"#waline","comment":true,"path":"/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B(%E4%B8%80)%E4%B9%8B%E6%97%B6%E9%97%B4%E7%BC%96%E7%A8%8B/"}</script><link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.css"><script>document.addEventListener("page:loaded",()=>{NexT.utils.loadComments(CONFIG.waline.el).then(()=>NexT.utils.getScript(CONFIG.waline.libUrl,{condition:window.Waline})).then(()=>Waline.init(Object.assign({},CONFIG.waline,{el:document.querySelector(CONFIG.waline.el)})))})</script></body></html>