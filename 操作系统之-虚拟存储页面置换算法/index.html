<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.jpeg"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.ico"><link rel="mask-icon" href="/images/avatar.jpeg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous"><link rel="stylesheet" href="https://unpkg.com/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"yuerer.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"hide","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":true,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/config.min.js"></script><meta name="description" content="页面置换算法概念 功能 当出现缺页异常时 需调入新页面且内存已满 置换算法选择被置换的物理页面   设计目标 尽可能地减少页面调入调出次数 把未来不再访问 或 短期内不访问的页面调出   页面锁定 (Frame locking) 描述必须常驻内存的逻辑页面 操作系统的关键代码 要求响应速度的代码和数据 页表中的锁定标志位 (Lock bit)"><meta property="og:type" content="article"><meta property="og:title" content="操作系统之 虚拟存储页面置换算法"><meta property="og:url" content="https://yuerer.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/index.html"><meta property="og:site_name" content="Yuerer&#39;s Blog"><meta property="og:description" content="页面置换算法概念 功能 当出现缺页异常时 需调入新页面且内存已满 置换算法选择被置换的物理页面   设计目标 尽可能地减少页面调入调出次数 把未来不再访问 或 短期内不访问的页面调出   页面锁定 (Frame locking) 描述必须常驻内存的逻辑页面 操作系统的关键代码 要求响应速度的代码和数据 页表中的锁定标志位 (Lock bit)"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://yuerer.com/images/OPT_page_replacement_algorithm.png"><meta property="og:image" content="https://yuerer.com/images/FIFO_page_replacement_algorithm.png"><meta property="og:image" content="https://yuerer.com/images/LRU_page_replacement_algorithm.png"><meta property="og:image" content="https://yuerer.com/images/LRU_stack_page_replacement_algorithm.png"><meta property="og:image" content="https://yuerer.com/images/Clock_page_replacement_algorithm.png"><meta property="og:image" content="https://yuerer.com/images/Improved_Clock_page_replacement_algorithm.png"><meta property="og:image" content="https://yuerer.com/images/LFU_page_replacement_algorithm.png"><meta property="og:image" content="https://yuerer.com/images/FIFO_Belady_3.png"><meta property="og:image" content="https://yuerer.com/images/FIFO_Belady_4.png"><meta property="og:image" content="https://yuerer.com/images/LRU_No_Belady.png"><meta property="og:image" content="https://yuerer.com/images/CPU_process.png"><meta property="og:image" content="https://yuerer.com/images/Working_set.png"><meta property="og:image" content="https://yuerer.com/images/Working_set_page_replacement_algorithm.png"><meta property="og:image" content="https://yuerer.com/images/PFF_process.png"><meta property="og:image" content="https://yuerer.com/images/PFF_page_replacement_algorithm.png"><meta property="og:image" content="https://yuerer.com/images/thrashing.png"><meta property="article:published_time" content="2018-11-23T10:47:20.000Z"><meta property="article:modified_time" content="2025-10-21T13:50:52.276Z"><meta property="article:author" content="Yuerer"><meta property="article:tag" content="操作系统"><meta property="article:tag" content="虚拟存储"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://yuerer.com/images/OPT_page_replacement_algorithm.png"><link rel="canonical" href="https://yuerer.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://yuerer.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/","path":"操作系统之-虚拟存储页面置换算法/","title":"操作系统之 虚拟存储页面置换算法"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>操作系统之 虚拟存储页面置换算法 | Yuerer's Blog</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-129491388-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-129491388-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/third-party/analytics/google-analytics.min.js"></script><link rel="dns-prefetch" href="https://yuerer-comment-xufei-0bea01e6f05-1307930306.ap-shanghai.app.tcloudbase.com"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Yuerer's Blog</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">钰儿的Blog</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E6%A6%82%E5%BF%B5"><span class="nav-text">页面置换算法概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E8%AF%84%E4%BB%B7%E6%96%B9%E6%B3%95"><span class="nav-text">页面置换算法评价方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-text">局部页面置换算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E4%BC%98%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95-OPT-optional"><span class="nav-text">最优页面置换算法 (OPT optional)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E4%BC%98%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="nav-text">最优页面置换算法实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E4%BC%98%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E7%89%B9%E5%BE%81"><span class="nav-text">最优页面置换算法特征</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E4%BC%98%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="nav-text">最优页面置换算法示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95-FIFO-First-In-First-Out"><span class="nav-text">先进先出置换算法 (FIFO First-In First-Out)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="nav-text">先进先出置换算法实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E7%89%B9%E5%BE%81"><span class="nav-text">先进先出置换算法特征</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="nav-text">先进先出置换算法示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95-LRU-Least-Recently-Used"><span class="nav-text">最近最久未使用页面置换算法 (LRU Least Recently Used)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="nav-text">最近最久未使用算法实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%AE%97%E6%B3%95%E7%89%B9%E5%BE%81"><span class="nav-text">最近最久未使用算法特征</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="nav-text">最近最久未使用算法示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%AE%97%E6%B3%95%E5%8F%AF%E8%83%BD%E5%AE%9E%E7%8E%B0"><span class="nav-text">最近最久未使用算法可能实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%AE%97%E6%B3%95%E6%A0%88%E5%AE%9E%E7%8E%B0"><span class="nav-text">最近最久未使用算法栈实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E9%92%9F%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95-Clock"><span class="nav-text">时钟页面置换算法 (Clock)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E7%89%B9%E5%BE%81"><span class="nav-text">时钟置换算法特征</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="nav-text">时钟置换算法实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="nav-text">时钟置换算法示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%94%B9%E8%BF%9B%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-text">改进时钟置换算法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%94%B9%E8%BF%9B%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E5%AE%9E%E4%BE%8B"><span class="nav-text">改进时钟置换算法实例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E4%B8%8D%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95-LFU-Least-Frequently-Used"><span class="nav-text">最不常用算法 (LFU Least Frequently Used)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E4%B8%8D%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="nav-text">最不常用算法实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E4%B8%8D%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E7%89%B9%E5%BE%81"><span class="nav-text">最不常用算法特征</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#LRU-%E5%92%8C-LFU-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">LRU 和 LFU 的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E4%B8%8D%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="nav-text">最不常用算法示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Belady-%E7%8E%B0%E8%B1%A1"><span class="nav-text">Belady 现象</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%A7%E7%94%9F-Belady-%E7%8E%B0%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-text">产生 Belady 现象的原因</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FIFO-%E7%9A%84-Belady-%E7%8E%B0%E8%B1%A1"><span class="nav-text">FIFO 的 Belady 现象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#LRU-%E6%B2%A1%E6%9C%89-Belady-%E7%8E%B0%E8%B1%A1"><span class="nav-text">LRU 没有 Belady 现象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#LRU-FIFO-%E5%92%8C-Clock-%E6%AF%94%E8%BE%83"><span class="nav-text">LRU FIFO 和 Clock 比较</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-text">全局页面置换算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%8D%E8%B6%B3"><span class="nav-text">局部页面置换算法的不足</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E9%9C%80%E8%A6%81%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">全局页面置换算法需要解决的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CPU%E5%88%A9%E7%94%A8%E7%8E%87%E5%92%8C%E5%B9%B6%E5%8F%91%E8%BF%9B%E7%A8%8B%E6%95%B0%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-text">CPU利用率和并发进程数的关系</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E9%9B%86"><span class="nav-text">工作集</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E9%9B%86%E7%9A%84%E5%8F%98%E5%8C%96"><span class="nav-text">工作集的变化</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%B8%E9%A9%BB%E9%9B%86"><span class="nav-text">常驻集</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E9%9B%86%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-text">工作集置换算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E9%9B%86%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="nav-text">工作集置换算法实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E9%9B%86%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="nav-text">工作集置换算法示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E9%A1%B5%E7%8E%87%E7%AE%97%E6%B3%95-PFF-Page-Fault-Frequency"><span class="nav-text">缺页率算法 (PFF Page Fault Frequency)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%BA%E9%A1%B5%E7%8E%87%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="nav-text">缺页率算法实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%BA%E9%A1%B5%E7%8E%87%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="nav-text">缺页率算法示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%96%E5%8A%A8%E5%92%8C%E8%B4%9F%E8%BD%BD%E6%8E%A7%E5%88%B6"><span class="nav-text">抖动和负载控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B4%9F%E8%BD%BD%E6%8E%A7%E5%88%B6"><span class="nav-text">负载控制</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Yuerer" src="/images/avatar.jpeg"><p class="site-author-name" itemprop="name">Yuerer</p><div class="site-description" itemprop="description">钰儿的Blog</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">65</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">16</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">90</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/Yu2erer" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Yu2erer" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:yu2erer#gmail.com" title="E-Mail → mailto:yu2erer#gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://yuerer.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpeg"><meta itemprop="name" content="Yuerer"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Yuerer's Blog"><meta itemprop="description" content="钰儿的Blog"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="操作系统之 虚拟存储页面置换算法 | Yuerer's Blog"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">操作系统之 虚拟存储页面置换算法</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-11-23 18:47:20" itemprop="dateCreated datePublished" datetime="2018-11-23T18:47:20+08:00">2018-11-23</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a> </span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Waline：</span> <a title="waline" href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/" itemprop="commentCount"></span> </a></span><span class="post-meta-item" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="waline-pageview-count" data-path="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/"></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h3 id="页面置换算法概念"><a href="#页面置换算法概念" class="headerlink" title="页面置换算法概念"></a>页面置换算法概念</h3><ul><li>功能<ul><li>当出现缺页异常时 需调入新页面且内存已满 置换算法选择被置换的物理页面</li></ul></li><li>设计目标<ul><li>尽可能地减少页面调入调出次数</li><li>把未来不再访问 或 短期内不访问的页面调出</li></ul></li><li>页面锁定 (Frame locking)<ul><li>描述必须常驻内存的逻辑页面</li><li>操作系统的关键代码</li><li>要求响应速度的代码和数据</li><li>页表中的锁定标志位 (Lock bit)</li></ul></li></ul><span id="more"></span><h3 id="页面置换算法评价方法"><a href="#页面置换算法评价方法" class="headerlink" title="页面置换算法评价方法"></a>页面置换算法评价方法</h3><ul><li>记录进程访问内存的页面轨迹<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">虚拟地址访问用(页号, 位移)表示</span><br><span class="line">(3,0),  (1,9),  (4,1),  (2,1),  (5,3),  (2,0),  (1,9),  (2,4),  (3,1),  (4,8)</span><br><span class="line">对应的页面轨迹</span><br><span class="line">3, 1, 4, 2, 5, 2, 1, 2, 3, 4</span><br><span class="line">替换如 c, a, d, b, e, b, a, b, c, d</span><br></pre></td></tr></table></figure></li><li>评价标准<ul><li>模拟页面置换算法的行为 记录各个置换算法产生缺页的次数 越少越好</li></ul></li></ul><h3 id="局部页面置换算法"><a href="#局部页面置换算法" class="headerlink" title="局部页面置换算法"></a>局部页面置换算法</h3><p>置换页面的选择范围仅限于当前进程占用的物理页面内 (在当前进程中的物理页面来决定换哪个页)</p><ul><li>最优算法 (预测未来来决定 太理想)</li><li>先进先出算法 (先进先出并不一定反映了实际的访问特征 性能较差)</li><li>最近最久未使用算法 (统计过去 假设过去的特征是对未来的预测)<ul><li>时钟算法</li><li>最不常用算法</li></ul></li></ul><h4 id="最优页面置换算法-OPT-optional"><a href="#最优页面置换算法-OPT-optional" class="headerlink" title="最优页面置换算法 (OPT optional)"></a>最优页面置换算法 (OPT optional)</h4><p>置换在未来最长时间不访问页面</p><h5 id="最优页面置换算法实现"><a href="#最优页面置换算法实现" class="headerlink" title="最优页面置换算法实现"></a>最优页面置换算法实现</h5><ul><li>缺页时 计算内存中的每个逻辑页面的下一次访问时间</li><li>选择 未来最长时间 不访问 的页面</li></ul><h5 id="最优页面置换算法特征"><a href="#最优页面置换算法特征" class="headerlink" title="最优页面置换算法特征"></a>最优页面置换算法特征</h5><ul><li>缺页次数最少</li><li>实际系统中无法实现</li><li>无法预知每个页面在下次访问前的等待时间</li><li>但是能作为置换算法性能评测依据</li></ul><h5 id="最优页面置换算法示例"><a href="#最优页面置换算法示例" class="headerlink" title="最优页面置换算法示例"></a>最优页面置换算法示例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第一次 第二次 第三次 第四次都是正常访问的</span><br><span class="line">访问第五次的时候 要访问 e 不在物理内存 产生缺页</span><br><span class="line">缺页异常中断服务例程 引用最优页面置换算法 算出未来最长时间不访问的页面 为 d 它 在 10 的时候访问</span><br><span class="line">将 d页 替换为 e页</span><br><span class="line">一共发生了 两次 缺页异常</span><br></pre></td></tr></table></figure><p><img data-src="/images/OPT_page_replacement_algorithm.png" alt="OPT_page_replacement_algorithm"></p><h4 id="先进先出置换算法-FIFO-First-In-First-Out"><a href="#先进先出置换算法-FIFO-First-In-First-Out" class="headerlink" title="先进先出置换算法 (FIFO First-In First-Out)"></a>先进先出置换算法 (FIFO First-In First-Out)</h4><p>选择在内存中驻留时间 最长的 页面进行置换</p><h5 id="先进先出置换算法实现"><a href="#先进先出置换算法实现" class="headerlink" title="先进先出置换算法实现"></a>先进先出置换算法实现</h5><ul><li>维护一个记录所有位于内存中的逻辑页面的链表</li><li>链表元素按照驻留时间排序 链首最长 链尾最短</li><li>出现缺页时 选择链首页面进行置换 新页面加到链尾</li></ul><h5 id="先进先出置换算法特征"><a href="#先进先出置换算法特征" class="headerlink" title="先进先出置换算法特征"></a>先进先出置换算法特征</h5><ul><li>实现简单</li><li>性能较差 调出的页面很可能是经常访问的</li><li>进程分配物理页面数增加时 缺页不一定减少(Belady 现象)</li><li>有缺陷 不单独使用 揉到其它算法里一起使用</li></ul><h5 id="先进先出置换算法示例"><a href="#先进先出置换算法示例" class="headerlink" title="先进先出置换算法示例"></a>先进先出置换算法示例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一次 第二次 第三次 第四次 都是正常访问</span><br><span class="line">第五次访问 e 出现缺页异常 进入缺页异常中断服务例程 引用先进先出置换算法</span><br><span class="line">因为 物理页帧 a 是最早进来的 按照先进先出的规则 a 换为 e</span><br><span class="line">整个过程 共发生了 五次 缺页异常</span><br></pre></td></tr></table></figure><p><img data-src="/images/FIFO_page_replacement_algorithm.png" alt="FIFO_page_replacement_algorithm"></p><h4 id="最近最久未使用页面置换算法-LRU-Least-Recently-Used"><a href="#最近最久未使用页面置换算法-LRU-Least-Recently-Used" class="headerlink" title="最近最久未使用页面置换算法 (LRU Least Recently Used)"></a>最近最久未使用页面置换算法 (LRU Least Recently Used)</h4><p>属于 最优置换算法 和 先进先出置换算法 的折中</p><ul><li>选择最长时间没有被引用的页面进行置换</li><li>某些页面长时间未被访问 则它们在将来还可能会长时间不会访问</li></ul><h5 id="最近最久未使用算法实现"><a href="#最近最久未使用算法实现" class="headerlink" title="最近最久未使用算法实现"></a>最近最久未使用算法实现</h5><ul><li>缺页时 计算内存中每个逻辑页面的上一次访问时间</li><li>选择上一次使用到当前时间 最长的 页面置换出去</li></ul><h5 id="最近最久未使用算法特征"><a href="#最近最久未使用算法特征" class="headerlink" title="最近最久未使用算法特征"></a>最近最久未使用算法特征</h5><p>最优置换算法的一种近似</p><h5 id="最近最久未使用算法示例"><a href="#最近最久未使用算法示例" class="headerlink" title="最近最久未使用算法示例"></a>最近最久未使用算法示例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一次 第二次 第三次 第四次 都不产生缺页异常</span><br><span class="line">第五次访问 e 产生缺页异常 </span><br><span class="line">过去的时间 c 是最长时间没有被访问的 因此 将 c 换为 e</span><br><span class="line">总共出现 三次 缺页异常</span><br></pre></td></tr></table></figure><p><img data-src="/images/LRU_page_replacement_algorithm.png" alt="LRU_page_replacement_algorithm"></p><h5 id="最近最久未使用算法可能实现"><a href="#最近最久未使用算法可能实现" class="headerlink" title="最近最久未使用算法可能实现"></a>最近最久未使用算法可能实现</h5><p>每次访问开销都很大</p><ul><li>页面链表<ul><li>系统维护一个按最近一次访问时间排序的链表<ul><li>链表首节点是最近刚刚访问过的页面</li><li>链表尾节点是最久未使用的页面</li></ul></li><li>访问内存时 找到相应页面 并将其移到链首</li><li>缺页时 置换链表尾节点的页面</li></ul></li><li>活动页面栈<ul><li>访问时 将页号压入栈顶 并将栈内相同的页号删去</li><li>缺页时 置换栈底页面</li></ul></li></ul><h5 id="最近最久未使用算法栈实现"><a href="#最近最久未使用算法栈实现" class="headerlink" title="最近最久未使用算法栈实现"></a>最近最久未使用算法栈实现</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一 ~ 第四次 相安无事 但要将依次访问过的页 压入栈顶</span><br><span class="line">第五次 访问 e 缺页异常 将栈底 的 c 换为 e</span><br><span class="line">第六次 访问 b 栈里已经有 b 了 将 栈中的 b 删去 再压入栈顶</span><br><span class="line">共 发生 三次 缺页异常</span><br></pre></td></tr></table></figure><p><img data-src="/images/LRU_stack_page_replacement_algorithm.png" alt="LRU_stack_page_replacement_algorithm"></p><h4 id="时钟页面置换算法-Clock"><a href="#时钟页面置换算法-Clock" class="headerlink" title="时钟页面置换算法 (Clock)"></a>时钟页面置换算法 (Clock)</h4><p>仅对页面的访问情况进行大致统计 (统计过去一段时间 这个页面是否被访问过 若访问过则留下 没访问过则按照现有顺序做置换)</p><ul><li>数据结构<ul><li>在页表项加入 访问位 Access 位 描述页面在过去一段时间内访问情况</li><li>各页面组织成环形链表</li><li>指针指向最先调入的页面 后绕着环形链表走 看起来很像 时钟</li></ul></li><li>算法<ul><li>访问页面时 在页表项 记录页面访问情况</li><li>缺页时 从指针处开始顺序查找未被访问过的页表进行置换</li></ul></li></ul><h5 id="时钟置换算法特征"><a href="#时钟置换算法特征" class="headerlink" title="时钟置换算法特征"></a>时钟置换算法特征</h5><p>时钟算法是 LRU(最久未使用算法) 和 FIFO(先进先出算法) 做折中<br>因为它既不像 LRU 考虑的那么详细 又不像 FIFO 只在意一段时间内若不访问 就做置换 考虑的那么粗</p><h5 id="时钟置换算法实现"><a href="#时钟置换算法实现" class="headerlink" title="时钟置换算法实现"></a>时钟置换算法实现</h5><ul><li>页面装入内存时 访问位 置 0</li><li>访问页面 (读&#x2F;写) 时 访问位 置 1</li><li>缺页时 从指针当前位置顺序检查环形链表<ul><li>访问位为 0 则置换此页</li><li>访问位为 1 则访问位置 0 指针继续移动到下一个页面 直到找到可置换页面</li></ul></li></ul><h5 id="时钟置换算法示例"><a href="#时钟置换算法示例" class="headerlink" title="时钟置换算法示例"></a>时钟置换算法示例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一 ~ 第四次访问 的页面都已在环形链表中 故而 只将访问位 置 1</span><br><span class="line">第五次访问 e 缺页异常 指针扫描环形链表 访问位 为 1 的 则置 0 </span><br><span class="line">不断地循环扫描 直至 扫出可置换页面 这里 会循环了一遍以后 将 页面 a 换为 e</span><br><span class="line">一共发生了 四次 缺页异常</span><br></pre></td></tr></table></figure><p><img data-src="/images/Clock_page_replacement_algorithm.png" alt="Clock_page_replacement_algorithm"></p><h5 id="改进时钟置换算法"><a href="#改进时钟置换算法" class="headerlink" title="改进时钟置换算法"></a>改进时钟置换算法</h5><ul><li>时钟置换算法缺点</li></ul><p>之前的时钟置换算法如果要置换的页是被修改过的 那么就会先要将修改过的页 写到外存 然后<br>才将要换入的页读入内存 消耗时间过长</p><ul><li>改进</li></ul><p>减少修改页的缺页处理开销 (如果要置换的页被修改了 则不置换此页 同时操作系统定期将修改过的页写到外存)</p><ul><li>算法<ul><li>在页面中加入修改位 并在访问时 进行相应修改</li><li>缺页时 修改页面标志位 以跳过有修改的页面</li></ul></li></ul><h6 id="改进时钟置换算法实例"><a href="#改进时钟置换算法实例" class="headerlink" title="改进时钟置换算法实例"></a>改进时钟置换算法实例</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一次 只访问 c 访问位 置 1</span><br><span class="line">第二次 写 a 访问位 修改位 都置 1</span><br><span class="line">第三次 访问 d 访问位 置 1</span><br><span class="line">第四次 写 b 访问位 修改位 都 置 1</span><br><span class="line">第五次 访问 e 缺页异常 循环一遍 访问位 为 1 改成 0 访问位 为 0 若 修改位 为 1 改成 0 </span><br><span class="line">最后只会将 c 换 为 e 因为循环下来 a 和 b 页都是被修改过的 跳过 只有 c 访问位和修改位都为 0</span><br><span class="line">共发生 三次 缺页异常</span><br></pre></td></tr></table></figure><p><img data-src="/images/Improved_Clock_page_replacement_algorithm.png" alt="Improved_Clock_page_replacement_algorithm"></p><h4 id="最不常用算法-LFU-Least-Frequently-Used"><a href="#最不常用算法-LFU-Least-Frequently-Used" class="headerlink" title="最不常用算法 (LFU Least Frequently Used)"></a>最不常用算法 (LFU Least Frequently Used)</h4><p>缺页时 置换访问次数最少的页</p><h5 id="最不常用算法实现"><a href="#最不常用算法实现" class="headerlink" title="最不常用算法实现"></a>最不常用算法实现</h5><ul><li>每个页面设置一个访问计数</li><li>访问页数 访问计数 + 1</li><li>缺页时 置换 计数最小的页面</li></ul><h5 id="最不常用算法特征"><a href="#最不常用算法特征" class="headerlink" title="最不常用算法特征"></a>最不常用算法特征</h5><ul><li>算法开销大</li><li>开始时频繁使用 以后不使用的页面难换出 (因为页面在里面待的越久 访问计数越大)<ul><li>解决方法 较大的计数定期右移</li></ul></li></ul><h5 id="LRU-和-LFU-的区别"><a href="#LRU-和-LFU-的区别" class="headerlink" title="LRU 和 LFU 的区别"></a>LRU 和 LFU 的区别</h5><ul><li>LRU 关注多久未使用 时间越短越好 (维护栈)</li><li>LFU 关注次数 待的越久越好 (稍微简单些)</li></ul><h5 id="最不常用算法示例"><a href="#最不常用算法示例" class="headerlink" title="最不常用算法示例"></a>最不常用算法示例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">每次访问 修改 页面的计数 前 四次访问 都只是 累加</span><br><span class="line">到第五次访问 e 缺页异常 寻找当前计数最小的页 为 a 并将其置换</span><br><span class="line">共产生 五次 缺页异常</span><br></pre></td></tr></table></figure><p>LFU 不能够比较快的访问 但是 它可以用在 读取硬盘这种存储访问 时间长一些也没关系</p><p><img data-src="/images/LFU_page_replacement_algorithm.png" alt="LFU_page_replacement_algorithm.png"></p><h4 id="Belady-现象"><a href="#Belady-现象" class="headerlink" title="Belady 现象"></a>Belady 现象</h4><p>采用 FIFO 等算法时 可能出现分配的物理页面数增加 缺页次数反而升高的异常现象</p><h5 id="产生-Belady-现象的原因"><a href="#产生-Belady-现象的原因" class="headerlink" title="产生 Belady 现象的原因"></a>产生 Belady 现象的原因</h5><ul><li>FIFO 算法的置换特征 与 进程访问内存的动态特征矛盾</li><li>被它置换出去的页面 并不一定是 进程 近期不会访问的页面</li></ul><p>总而言之就是预测(近期不访问的页面)不合理</p><h5 id="FIFO-的-Belady-现象"><a href="#FIFO-的-Belady-现象" class="headerlink" title="FIFO 的 Belady 现象"></a>FIFO 的 Belady 现象</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当物理页面数 为 3 时 使用 FIFO 页面置换算法 共产生 9 次 缺页次数</span><br><span class="line">当物理页面数 为 4 时 使用 FIFO 页面置换算法 反而产生了 10 次 缺页次数</span><br></pre></td></tr></table></figure><p><img data-src="/images/FIFO_Belady_3.png" alt="FIFO_Belady_3"></p><p><img data-src="/images/FIFO_Belady_4.png" alt="FIFO_Belady_4"></p><h5 id="LRU-没有-Belady-现象"><a href="#LRU-没有-Belady-现象" class="headerlink" title="LRU 没有 Belady 现象"></a>LRU 没有 Belady 现象</h5><p><img data-src="/images/LRU_No_Belady.png" alt="LRU_No_Belady"></p><h5 id="LRU-FIFO-和-Clock-比较"><a href="#LRU-FIFO-和-Clock-比较" class="headerlink" title="LRU FIFO 和 Clock 比较"></a>LRU FIFO 和 Clock 比较</h5><ul><li>LRU 和 FIFO 本质都是 先进先出算法<ul><li>LRU 根据页面最近访问时间排序</li><li>LRU 需要动态地调整顺序 (算法性能好 系统开销大)</li><li>FIFO 根据页面进入内存的实际排序</li><li>FIFO 的页面进入时间是固定不变的 (系统开销较小 但会发生 Belady 现象)</li></ul></li></ul><p>当页面进入内存后 没有被访问了 最近访问时间和进入内存的时间相同时 LRU 可退化成 FIFO</p><ul><li>Clock 算法是 它们的折中<ul><li>页面访问时 不动态调整页面在链表中的顺序 只是做一个标记</li><li>缺页时 再将它移动到链表末尾 (跳过访问位 为 1 的页面)</li></ul></li></ul><p>对于未被访问的页面 LRU FIFO Clock 性能一样 因为都退化到 FIFO 了<br>对于被访问过的页面 Clock 算法 不能记录准确的访问时间 而 LRU 可以</p><h3 id="全局页面置换算法"><a href="#全局页面置换算法" class="headerlink" title="全局页面置换算法"></a>全局页面置换算法</h3><p>置换页面的选择范围是所有(所有进程)可换出的物理页面 (考虑的角度是从各个进程所需的内存不同)</p><ul><li>工作集算法</li><li>缺页率算法</li></ul><p>给进程分配可变数目的物理页面</p><h4 id="局部页面置换算法的不足"><a href="#局部页面置换算法的不足" class="headerlink" title="局部页面置换算法的不足"></a>局部页面置换算法的不足</h4><p>局部页面置换算法没有考虑进程访存的差异 (进程在不同阶段内存需求是不同的)</p><p>(使用局部页面置换算法 无论怎么置换 物理页面始终是那么多 缺页次数不能减少 如果给它加一些物理页面 性能会提高很多)</p><h4 id="全局页面置换算法需要解决的问题"><a href="#全局页面置换算法需要解决的问题" class="headerlink" title="全局页面置换算法需要解决的问题"></a>全局页面置换算法需要解决的问题</h4><ul><li>进程在不同阶段的内存需求是变化的</li><li>分配给进程的内存也需要在不同阶段有所变化</li><li>全局置换算法需要确定分配给进程的物理页面数</li></ul><h4 id="CPU利用率和并发进程数的关系"><a href="#CPU利用率和并发进程数的关系" class="headerlink" title="CPU利用率和并发进程数的关系"></a>CPU利用率和并发进程数的关系</h4><p><img data-src="/images/CPU_process.png" alt="CPU_process"></p><ul><li>CPU利用率 与 并发进程数存在相互促进和制约的关系<ul><li>进程数少时 提高并发进程数 可提高 CPU利用率</li><li>并发进程导致内存访问增加</li><li>并发进程的内存访问会降低访存局部性特征 (两个进程所做的事情不相干 局部性原理不适用)</li><li>局部性特征下降 缺页率上升和 CPU利用率下降</li></ul></li></ul><h5 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h5><p>一个进程当前正在使用的逻辑页面的集合 可表示为二元函数 W(t, Δ)</p><ul><li>t 是当前的执行时刻</li><li>Δ 为工作集窗口(Working-set window) 一个定长的页面访问时间窗口</li><li>W(t, Δ) 为在当前时刻t前的 Δ 时间窗口中所有访问页面所组成的集合</li><li>| W(t, Δ) | 为工作集大小 页面数量</li></ul><h6 id="工作集的变化"><a href="#工作集的变化" class="headerlink" title="工作集的变化"></a>工作集的变化</h6><p><img data-src="/images/Working_set.png" alt="Working_set"></p><ul><li>进程开始执行后 随着访问新页面逐步建立较稳定的工作集</li><li>当内存访问的局部性区域的位置大致稳定时(只访问那几个页面 没有大的改变时) 工作集大小也大致稳定</li><li>局部性区域的位置改变时(进程前一项事情做完 去做下一项事情时) 工作集快速扩张和快速收缩过渡到下一个稳定值</li></ul><h5 id="常驻集"><a href="#常驻集" class="headerlink" title="常驻集"></a>常驻集</h5><p>在当前时刻 进程实际驻留在内存当中的页面集合</p><ul><li>工作集和常驻集的关系<ul><li>工作集是进程运行过程中固有的性质 (进程在一段时间访问的页面集合)</li><li>常驻集 取决于 系统分配给进程的物理页面数 和 页面置换算法 (实际在内存中的页)</li></ul></li><li>缺页率和常驻集的关系<ul><li>常驻集 包含 工作集时 缺页较少 (进程访问的页都在内存里)</li><li>工作集发送剧烈过渡时 缺页较多</li><li>进程常驻集大小达到一定数目后 缺页率不会明显下降 (内存够进程功能使用了 再去加内存 反而效率下降)</li></ul></li></ul><h4 id="工作集置换算法"><a href="#工作集置换算法" class="headerlink" title="工作集置换算法"></a>工作集置换算法</h4><p>换出不在工作集中的页面 (并不一定是在缺页时才做 因此开销大)</p><h5 id="工作集置换算法实现"><a href="#工作集置换算法实现" class="headerlink" title="工作集置换算法实现"></a>工作集置换算法实现</h5><p>窗口大小 τ 当前时刻前τ个内存访问的页引用是工作集</p><ul><li>访存链表 维护窗口内的访存页面链表</li><li>访存时 换出不在工作集的页面 (开销大)</li><li>缺页时 换入页面</li></ul><h5 id="工作集置换算法示例"><a href="#工作集置换算法示例" class="headerlink" title="工作集置换算法示例"></a>工作集置换算法示例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一次访问 缺页 装入 c 此时 窗口大小 τ 为 4 不需要换出页</span><br><span class="line">第二次访问 不缺页 但是 此时在工作集的 页为 5 而窗口大小 τ 为 4 需要将最早的页 e 放到外存</span><br><span class="line">以此类推</span><br><span class="line">共 发送 五次缺页</span><br></pre></td></tr></table></figure><p><img data-src="/images/Working_set_page_replacement_algorithm.png" alt="Working_set_page_replacement_algorithm"></p><h4 id="缺页率算法-PFF-Page-Fault-Frequency"><a href="#缺页率算法-PFF-Page-Fault-Frequency" class="headerlink" title="缺页率算法 (PFF Page Fault Frequency)"></a>缺页率算法 (PFF Page Fault Frequency)</h4><p>缺页率 (Page fault rate) &#x3D; 缺页次数 &#x2F; 内存访问次数(不好用) 更多时候使用 缺页平均时间间隔的倒数</p><ul><li>影响缺页率因素<ul><li>页面置换算法 (只有这个能自己控制)</li><li>分配给进程的物理页面数</li><li>页面大小</li><li>程序的编写方法 (局部性特征)</li></ul></li></ul><h5 id="缺页率算法实现"><a href="#缺页率算法实现" class="headerlink" title="缺页率算法实现"></a>缺页率算法实现</h5><p>通过调节常驻集的大小 使每个进程的缺页率保持在一个合理的范围</p><ul><li>若进程缺页率过高 则增加常驻集以分配更多物理页面数</li><li>若进程缺页率过低 减少常驻集 将一些页面置换到外存</li></ul><p><img data-src="/images/PFF_process.png" alt="PFF_process"></p><ul><li>访存时 设置引用位标记</li><li>缺页时 计算从上次缺页时间 t_last 到现在 t_current 的时间间隔<ul><li>如果 t_current - t_last &gt; T 缺页率低 则置换 所有在[t_last, t_current]中没有被引用的页 使其用在更有意义的地方(CPU并发率提高)</li><li>如果 t_current - t_last &lt;&#x3D; T 缺页率高 则增加缺失页到常驻集中</li></ul></li></ul><h5 id="缺页率算法示例"><a href="#缺页率算法示例" class="headerlink" title="缺页率算法示例"></a>缺页率算法示例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第一次访问 出现缺页 直接加(因为没有之前状态可供参考) 第二次 第三次 不缺页</span><br><span class="line">第四次 访问 d 出现缺页 时间间隔 为 3 &gt; 窗口大小 2 说明缺页率低 将这段时间没有访问过的页 置换到外存 只将 c 和 d 留下</span><br><span class="line">第五次访问 不缺页 第六次访问 e 缺页异常 时间间隔 为 2 &lt;= 窗口大小 2 直接将 e 加入内存</span><br><span class="line">第七次 第八次 都不缺页 第九次访问 a 缺页异常 时间间隔 为 3 &gt; 窗口大小 2 只留下 c e a 三个页</span><br><span class="line">共 发送 五次 缺页异常</span><br></pre></td></tr></table></figure><p><img data-src="/images/PFF_page_replacement_algorithm.png" alt="PFF_page_replacement_algorithm"><br>跟 工作集算法对比 工作集算法每一次访问都在考虑置换哪一个页面到外存 缺页率算法只有在时间间隔够大的时候 才置换到外存 将置换这一过程放到了 缺页中断来完成<br>和 局部置换算法一样 开销降低</p><h3 id="抖动和负载控制"><a href="#抖动和负载控制" class="headerlink" title="抖动和负载控制"></a>抖动和负载控制</h3><p>抖动产生是因为 随着驻留内存的进程数目增加 分配给每个进程的物理页面数不断减小 缺页率不断上升<br>因此操作系统需在 并发水平 和 缺页率之间达到一个平衡 需要选择一个适当的进程数目 和 进程所需要的物理页面数</p><ul><li>抖动问题(Thrashing)<ul><li>进程物理页面太少 不能包含工作集</li><li>造成大量缺页 频繁置换</li><li>进程运行速度变慢</li></ul></li></ul><h4 id="负载控制"><a href="#负载控制" class="headerlink" title="负载控制"></a>负载控制</h4><p>通过调节并发进程数 (MPL Multiprogramming level) 来进行系统负载控制</p><ul><li>找到 平均缺页间隔时间 (MTBF Mean time between page faults) &#x3D; 缺页异常处理时间 (PFST Page fault service time) 的范围</li></ul><p><img data-src="/images/thrashing.png" alt="thrashing"></p></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"># 操作系统</a> <a href="/tags/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8/" rel="tag"># 虚拟存储</a></div><div class="post-nav"><div class="post-nav-item"><a href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E6%A6%82%E5%BF%B5/" rel="prev" title="操作系统之 虚拟存储概念"><i class="fa fa-angle-left"></i> 操作系统之 虚拟存储概念</a></div><div class="post-nav-item"><a href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-uCore-Lab-3/" rel="next" title="操作系统 uCore Lab 3 含 Challenge">操作系统 uCore Lab 3 含 Challenge <i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Yuerer</span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://unpkg.com/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://unpkg.com/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/comments.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/utils.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/motion.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/sidebar.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/next-boot.min.js"></script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://yuerer-comment-xufei-0bea01e6f05-1307930306.ap-shanghai.app.tcloudbase.com","cssUrl":"https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.css","commentCount":true,"pageview":true,"libUrl":"https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.js","locale":{"placeholder":"有何高见？"},"emoji":["https://unpkg.com/@waline/emojis@1.0.1/qq"],"meta":["nick","mail"],"requiredMeta":[["nick","mail"]],"wordLimit":0,"login":"disable","pageSize":10,"el":"#waline","comment":true,"path":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/"}</script><link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.css"><script>document.addEventListener("page:loaded",()=>{NexT.utils.loadComments(CONFIG.waline.el).then(()=>NexT.utils.getScript(CONFIG.waline.libUrl,{condition:window.Waline})).then(()=>Waline.init(Object.assign({},CONFIG.waline,{el:document.querySelector(CONFIG.waline.el)})))})</script></body></html>