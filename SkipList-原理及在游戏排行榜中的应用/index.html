<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.jpeg"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.ico"><link rel="mask-icon" href="/images/avatar.jpeg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous"><link rel="stylesheet" href="https://unpkg.com/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"yuerer.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"hide","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":true,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/config.min.js"></script><meta name="description" content="近期工作的内容主要是设计一个通用的游戏排行榜服务器, 通用的含义指的是同时为多个项目组提供一套通用的解决方案, 经过不断的调研, 最终写下此文. 本文将会讲述 排行榜的多种实现方式, 不过最终我选择了 SkipList 作为底层的数据结构, 因此会着重讲SkipList. 先来讲一下排行榜的主要功能. 排行榜主要功能 更新&#x2F;删除&#x2F;获取 一个 Key 在某个 排行榜 上的 排名,"><meta property="og:type" content="article"><meta property="og:title" content="SkipList 原理及在游戏排行榜中的应用"><meta property="og:url" content="https://yuerer.com/SkipList-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%9C%A8%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/index.html"><meta property="og:site_name" content="Yuerer&#39;s Blog"><meta property="og:description" content="近期工作的内容主要是设计一个通用的游戏排行榜服务器, 通用的含义指的是同时为多个项目组提供一套通用的解决方案, 经过不断的调研, 最终写下此文. 本文将会讲述 排行榜的多种实现方式, 不过最终我选择了 SkipList 作为底层的数据结构, 因此会着重讲SkipList. 先来讲一下排行榜的主要功能. 排行榜主要功能 更新&#x2F;删除&#x2F;获取 一个 Key 在某个 排行榜 上的 排名,"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2020-09-12T07:05:20.000Z"><meta property="article:modified_time" content="2025-10-21T13:50:52.261Z"><meta property="article:author" content="Yuerer"><meta property="article:tag" content="Redis"><meta property="article:tag" content="SkipList"><meta property="article:tag" content="游戏服务器"><meta property="article:tag" content="排行榜"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://yuerer.com/SkipList-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%9C%A8%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://yuerer.com/SkipList-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%9C%A8%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/","path":"SkipList-原理及在游戏排行榜中的应用/","title":"SkipList 原理及在游戏排行榜中的应用"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>SkipList 原理及在游戏排行榜中的应用 | Yuerer's Blog</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-129491388-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-129491388-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/third-party/analytics/google-analytics.min.js"></script><link rel="dns-prefetch" href="https://yuerer-comment-xufei-0bea01e6f05-1307930306.ap-shanghai.app.tcloudbase.com"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Yuerer's Blog</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">钰儿的Blog</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E8%A1%8C%E6%A6%9C%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD"><span class="nav-text">排行榜主要功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E8%A1%8C%E6%A6%9C%E6%8E%92%E5%BA%8F%E6%96%B9%E6%A1%88"><span class="nav-text">排行榜排序方案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E6%8A%89%E6%8B%A9"><span class="nav-text">数据结构的抉择</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E8%A1%8C%E6%A6%9C%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0"><span class="nav-text">排行榜服务实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SkipList-%E5%8E%9F%E7%90%86"><span class="nav-text">SkipList 原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-%E4%B8%AD-SkipList-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">Redis 中 SkipList 的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Insert-%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="nav-text">Insert 插入操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GetRank-%E8%8E%B7%E5%8F%96%E6%8E%92%E5%90%8D"><span class="nav-text">GetRank 获取排名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GetElementByRank-%E6%A0%B9%E6%8D%AE%E6%8E%92%E5%90%8D%E6%89%BE%E5%AF%B9%E8%B1%A1"><span class="nav-text">GetElementByRank 根据排名找对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E8%A1%8C%E6%A6%9C%E7%9A%84%E5%8F%A6%E7%B1%BB%E5%81%9A%E6%B3%95"><span class="nav-text">排行榜的另类做法</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Yuerer" src="/images/avatar.jpeg"><p class="site-author-name" itemprop="name">Yuerer</p><div class="site-description" itemprop="description">钰儿的Blog</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">65</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">16</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">90</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/Yu2erer" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Yu2erer" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:yu2erer#gmail.com" title="E-Mail → mailto:yu2erer#gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://yuerer.com/SkipList-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%9C%A8%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpeg"><meta itemprop="name" content="Yuerer"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Yuerer's Blog"><meta itemprop="description" content="钰儿的Blog"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="SkipList 原理及在游戏排行榜中的应用 | Yuerer's Blog"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">SkipList 原理及在游戏排行榜中的应用</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-09-12 15:05:20" itemprop="dateCreated datePublished" datetime="2020-09-12T15:05:20+08:00">2020-09-12</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">游戏设计</span></a> </span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Waline：</span> <a title="waline" href="/SkipList-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%9C%A8%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/SkipList-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%9C%A8%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/" itemprop="commentCount"></span> </a></span><span class="post-meta-item" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="waline-pageview-count" data-path="/SkipList-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%9C%A8%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>近期工作的内容主要是设计一个通用的游戏排行榜服务器, 通用的含义指的是同时为多个项目组提供一套通用的解决方案, 经过不断的调研, 最终写下此文.</p><p>本文将会讲述 排行榜的多种实现方式, 不过最终我选择了 SkipList 作为底层的数据结构, 因此会着重讲SkipList.</p><p>先来讲一下排行榜的主要功能.</p><h2 id="排行榜主要功能"><a href="#排行榜主要功能" class="headerlink" title="排行榜主要功能"></a>排行榜主要功能</h2><ul><li>更新&#x2F;删除&#x2F;获取 一个 Key 在某个 排行榜 上的 排名, 及展示信息</li><li>获取 一个排行榜 任意区间(例如排名区间) 的展示信息</li></ul><h2 id="排行榜排序方案"><a href="#排行榜排序方案" class="headerlink" title="排行榜排序方案"></a>排行榜排序方案</h2><p>游戏中的排行榜的排序方案无非就两种</p><ul><li>实时排序, 即玩家数值变化的瞬间, 就完成了对它的排序</li><li>非实时排序, 亦可称之为定时排序, 玩家数据变动不立即排序, 而是直到策划所配的时间点到的时候才进行排序</li></ul><p>这两种排序方案没有好坏之分, 主要是看策划他想要什么? <del>(或许他自己也不知道想要什么, 他都想试试看, 他只顾着他自己)</del></p><span id="more"></span><h2 id="数据结构的抉择"><a href="#数据结构的抉择" class="headerlink" title="数据结构的抉择"></a>数据结构的抉择</h2><p>首先, 因为我们要提供给多个项目组一套解决方案, 每个项目组需要的排序方案大概率是不同的, 因此 排除了定时排序, 如果一开始就往定时排序的思路上想, 到时候哪个项目组突然说要实时排序, 改动起来会非常痛苦, 而且定时排序实现起来比较简单, 直接到点快排就完事了.</p><p>那么 排除了 定时排序, 就只能朝着实时排序的思路上走.</p><p>业界一般采用两种数据结构进行实现</p><ul><li>RB Tree 红黑树<ul><li>优势:<ul><li>时间复杂度的常数相对 SkipList 低</li><li>内存占用也相对较低</li></ul></li><li>不足:<ul><li>实现复杂</li><li>不能方便的获取到某个区间的信息</li></ul></li></ul></li><li>SkipList 跳表<ul><li>和 红黑树 相反</li></ul></li></ul><p>或许 堆也可以加进去, 取topK, 但是超出了k项, 就不知道排名.</p><p>SkipList 在 redis 的有序集合中也有用到, 这时候可能会有人问 为什么你不考虑直接用 redis 呢?</p><p>我考虑的点主要有以下几点</p><ol><li>引入 redis 会增加部署难度</li><li>引入 redis 仅仅只用来做排序, 是不是太笨重了?</li><li>redis 的默认 SkipList 实现是从小到大, 而我们知道一般是分值越靠前的越经常访问, 如果从小到大 查找靠前的效率可能不如从大到小, 但是 redis 写死排序顺序了, 我不开心</li><li>现在游戏服务器为了避免宕机的风险, 都会把服务器拆的特别细, 但是这就会带来一个问题, 本来一件事情能在一个地方集中处理完, 现在要多走几条链路才能做完, 效率会变低, 如果再加入一个 redis, 链路只会更长</li></ol><p>不过, 我们实现的时候可以参考 redis 的 SkipList.</p><h2 id="排行榜服务实现"><a href="#排行榜服务实现" class="headerlink" title="排行榜服务实现"></a>排行榜服务实现</h2><p>首先 我们要抽象出 key 和 value 这两个概念, key 你可以理解为 playerID, 那之所以叫 key 是因为 有的排行榜它不是以角色为单位, 它也有可能是以宠物为单位, 此时的 key 就是 petID. value 就是分值, 不过这里不能简单地就一个分值, 试想一下, 如果分值相同了怎么办?</p><p>以下代码均为伪代码, 随手一写.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Value</span> &#123;</span><br><span class="line">    <span class="type">uint64_t</span> score;</span><br><span class="line">    <span class="comment">// 加入操作时间这一概念, 如果分值相同, 先来排前</span></span><br><span class="line">    <span class="type">int64_t</span> operatorTime;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">    <span class="type">uint64_t</span> key;</span><br><span class="line">    Value value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Data 表示的就是 这个 key 用于排序的信息, 那么这时候有个问题 如果 这个 key 同时出现在 A, B 两个排行榜, 那么 key 就可能造成数据冗余, 占用内存, 这个时候 就要改造 Data 这一 结构.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">    <span class="type">uint64_t</span> key;</span><br><span class="line">    <span class="comment">// Value value;</span></span><br><span class="line">    <span class="comment">// [leaderBoardID, value]</span></span><br><span class="line">    Value unordered_map&lt;<span class="type">uint32_t</span>, Value&gt; value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这时候 如果一个 key 出现在多个排行榜 只需要在 这个 map 里 通过 排行榜ID 去找属于这个排行榜的分值就行了.</p><p>此时又出现了一个问题, player key 和 pet key 有可能相同 通过 key 来查找数据 显然是不合理的.</p><p>这时候就要引入一个 DataType 可以理解为 key 的类型, 它与 排行榜LeaderBoard 绑定在一起.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> DataType;</span><br><span class="line">vector&lt;Data&gt; DataArray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LeaderBoard</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> leaderBoardID;</span><br><span class="line">    DataType dataType;</span><br><span class="line">    <span class="comment">// 真正去排序的 SkipList</span></span><br><span class="line">    SkipList list;</span><br><span class="line">&#125;;</span><br><span class="line">score = DataArray[leaderBoard.dataType].value[leaderboard.leaderBoard.ID].score;</span><br></pre></td></tr></table></figure><p>这样就能通过 排行榜 反查到其旗下的排行信息.</p><p>讲清楚了排行榜的设计, 接下来就是重头戏 SkipList 的实现, 这里我 拿出 Redis 的源码来讲解.</p><h2 id="SkipList-原理"><a href="#SkipList-原理" class="headerlink" title="SkipList 原理"></a>SkipList 原理</h2><p>其实你可以这么理解, 普通的链表 搜索一个东西 要遍历一次 时间复杂度为 O(n), 要想提高搜索速度, 就要尽可能跳过多的节点, 那么给它建多条索引链就行了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">┌────────┐    .─.                .─.               .─.</span><br><span class="line">│  Head  ├──▶(Min───────────────▶ <span class="number">7</span> ──────────────▶<span class="number">99</span> )  Level <span class="number">3</span></span><br><span class="line">└────┬───┘    `─<span class="string">&#x27;                `┬&#x27;</span>               `┬&#x27;</span><br><span class="line">     │                            │                 │</span><br><span class="line">┌────▼───┐    .─.    .─.         .▼.   .─.         .▼.</span><br><span class="line">│  Head  ├──▶(Min──▶( <span class="number">3</span> ────────▶ <span class="number">7</span> ──▶<span class="number">30</span> ────────▶<span class="number">99</span> )  Level <span class="number">2</span></span><br><span class="line">└────┬───┘    `─<span class="string">&#x27;    `┬&#x27;</span>         `┬<span class="string">&#x27;   `┬&#x27;</span>         `┬&#x27;</span><br><span class="line">     │                │           │     │           │</span><br><span class="line">┌────▼───┐    .─.    .▼.   .─.   .▼.   .▼.   .─.   .▼.</span><br><span class="line">│  Head  ├──▶(Min──▶( <span class="number">3</span> ──▶ <span class="number">9</span> ──▶ <span class="number">7</span> ──▶<span class="number">30</span> ──▶<span class="number">90</span> ──▶<span class="number">99</span> )  Level <span class="number">1</span></span><br><span class="line">└────────┘    `─<span class="string">&#x27;    `─&#x27;</span>   `─<span class="string">&#x27;   `─&#x27;</span>   `─<span class="string">&#x27;   `─&#x27;</span>   `─&#x27;</span><br></pre></td></tr></table></figure><p>从最上面的索引链表开始搜 30 的排名 可以像下面这样搜索</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">┌────────┐    .─.                .─.               .─.</span><br><span class="line">│  Head  ├──▶(Min──────<span class="number">3</span>────────▶ <span class="number">7</span> ──────────────▶<span class="number">99</span> )  Level <span class="number">3</span></span><br><span class="line">└────┬───┘    `─<span class="string">&#x27;                `┬&#x27;</span>               `┬&#x27;</span><br><span class="line">	 │                            │                 │</span><br><span class="line">┌────▼───┐    .─.    .─.         .▼.   .─.         .▼.</span><br><span class="line">│  Head  ├──▶(Min──▶( <span class="number">3</span> ────────▶ <span class="number">7</span>  <span class="number">1</span>▶<span class="number">30</span> ────────▶<span class="number">99</span> )  Level <span class="number">2</span></span><br><span class="line">└────┬───┘    `─<span class="string">&#x27;    `┬&#x27;</span>         `┬<span class="string">&#x27;   `┬&#x27;</span>         `┬&#x27;</span><br><span class="line">     │                │           │     │           │</span><br><span class="line">┌────▼───┐    .─.    .▼.   .─.   .▼.   .▼.   .─.   .▼.</span><br><span class="line">│  Head  ├──▶(Min──▶( <span class="number">3</span> ──▶ <span class="number">9</span> ──▶ <span class="number">7</span> ──▶<span class="number">30</span> ──▶<span class="number">90</span> ──▶<span class="number">99</span> )  Level <span class="number">1</span></span><br><span class="line">└────────┘    `─<span class="string">&#x27;    `─&#x27;</span>   `─<span class="string">&#x27;   `─&#x27;</span>   `─<span class="string">&#x27;   `─&#x27;</span>   `─&#x27;</span><br></pre></td></tr></table></figure><p>min 后面 要跨越 span &#x3D; 3 才能到 7, 7要跨越 span &#x3D; 1 才能到 30, 因此 30 从小到大为第四名.</p><p>至此, 我们知道 skiplist 本质就是多个索引 快速查找, 同时维护了一个 span值, 来快速得到 排名</p><h3 id="Redis-中-SkipList-的实现"><a href="#Redis-中-SkipList-的实现" class="headerlink" title="Redis 中 SkipList 的实现"></a>Redis 中 SkipList 的实现</h3><p>首先是要确定, 我们提升一个节点到索引链的概率, 和 要建多少条索引链, redis 中 最大层级为32层, 每次提升节点的概率为 0.25.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ZSKIPLIST_MAXLEVEL 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZSKIPLIST_P 0.25</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">zslRandomLevel</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> level = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((random()&amp;<span class="number">0xFFFF</span>) &lt; (ZSKIPLIST_P * <span class="number">0xFFFF</span>))</span><br><span class="line">        level += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个随机算法, 可以粗略的计算</p><ul><li>层数为 1, 概率为 1 - p</li><li>层数为 2, 概率为 (1 - p)*p</li><li>层数为 3, 概率为 (1 - p)<em>p</em>p</li></ul><p>平均层数为 (1-p)+ (1-p)*p + (1-p)<em>p</em>p + … &#x3D; 1 &#x2F; 1 - p</p><p>如果按照 redis 的提升概率 0.25 来算, 那么空间上膨胀 (4 &#x2F; 3) 即 1.33倍.</p><p>下面来看 SkipList 的定义.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 一个对象, 当分值相同时, 它决定了先后顺序, 可以忽视</span></span><br><span class="line">    robj *obj;</span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="comment">// 回退指针, 其实基本用不上</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="comment">// 每一层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 距离后一个节点要走几步, 用来算 排名</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> span;</span><br><span class="line"></span><br><span class="line">    &#125; level[];</span><br><span class="line"></span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="comment">// 头和尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="comment">// 表中节点的数量, 不然它从小到大排序, 你怎么找最大的?</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    <span class="comment">// 最大层数 不超过 32层</span></span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line"></span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><h3 id="Insert-插入操作"><a href="#Insert-插入操作" class="headerlink" title="Insert 插入操作"></a>Insert 插入操作</h3><p>主要是从最高层, 依次向下找 新来的值应该插入到哪, 然后 保存到 update 这个数组中, 这样就不用每找一层就改一层.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">zskiplistNode *<span class="title function_">zslInsert</span><span class="params">(zskiplist *zsl, <span class="type">double</span> score, robj *obj)</span> &#123;</span><br><span class="line">    zskiplistNode *update[<span class="number">32</span>], *x;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> rank[<span class="number">32</span>];</span><br><span class="line">    <span class="type">int</span> i, level;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最顶层的起始 rank值当然是 0</span></span><br><span class="line">        rank[i] = i == (zsl-&gt;level<span class="number">-1</span>) ? <span class="number">0</span> : rank[i+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从小到大排</span></span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,obj) &lt; <span class="number">0</span>))) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 跨度就是 排名</span></span><br><span class="line">            rank[i] += x-&gt;level[i].span;</span><br><span class="line"></span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    level = zslRandomLevel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化未使用层级</span></span><br><span class="line">    <span class="keyword">if</span> (level &gt; zsl-&gt;level) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = zsl-&gt;level; i &lt; level; i++) &#123;</span><br><span class="line">            rank[i] = <span class="number">0</span>;</span><br><span class="line">            update[i] = zsl-&gt;header;</span><br><span class="line">            update[i]-&gt;level[i].span = zsl-&gt;length;</span><br><span class="line">        &#125;</span><br><span class="line">        zsl-&gt;level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x = zslCreateNode(level,score,obj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把 update 记录的位置, 拿来做修正</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 简单的链表插入操作, 你只需要记住, update[i]-&gt;x-&gt;update[i].forward</span></span><br><span class="line">        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;</span><br><span class="line">        update[i]-&gt;level[i].forward = x;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// rank[0] 是最底层链表的 x 的前一个节点</span></span><br><span class="line">        <span class="comment">// rank[i] 是第i层链表 距离 x 的前一个节点</span></span><br><span class="line">        <span class="comment">// 相当于修复一下 第i层链表距离x的前一个节点的span值</span></span><br><span class="line">        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="number">0</span>] - rank[i]);</span><br><span class="line">        update[i]-&gt;level[i].span = (rank[<span class="number">0</span>] - rank[i]) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = level; i &lt; zsl-&gt;level; i++) &#123;</span><br><span class="line">        update[i]-&gt;level[i].span++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x-&gt;backward = (update[<span class="number">0</span>] == zsl-&gt;header) ? <span class="literal">NULL</span> : update[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward)</span><br><span class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        zsl-&gt;tail = x;</span><br><span class="line"></span><br><span class="line">    zsl-&gt;length++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GetRank-获取排名"><a href="#GetRank-获取排名" class="headerlink" title="GetRank 获取排名"></a>GetRank 获取排名</h3><p>一样从最上层开始找… 然后累计 span 值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">zslGetRank</span><span class="params">(zskiplist *zsl, <span class="type">double</span> score, robj *o)</span> &#123;</span><br><span class="line">    zskiplistNode *x;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rank = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,o) &lt;= <span class="number">0</span>))) &#123;</span><br><span class="line"></span><br><span class="line">            rank += x-&gt;level[i].span;</span><br><span class="line"></span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x-&gt;obj &amp;&amp; equalStringObjects(x-&gt;obj,o)) &#123;</span><br><span class="line">            <span class="keyword">return</span> rank;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GetElementByRank-根据排名找对象"><a href="#GetElementByRank-根据排名找对象" class="headerlink" title="GetElementByRank 根据排名找对象"></a>GetElementByRank 根据排名找对象</h3><p>用 traversed 统计意境走过的步长, 这个思路还是比较清奇的…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">zskiplistNode* <span class="title function_">zslGetElementByRank</span><span class="params">(zskiplist *zsl, <span class="type">unsigned</span> <span class="type">long</span> rank)</span> &#123;</span><br><span class="line">    zskiplistNode *x;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> traversed = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp; (traversed + x-&gt;level[i].span) &lt;= rank)</span><br><span class="line">        &#123;</span><br><span class="line">            traversed += x-&gt;level[i].span;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (traversed == rank) &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没找到目标节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此, Redis 中的 SkipList 已经基本了解完了.</p><h2 id="排行榜的另类做法"><a href="#排行榜的另类做法" class="headerlink" title="排行榜的另类做法"></a>排行榜的另类做法</h2><p>其实如果你知道 玩家的分值的区间, 例如皇室战争的皇冠杯数大致的范围你是知道的, 那你其实可以这么来做</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">uint32_t</span>&gt;&gt; array;</span><br><span class="line">array[皇冠数].<span class="built_in">push_back</span>(👑的key);</span><br><span class="line">这样要取出其排名, 只需要累加前面的 数组就可以了..</span><br><span class="line"></span><br><span class="line">假设 分值为 <span class="number">1</span> - <span class="number">5</span> </span><br><span class="line">[<span class="number">5</span>] [<span class="number">4</span>] [<span class="number">3</span>] [<span class="number">2</span>] [<span class="number">1</span>]</span><br><span class="line">k1  k4  k2  k5  k7</span><br><span class="line">k3      k6</span><br><span class="line"></span><br><span class="line">那你要得到 k2 的排名, 你只需要 累加 [<span class="number">5</span>] + [<span class="number">4</span>] 的大小就能算出来</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Redis/" rel="tag"># Redis</a> <a href="/tags/SkipList/" rel="tag"># SkipList</a> <a href="/tags/%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E5%99%A8/" rel="tag"># 游戏服务器</a> <a href="/tags/%E6%8E%92%E8%A1%8C%E6%A6%9C/" rel="tag"># 排行榜</a></div><div class="post-nav"><div class="post-nav-item"><a href="/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" rel="prev" title="Linux网络编程 I/O多路复用"><i class="fa fa-angle-left"></i> Linux网络编程 I/O多路复用</a></div><div class="post-nav-item"><a href="/Lua5.3-%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0(%E4%B8%80)-Lua%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/" rel="next" title="Lua 5.3 设计实现(一) Lua是怎么跑起来的?">Lua 5.3 设计实现(一) Lua是怎么跑起来的? <i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Yuerer</span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://unpkg.com/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://unpkg.com/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/comments.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/utils.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/motion.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/sidebar.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/next-boot.min.js"></script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://yuerer-comment-xufei-0bea01e6f05-1307930306.ap-shanghai.app.tcloudbase.com","cssUrl":"https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.css","commentCount":true,"pageview":true,"libUrl":"https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.js","locale":{"placeholder":"有何高见？"},"emoji":["https://unpkg.com/@waline/emojis@1.0.1/qq"],"meta":["nick","mail"],"requiredMeta":[["nick","mail"]],"wordLimit":0,"login":"disable","pageSize":10,"el":"#waline","comment":true,"path":"/SkipList-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%9C%A8%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"}</script><link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.css"><script>document.addEventListener("page:loaded",()=>{NexT.utils.loadComments(CONFIG.waline.el).then(()=>NexT.utils.getScript(CONFIG.waline.libUrl,{condition:window.Waline})).then(()=>Waline.init(Object.assign({},CONFIG.waline,{el:document.querySelector(CONFIG.waline.el)})))})</script></body></html>