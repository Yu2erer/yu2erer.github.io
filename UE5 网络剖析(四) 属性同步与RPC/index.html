<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.jpeg"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.ico"><link rel="mask-icon" href="/images/avatar.jpeg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous"><link rel="stylesheet" href="https://unpkg.com/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"yuerer.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"hide","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":true,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/config.min.js"></script><meta name="description" content="本文主要剖析 UE5 网络中是如何进行属性同步和RPC的。 同步 Actor要进行属性同步，首先就要先同步 Actor，但更要知道哪些 Actor 需要网络同步。 哪些 Actor 需要网络同步Actor 需要设置 bReplicates 为 true，才会进行同步， 以 Spawn Pawn 为例，玩家登录之后会由 GameMode 创建 Pawn 实例。 12345678AActor* UWo"><meta property="og:type" content="article"><meta property="og:title" content="UE5 网络剖析(四) 属性同步与RPC"><meta property="og:url" content="https://yuerer.com/UE5%20%E7%BD%91%E7%BB%9C%E5%89%96%E6%9E%90(%E5%9B%9B)%20%E5%B1%9E%E6%80%A7%E5%90%8C%E6%AD%A5%E4%B8%8ERPC/index.html"><meta property="og:site_name" content="Yuerer&#39;s Blog"><meta property="og:description" content="本文主要剖析 UE5 网络中是如何进行属性同步和RPC的。 同步 Actor要进行属性同步，首先就要先同步 Actor，但更要知道哪些 Actor 需要网络同步。 哪些 Actor 需要网络同步Actor 需要设置 bReplicates 为 true，才会进行同步， 以 Spawn Pawn 为例，玩家登录之后会由 GameMode 创建 Pawn 实例。 12345678AActor* UWo"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://yuerer.com/images/UE5_network_replicator1.png"><meta property="og:image" content="https://yuerer.com/images/UE5_network_replicator2.png"><meta property="og:image" content="https://yuerer.com/images/UE5_network_replicator3.png"><meta property="og:image" content="https://yuerer.com/images/UE5_network_replicator4.png"><meta property="article:published_time" content="2024-12-07T02:59:20.000Z"><meta property="article:modified_time" content="2025-10-21T13:50:52.263Z"><meta property="article:author" content="Yuerer"><meta property="article:tag" content="UE5"><meta property="article:tag" content="网络"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://yuerer.com/images/UE5_network_replicator1.png"><link rel="canonical" href="https://yuerer.com/UE5%20%E7%BD%91%E7%BB%9C%E5%89%96%E6%9E%90(%E5%9B%9B)%20%E5%B1%9E%E6%80%A7%E5%90%8C%E6%AD%A5%E4%B8%8ERPC/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://yuerer.com/UE5%20%E7%BD%91%E7%BB%9C%E5%89%96%E6%9E%90(%E5%9B%9B)%20%E5%B1%9E%E6%80%A7%E5%90%8C%E6%AD%A5%E4%B8%8ERPC/","path":"UE5 网络剖析(四) 属性同步与RPC/","title":"UE5 网络剖析(四) 属性同步与RPC"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>UE5 网络剖析(四) 属性同步与RPC | Yuerer's Blog</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-129491388-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-129491388-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/third-party/analytics/google-analytics.min.js"></script><link rel="dns-prefetch" href="https://yuerer-comment-xufei-0bea01e6f05-1307930306.ap-shanghai.app.tcloudbase.com"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Yuerer's Blog</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">钰儿的Blog</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5-Actor"><span class="nav-text">同步 Actor</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%AA%E4%BA%9B-Actor-%E9%9C%80%E8%A6%81%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5"><span class="nav-text">哪些 Actor 需要网络同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%93%E5%89%8D%E5%B8%A7%E8%A6%81%E5%90%8C%E6%AD%A5%E5%93%AA%E4%BA%9B-Actor"><span class="nav-text">当前帧要同步哪些 Actor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96-Actor"><span class="nav-text">序列化 Actor</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E5%90%8C%E6%AD%A5"><span class="nav-text">属性同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%BE%E5%87%BA%E9%9C%80%E8%A6%81%E5%90%8C%E6%AD%A5%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-text">找出需要同步的属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%AF%8F%E4%B8%AA%E5%B1%9E%E6%80%A7%E5%9C%A8-ShadowBuffer-%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="nav-text">计算每个属性在 ShadowBuffer 的位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%90%86%E8%A7%A3%E5%90%8C%E6%AD%A5%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%89%80%E9%9C%80%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">理解同步过程中所需的数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AF%94%E8%BE%83%E5%B1%9E%E6%80%A7"><span class="nav-text">比较属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E5%8F%98%E6%9B%B4%E5%B1%9E%E6%80%A7"><span class="nav-text">发送变更属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E5%90%8C%E6%AD%A5%E4%B8%A2%E5%8C%85"><span class="nav-text">属性同步丢包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E6%8C%87%E9%92%88"><span class="nav-text">同步指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RPC"><span class="nav-text">RPC</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Yuerer" src="/images/avatar.jpeg"><p class="site-author-name" itemprop="name">Yuerer</p><div class="site-description" itemprop="description">钰儿的Blog</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">65</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">16</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">90</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/Yu2erer" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Yu2erer" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:yu2erer#gmail.com" title="E-Mail → mailto:yu2erer#gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://yuerer.com/UE5%20%E7%BD%91%E7%BB%9C%E5%89%96%E6%9E%90(%E5%9B%9B)%20%E5%B1%9E%E6%80%A7%E5%90%8C%E6%AD%A5%E4%B8%8ERPC/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpeg"><meta itemprop="name" content="Yuerer"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Yuerer's Blog"><meta itemprop="description" content="钰儿的Blog"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="UE5 网络剖析(四) 属性同步与RPC | Yuerer's Blog"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">UE5 网络剖析(四) 属性同步与RPC</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2024-12-07 10:59:20" itemprop="dateCreated datePublished" datetime="2024-12-07T10:59:20+08:00">2024-12-07</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UE/" itemprop="url" rel="index"><span itemprop="name">UE</span></a> </span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Waline：</span> <a title="waline" href="/UE5%20%E7%BD%91%E7%BB%9C%E5%89%96%E6%9E%90(%E5%9B%9B)%20%E5%B1%9E%E6%80%A7%E5%90%8C%E6%AD%A5%E4%B8%8ERPC/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/UE5%20%E7%BD%91%E7%BB%9C%E5%89%96%E6%9E%90(%E5%9B%9B)%20%E5%B1%9E%E6%80%A7%E5%90%8C%E6%AD%A5%E4%B8%8ERPC/" itemprop="commentCount"></span> </a></span><span class="post-meta-item" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="waline-pageview-count" data-path="/UE5%20%E7%BD%91%E7%BB%9C%E5%89%96%E6%9E%90(%E5%9B%9B)%20%E5%B1%9E%E6%80%A7%E5%90%8C%E6%AD%A5%E4%B8%8ERPC/"></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>本文主要剖析 UE5 网络中是如何进行属性同步和RPC的。</p><h2 id="同步-Actor"><a href="#同步-Actor" class="headerlink" title="同步 Actor"></a>同步 Actor</h2><p>要进行属性同步，首先就要先同步 Actor，但更要知道哪些 Actor 需要网络同步。</p><h3 id="哪些-Actor-需要网络同步"><a href="#哪些-Actor-需要网络同步" class="headerlink" title="哪些 Actor 需要网络同步"></a>哪些 Actor 需要网络同步</h3><p>Actor 需要设置 <code>bReplicates</code> 为 true，才会进行同步，</p><p>以 Spawn Pawn 为例，玩家登录之后会由 <code>GameMode</code> 创建 Pawn 实例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AActor* <span class="title">UWorld::SpawnActor</span><span class="params">( UClass* Class, FVector <span class="type">const</span>* Location, FRotator <span class="type">const</span>* Rotation, <span class="type">const</span> FActorSpawnParameters&amp; SpawnParameters )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    AActor* <span class="type">const</span> Actor = <span class="built_in">NewObject</span>&lt;AActor&gt;(LevelToSpawnIn, Class, NewActorName, ActorFlags, Template, <span class="literal">false</span><span class="comment">/*bCopyTransientsFromClassDefaults*/</span>, <span class="literal">nullptr</span><span class="comment">/*InInstanceGraph*/</span>, ExternalPackage);</span><br><span class="line">    <span class="comment">// Add this newly spawned actor to the network actor list. Do this after PostSpawnInitialize so that actor has &quot;finished&quot; spawning.</span></span><br><span class="line">    <span class="built_in">AddNetworkActor</span>( Actor );</span><br><span class="line">    <span class="keyword">return</span> Actor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若 <code>bReplicates</code> 为 true，则 RemoteRole 为 ROLE_SimulatedProxy，表示是远端为模拟代理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AActor::PostInitProperties</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">PostInitProperties</span>();</span><br><span class="line">    RemoteRole = (bReplicates ? ROLE_SimulatedProxy : ROLE_None);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将需要同步的 Actor 加入到 NetDriver中的一个集合里， 至此就找到了要网络同步的 Actor，需要注意一点是 <code>Replicate</code> 是支持动态开关的。</p><span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UNetDriver::AddNetworkActor</span><span class="params">(AActor* Actor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">IsDormInitialStartupActor</span>(Actor))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">GetNetworkObjectList</span>().<span class="built_in">FindOrAdd</span>(Actor, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="当前帧要同步哪些-Actor"><a href="#当前帧要同步哪些-Actor" class="headerlink" title="当前帧要同步哪些 Actor"></a>当前帧要同步哪些 Actor</h3><p>找出了所有要网络同步的 Actor 后，就需要确认当前帧要同步哪些 Actor，毕竟不可能每帧都同步所有 Actor，带宽和计算成本都接受不了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UNetDriver::TickFlush</span><span class="params">(<span class="type">float</span> DeltaSeconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ServerReplicateActors</span>(DeltaSeconds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过代码裁剪，得出以下核心代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">int32 <span class="title">UNetDriver::ServerReplicateActors</span><span class="params">(<span class="type">float</span> DeltaSeconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> int32 NumClientsToTick = <span class="built_in">ServerReplicateActors_PrepConnections</span>( DeltaSeconds );</span><br><span class="line">    <span class="comment">// Build the consider list (actors that are ready to replicate)</span></span><br><span class="line">    <span class="built_in">ServerReplicateActors_BuildConsiderList</span>( ConsiderList, ServerTickTime );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( int32 i=<span class="number">0</span>; i &lt; ClientConnections.<span class="built_in">Num</span>(); i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">bool</span> bProcessConsiderListIsBound = OnProcessConsiderListOverride.<span class="built_in">IsBound</span>();</span><br><span class="line">        <span class="keyword">if</span> (Connection-&gt;ViewTarget)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!bProcessConsiderListIsBound)</span><br><span class="line">            &#123;</span><br><span class="line">                FActorPriority* PriorityList = <span class="literal">NULL</span>;</span><br><span class="line">                FActorPriority** PriorityActors = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Get a sorted list of actors for this connection</span></span><br><span class="line">                <span class="type">const</span> int32 FinalSortedCount = <span class="built_in">ServerReplicateActors_PrioritizeActors</span>(Connection, ConnectionViewers, ConsiderList, bCPUSaturated, PriorityList, PriorityActors);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Process the sorted list of actors for this connection</span></span><br><span class="line">                <span class="function">TInterval&lt;int32&gt; <span class="title">ActorsIndexRange</span><span class="params">(<span class="number">0</span>, FinalSortedCount)</span></span>;</span><br><span class="line">                <span class="type">const</span> int32 LastProcessedActor = <span class="built_in">ServerReplicateActors_ProcessPrioritizedActorsRange</span>(Connection, ConnectionViewers, PriorityActors, ActorsIndexRange, Updated);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">ServerReplicateActors_MarkRelevantActors</span>(Connection, ConnectionViewers, LastProcessedActor, FinalSortedCount, PriorityActors);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ServerReplicateActors_PrepConnections</code> 是用于计算此处需要给几个客户端同步，通常用于 <code>ListenServer</code> ，因为玩家的机器通常性能不会太好，而 <code>Dedicated Server</code> 当然是选择给所有客户端全部同步，因此此处逻辑不重要。</p><p><code>ServerReplicateActors_BuildConsiderList</code> 看名字就能猜到，是计算哪些 Actor 可以被纳入考虑同步名单，主要是根据检查 Actor 的一些属性，比如该 Actor所属 NetDriver 和当前 NetDriver 是否一致，是否即将被删除。</p><p>有了考虑名单，就要根据优先级来排序 Actor， <code>ServerReplicateActors_PrioritizeActors</code> 就是来做这一部分工作的，其中会调用 <code>Actor::IsNetRelevantFor</code> 和 <code>AActor::GetNetPriority</code> 。</p><p><code>Actor::IsNetRelevantFor</code> 是检查该 Actor 是否和当前 观察者 是否相关的，比如 <code>NetCullDistanceSquared</code> 这个参数就是在此刻用上的，检查和观察者的距离。</p><p><code>AActor::GetNetPriority</code> 是获取 Actor 网络优先级，这部分逻辑比较有趣，所以单独拉出来看看。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">AActor::GetNetPriority</span><span class="params">(<span class="type">const</span> FVector&amp; ViewPos, <span class="type">const</span> FVector&amp; ViewDir, AActor* Viewer, AActor* ViewTarget, UActorChannel* InChannel, <span class="type">float</span> Time, <span class="type">bool</span> bLowBandwidth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bNetUseOwnerRelevancy &amp;&amp; Owner)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// If we should use our owner&#x27;s priority, pass it through</span></span><br><span class="line">        <span class="keyword">return</span> Owner-&gt;<span class="built_in">GetNetPriority</span>(ViewPos, ViewDir, Viewer, ViewTarget, InChannel, Time, bLowBandwidth);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ViewTarget &amp;&amp; (<span class="keyword">this</span> == ViewTarget || <span class="built_in">GetInstigator</span>() == ViewTarget))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// If we&#x27;re the view target or owned by the view target, use a high priority</span></span><br><span class="line">        Time *= <span class="number">4.f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">IsHidden</span>() &amp;&amp; <span class="built_in">GetRootComponent</span>() != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// If this actor has a location, adjust priority based on location</span></span><br><span class="line">        FVector Dir = <span class="built_in">GetActorLocation</span>() - ViewPos;</span><br><span class="line">        <span class="type">float</span> DistSq = Dir.<span class="built_in">SizeSquared</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Adjust priority based on distance and whether actor is in front of viewer</span></span><br><span class="line">        <span class="keyword">if</span> ((ViewDir | Dir) &lt; <span class="number">0.f</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (DistSq &gt; NEARSIGHTTHRESHOLDSQUARED)</span><br><span class="line">            &#123;</span><br><span class="line">                Time *= <span class="number">0.2f</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (DistSq &gt; CLOSEPROXIMITYSQUARED)</span><br><span class="line">            &#123;</span><br><span class="line">                Time *= <span class="number">0.4f</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((DistSq &lt; FARSIGHTTHRESHOLDSQUARED) &amp;&amp; (FMath::<span class="built_in">Square</span>(ViewDir | Dir) &gt; <span class="number">0.5f</span> * DistSq))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Compute the amount of distance along the ViewDir vector. Dir is not normalized</span></span><br><span class="line">            <span class="comment">// Increase priority if we&#x27;re being looked directly at</span></span><br><span class="line">            Time *= <span class="number">2.f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (DistSq &gt; MEDSIGHTTHRESHOLDSQUARED)</span><br><span class="line">        &#123;</span><br><span class="line">            Time *= <span class="number">0.4f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NetPriority * Time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认会根据 Actor 处于观察者的位置来计算优先级，如果 DotProduct &lt; 0 则是背面，根据距离来调整优先级，若在正面，且视线相近则放大。</p><p>前面几篇提到过，Actor 是基于 ActorChannel 同步的，服务端需要通知客户端创建一个 ActorChannel，然后专门为该 Actor 进行同步。</p><p>首次同步，会为该 Actor 在本地创建 ActorChannel。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">int32 <span class="title">UNetDriver::ServerReplicateActors_ProcessPrioritizedActorsRange</span><span class="params">( UNetConnection* Connection, <span class="type">const</span> TArray&lt;FNetViewer&gt;&amp; ConnectionViewers, FActorPriority** PriorityActors, <span class="type">const</span> TInterval&lt;int32&gt;&amp; ActorsIndexRange, int32&amp; OutUpdated, <span class="type">bool</span> bIgnoreSaturation )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (...)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Create a new channel for this actor.</span></span><br><span class="line">        Channel = (UActorChannel*)Connection-&gt;<span class="built_in">CreateChannelByName</span>( NAME_Actor, EChannelCreateFlags::OpenedLocally );</span><br><span class="line">        <span class="keyword">if</span> ( Channel )</span><br><span class="line">        &#123;</span><br><span class="line">            Channel-&gt;<span class="built_in">SetChannelActor</span>(Actor, ESetChannelActorFlags::None);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( Channel-&gt;<span class="built_in">ReplicateActor</span>() )</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SetChannelActor</code> 是属性同步和RPC的重点，但此处先跳过，后面会回来。但至少现在，已经找出当前帧要同步的 Actor，并为它创建了本地 ActorChannel。</p><h3 id="序列化-Actor"><a href="#序列化-Actor" class="headerlink" title="序列化 Actor"></a>序列化 Actor</h3><p>同步一个东西通常都是用序列化的方式进行，UE5 也不例外，调用 <code>Channel-&gt;ReplicateActor()</code> ，进而使用 PackageMapClient 来序列化 Actor。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">int64 <span class="title">UActorChannel::ReplicateActor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (RepFlags.bNetInitial &amp;&amp; OpenedLocally)</span><br><span class="line">    &#123;</span><br><span class="line">        Connection-&gt;PackageMap-&gt;<span class="built_in">SerializeNewActor</span>(Bunch, <span class="keyword">this</span>, <span class="built_in">static_cast</span>&lt;AActor*&amp;&gt;(Actor));</span><br><span class="line">        bWroteSomethingImportant = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        Actor-&gt;<span class="built_in">OnSerializeNewActor</span>(Bunch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PackageMapClient</code> 在网络剖析的前面几篇提到过，每个连接有一个，就是专门用来序列化 Actor 的。</p><p>在深入序列化 Actor 之前，需要先了解 <code>NetGUID</code> ，这是用于表示某个 Object 的，无论在客户端还是服务端都是相同的，都能够指向同一个对象。</p><p>简单看一下 <code>NetGUID</code> 分配方式，根据是否为动态对象，划分出两个数组，每次分配都是递增。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FNetworkGUID <span class="title">FNetGUIDCache::AssignNewNetGUID_Server</span><span class="params">( UObject* Object )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Generate new NetGUID and assign it</span></span><br><span class="line">    <span class="type">const</span> int32 IsStatic = <span class="built_in">IsDynamicObject</span>( Object ) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> FNetworkGUID NewNetGuid = FNetworkGUID::<span class="built_in">CreateFromIndex</span>(++NetworkGuidIndex[IsStatic], IsStatic != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RegisterNetGUID_Server</span>( NewNetGuid, Object );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NewNetGuid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> FNetworkGUID <span class="title">CreateFromIndex</span><span class="params">(uint64 NetIndex, <span class="type">bool</span> bIsStatic)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FNetworkGUID NewGuid;</span><br><span class="line">    NewGuid.ObjectId = NetIndex &lt;&lt; <span class="number">1</span> | (bIsStatic ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NewGuid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>序列化 Actor 是一个递归的过程，为了方便后续的理解，这里简单阐述一下序列化的过程。</p><p>比如我们要序列化一个已经 Spawn 的 Actor，最直观的思路就是序列化当前 Actor 的一些属性，比如位置，旋转，速度，但这样实际上还不够，因为对方还不知道这个 Actor 是基于什么东西构造出来的，应该还要序列化出它的 CDO 类，CDO 可以理解为这个 Actor 的原型，根据这个原型 Archetype 实例化出这个 Actor，这个原型要么是 C++文件，要么是蓝图文件，所以是一定有路径的，因此要想序列化 Actor，需要先把它的原型给序列化好，不然就找不到它的原型无法构造它出来，在代码结构中称之为 ObjOuter。</p><p>因此序列化 Actor，会先打入 Actor 的 GUID，然后打入 Actor→Outer 的 GUID，发现 Outer 对端也没有收到过，这时就会打入 Outer 的路径，最后才是当前 Actor 的路径。</p><p>从发的角度可能很难理解，但是从客户端接收的角度就会好理解些，先是收到 Actor 的 GUID，暂存下来，然后递归函数继续收到 Actor 的 Outer 的 GUID 也暂存下来，继续递归发现没有新的 GUID 了，返回，开始读取 Outer 的路径，路径读完，返回递归，最后读取 Actor 的其他信息。</p><p>总之先是知道儿子的名字，然后查一下父亲的名字和地址，构造完父亲后，此时数据流中就只剩下儿子的地址，就可以构造出儿子。</p><p>简单结构如下(省略其他属性)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Character GUID | BP_Characer GUID | BP_Character Path | Character Path | Character localtion ...</span><br></pre></td></tr></table></figure><p><code>UActorChannel::ReplicateActor</code> 调用 <code>UPackageMapClient::SerializeNewActor</code> 开始序列化一个 Actor。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">UPackageMapClient::SerializeNewActor</span><span class="params">(FArchive&amp; Ar, <span class="keyword">class</span> UActorChannel *Channel, <span class="keyword">class</span> AActor*&amp; Actor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FNetworkGUID NetGUID;</span><br><span class="line">    UObject *NewObj = Actor;</span><br><span class="line">    <span class="built_in">SerializeObject</span>(Ar, AActor::<span class="built_in">StaticClass</span>(), NewObj, &amp;NetGUID);</span><br><span class="line">    Channel-&gt;ActorNetGUID = NetGUID;</span><br><span class="line"></span><br><span class="line">    Actor = <span class="built_in">Cast</span>&lt;AActor&gt;(NewObj);</span><br><span class="line">    <span class="keyword">if</span> ( NetGUID.<span class="built_in">IsDynamic</span>() )</span><br><span class="line">    &#123;</span><br><span class="line">        UObject* Archetype = <span class="literal">nullptr</span>;</span><br><span class="line">        UObject* ActorLevel = <span class="literal">nullptr</span>;</span><br><span class="line">        FVector Location = FVector::ZeroVector;</span><br><span class="line">        FVector Scale = FVector::OneVector;</span><br><span class="line">        FVector Velocity = FVector::ZeroVector;</span><br><span class="line">        FRotator Rotation = FRotator::ZeroRotator;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>InternalWriteObject</code> 会写入当前 Actor 信息，但是此时由于还未处于 导出 NetGUID 模式下，所以只会简单写入 GUID。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">UPackageMapClient::SerializeObject</span><span class="params">( FArchive&amp; Ar, UClass* Class, UObject*&amp; Object, FNetworkGUID *OutNetGUID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Ar.<span class="built_in">IsSaving</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        FNetworkGUID NetGUID = GuidCache-&gt;<span class="built_in">GetOrAssignNetGUID</span>( Object );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out NetGUID to caller if necessary</span></span><br><span class="line">        <span class="keyword">if</span> (OutNetGUID)</span><br><span class="line">        &#123;</span><br><span class="line">            *OutNetGUID = NetGUID;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write object NetGUID to the given FArchive</span></span><br><span class="line">        <span class="built_in">InternalWriteObject</span>( Ar, NetGUID, Object, <span class="built_in">TEXT</span>( <span class="string">&quot;&quot;</span> ), <span class="literal">NULL</span> );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we need to export this GUID (its new or hasnt been ACKd, do so here)</span></span><br><span class="line">        <span class="keyword">if</span> (!NetGUID.<span class="built_in">IsDefault</span>() &amp;&amp; Object &amp;&amp; <span class="built_in">ShouldSendFullPath</span>(Object, NetGUID))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( !<span class="built_in">ExportNetGUID</span>( NetGUID, Object, <span class="built_in">TEXT</span>(<span class="string">&quot;&quot;</span>), <span class="literal">NULL</span> ) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">UE_LOG</span>( LogNetPackageMap, Verbose, <span class="built_in">TEXT</span>( <span class="string">&quot;Failed to export in ::SerializeObject %s&quot;</span>), *Object-&gt;<span class="built_in">GetName</span>() );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>!NetGUID.IsValid()</code> 说明已经写完了，没有更外层的对象需要序列化， <code>IsExportingNetGUIDBunch</code> 为 true 时才会一层层导出 Actor，该变量在 <code>ExportNetGUID</code> 中被设置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UPackageMapClient::InternalWriteObject</span><span class="params">(FArchive &amp; Ar, FNetworkGUID NetGUID, UObject* Object, FString ObjectPathName, UObject* ObjectOuter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Ar &lt;&lt; NetGUID;</span><br><span class="line">    <span class="built_in">NET_CHECKSUM</span>(Ar);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!NetGUID.<span class="built_in">IsValid</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// We&#x27;re done writing</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write export flags</span></span><br><span class="line">    <span class="comment">//   note: Default NetGUID is implied to always send path</span></span><br><span class="line">    FExportFlags ExportFlags;</span><br><span class="line"></span><br><span class="line">    ExportFlags.bHasNetworkChecksum = (GuidCache-&gt;NetworkChecksumMode != FNetGUIDCache::ENetworkChecksumMode::None) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (NetGUID.<span class="built_in">IsDefault</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Only the client sends default guids</span></span><br><span class="line">        <span class="built_in">check</span>(!<span class="built_in">IsNetGUIDAuthority</span>());</span><br><span class="line">        ExportFlags.bHasPath = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        Ar &lt;&lt; ExportFlags.Value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (GuidCache-&gt;IsExportingNetGUIDBunch)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Only the server should be exporting guids</span></span><br><span class="line">        <span class="built_in">check</span>(<span class="built_in">IsNetGUIDAuthority</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Object != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ExportFlags.bHasPath = <span class="built_in">ShouldSendFullPath</span>(Object, NetGUID) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ExportFlags.bHasPath = ObjectPathName.<span class="built_in">IsEmpty</span>() ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ExportFlags.bNoLoad	= bNoLoad ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Ar &lt;&lt; ExportFlags.Value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ExportFlags.bHasPath)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Object != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// If the object isn&#x27;t nullptr, expect an empty path name, then fill it out with the actual info</span></span><br><span class="line">            <span class="built_in">check</span>(ObjectOuter == <span class="literal">nullptr</span>);</span><br><span class="line">            <span class="built_in">check</span>(ObjectPathName.<span class="built_in">IsEmpty</span>());</span><br><span class="line">            ObjectPathName = Object-&gt;<span class="built_in">GetName</span>();</span><br><span class="line">            ObjectOuter = Object-&gt;<span class="built_in">GetOuter</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">bool</span> bIsPackage = (NetGUID.<span class="built_in">IsStatic</span>() &amp;&amp; Object != <span class="literal">nullptr</span> &amp;&amp; Object-&gt;<span class="built_in">GetOuter</span>() == <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Serialize reference to outer. This is basically a form of compression.</span></span><br><span class="line">        FNetworkGUID OuterNetGUID = GuidCache-&gt;<span class="built_in">GetOrAssignNetGUID</span>(ObjectOuter);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">InternalWriteObject</span>(Ar, OuterNetGUID, ObjectOuter, <span class="built_in">TEXT</span>( <span class="string">&quot;&quot;</span> ), <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后是导出的 NetGUID 会被放入到 <code>ExportBunches</code> ，发送 Bunch 时，如果这里有值，则会将它放到 Bunch 的最前面发送出去。</p><p>到这里 Actor 同步的主要流程就都清楚了，后续就是补充上面未提到的一些东西。在首次序列化 Actor 时 允许重写 OnSerializeNewActor 来追加你想传递的信息，比如 PlayerController 就追加了 <code>NetPlayerIndex</code> ，当首次同步 Actor 时，可以通过 <code>OnActorChannelOpen</code> 将其读出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	* SerializeNewActor has just been called on the actor before network replication (server side)</span></span><br><span class="line"><span class="comment">	* @param OutBunch Bunch containing serialized contents of actor prior to replication</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">AActor::OnSerializeNewActor</span><span class="params">(<span class="keyword">class</span> FOutBunch&amp; OutBunch)</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	* Allows for a specific response from the actor when the actor channel is opened (client side)</span></span><br><span class="line"><span class="comment">	* @param InBunch Bunch received at time of open</span></span><br><span class="line"><span class="comment">	* @param Connection the connection associated with this actor</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">AActor::OnActorChannelOpen</span><span class="params">(<span class="keyword">class</span> FInBunch&amp; InBunch, <span class="keyword">class</span> UNetConnection* Connection)</span> </span>&#123;&#125;;</span><br></pre></td></tr></table></figure><p>读取同步 Actor 的 Bunch逻辑在 <code>void UActorChannel::ProcessBunch( FInBunch &amp; Bunch )</code> 此处就不再重复了，都是同样的几个函数，根据 Ar 读取写入模式来区分逻辑。</p><h2 id="属性同步"><a href="#属性同步" class="headerlink" title="属性同步"></a>属性同步</h2><p>属性同步的前提是要感知属性的变化，通常比较麻烦的做法就是每次修改完某个属性，就手动置脏，这种方式麻烦，但是性能高，因此 UE4.25 也支持了这个功能，叫做 push model。还有一种常见做法就是设置回调，每次修改属性时触发修改回调，来感知该属性的变化，通常在 <code>lua</code> <code>C#</code> 这类语言中比较好实现。UE5的框架采用了一种更特殊的方式，即直接对比前后两次的内存。</p><p>要想实现对比前后两次的内存，首先就需要找到什么字段需要同步，以及需要同步的字段所在Actor中的内存地址。</p><p><img data-src="/images/UE5_network_replicator1.png" alt="UE5_network_replicator1.png"></p><h3 id="找出需要同步的属性"><a href="#找出需要同步的属性" class="headerlink" title="找出需要同步的属性"></a>找出需要同步的属性</h3><p><code>FRepLayout</code> 就是来记录 Replicator 属性布局的，从它的函数声明中就可以看出，它可以根据 Class、Struct、Function 中构造出来，Function 就是后面要提到的 RPC。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Creates a new FRepLayout for the given class. */</span></span><br><span class="line"><span class="function">ENGINE_API <span class="type">static</span> TSharedPtr&lt;FRepLayout&gt; <span class="title">CreateFromClass</span><span class="params">(UClass* InObjectClass, <span class="type">const</span> UNetConnection* ServerConnection = <span class="literal">nullptr</span>, <span class="type">const</span> ECreateRepLayoutFlags Flags = ECreateRepLayoutFlags::None)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Creates a new FRepLayout for the given struct. */</span></span><br><span class="line"><span class="function">ENGINE_API <span class="type">static</span> TSharedPtr&lt;FRepLayout&gt; <span class="title">CreateFromStruct</span><span class="params">(UStruct * InStruct, <span class="type">const</span> UNetConnection* ServerConnection = <span class="literal">nullptr</span>, <span class="type">const</span> ECreateRepLayoutFlags Flags = ECreateRepLayoutFlags::None)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Creates a new FRepLayout for the given function. */</span></span><br><span class="line"><span class="function"><span class="type">static</span> TSharedPtr&lt;FRepLayout&gt; <span class="title">CreateFromFunction</span><span class="params">(UFunction* InFunction, <span class="type">const</span> UNetConnection* ServerConnection = <span class="literal">nullptr</span>, <span class="type">const</span> ECreateRepLayoutFlags Flags = ECreateRepLayoutFlags::None)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TSharedPtr&lt;FRepLayout&gt; <span class="title">FRepLayout::CreateFromClass</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    UClass* InClass,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> UNetConnection* ServerConnection,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> ECreateRepLayoutFlags CreateFlags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TSharedPtr&lt;FRepLayout&gt; RepLayout = <span class="built_in">MakeShareable</span>&lt;FRepLayout&gt;(<span class="keyword">new</span> <span class="built_in">FRepLayout</span>());</span><br><span class="line">    RepLayout-&gt;<span class="built_in">InitFromClass</span>(InClass, ServerConnection, CreateFlags);</span><br><span class="line">    <span class="keyword">return</span> RepLayout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>InitFromClass</code> 会调用 <code>UClass::SetUpRuntimeReplicationData</code> 来收集需要同步的字段，这个函数会在蓝图创建或每次编译时执行，这也就是蓝图实现同步变量的原理。</p><p><img data-src="/images/UE5_network_replicator2.png" alt="UE5_network_replicator2.png"></p><p>通过遍历该类的所有字段，找出需要同步的字段。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UClass::SetUpRuntimeReplicationData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NetFields.<span class="built_in">Empty</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (UClass* SuperClass = <span class="built_in">GetSuperClass</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        SuperClass-&gt;<span class="built_in">SetUpRuntimeReplicationData</span>();</span><br><span class="line">        ClassReps = SuperClass-&gt;ClassReps;</span><br><span class="line">        FirstOwnedClassRep = ClassReps.<span class="built_in">Num</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ClassReps.<span class="built_in">Empty</span>();</span><br><span class="line">        FirstOwnedClassRep = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Track properties so me can ensure they are sorted by offsets at the end</span></span><br><span class="line">    TArray&lt;FProperty*&gt; NetProperties;</span><br><span class="line">    <span class="keyword">for</span> (TFieldIterator&lt;FField&gt; <span class="built_in">It</span>(<span class="keyword">this</span>, EFieldIteratorFlags::ExcludeSuper); It; ++It)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (FProperty* Prop = <span class="built_in">CastField</span>&lt;FProperty&gt;(*It))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((Prop-&gt;PropertyFlags &amp; CPF_Net) &amp;&amp; Prop-&gt;<span class="built_in">GetOwner</span>&lt;UObject&gt;() == <span class="keyword">this</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                NetProperties.<span class="built_in">Add</span>(Prop);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里找出所有 RPC函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(TFieldIterator&lt;UField&gt; <span class="built_in">It</span>(<span class="keyword">this</span>,EFieldIteratorFlags::ExcludeSuper); It; ++It)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (UFunction * Func = <span class="built_in">Cast</span>&lt;UFunction&gt;(*It))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// When loading reflection data (e.g. from blueprints), we may have references to placeholder functions, or reflection data </span></span><br><span class="line">        <span class="comment">// in children may be out of date. In that case we cannot enforce this check, but that is ok because reflection data will</span></span><br><span class="line">        <span class="comment">// be regenerated by compile on load anyway:</span></span><br><span class="line">        <span class="type">const</span> <span class="type">bool</span> bCanCheck = (!GIsEditor &amp;&amp; !<span class="built_in">IsRunningCommandlet</span>()) || !Func-&gt;<span class="built_in">HasAnyFlags</span>(RF_WasLoaded);</span><br><span class="line">        <span class="built_in">check</span>(!bCanCheck || (!Func-&gt;<span class="built_in">GetSuperFunction</span>() || (Func-&gt;<span class="built_in">GetSuperFunction</span>()-&gt;FunctionFlags&amp;FUNC_NetFuncFlags) == (Func-&gt;FunctionFlags&amp;FUNC_NetFuncFlags)));</span><br><span class="line">        <span class="keyword">if</span> ((Func-&gt;FunctionFlags&amp;FUNC_Net) &amp;&amp; !Func-&gt;<span class="built_in">GetSuperFunction</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            NetFields.<span class="built_in">Add</span>(Func);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>蓝图也就是 非 <code>CLASS_Native</code> 则需要对属性进行一次稳定排序，保证之后的内存布局顺序是一致的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">bool</span> bIsNativeClass = <span class="built_in">HasAnyClassFlags</span>(CLASS_Native);</span><br><span class="line"><span class="keyword">if</span> (!bIsNativeClass)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Sort NetProperties so that their ClassReps are sorted by memory offset</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">FComparePropertyOffsets</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">FORCEINLINE <span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(FProperty* A, FProperty* B)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// Ensure stable sort</span></span><br><span class="line">            <span class="keyword">if</span> (A-&gt;<span class="built_in">GetOffset_ForGC</span>() == B-&gt;<span class="built_in">GetOffset_ForGC</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> A-&gt;<span class="built_in">GetName</span>() &lt; B-&gt;<span class="built_in">GetName</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> A-&gt;<span class="built_in">GetOffset_ForGC</span>() &lt; B-&gt;<span class="built_in">GetOffset_ForGC</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Algo::<span class="built_in">Sort</span>(NetProperties, <span class="built_in">FComparePropertyOffsets</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对静态数组的处理则是每个槽位都先占位，并将存在 ClassReps 里。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ClassReps.<span class="built_in">Reserve</span>(ClassReps.<span class="built_in">Num</span>() + NetProperties.<span class="built_in">Num</span>());</span><br><span class="line"><span class="keyword">for</span> (int32 i = <span class="number">0</span>; i &lt; NetProperties.<span class="built_in">Num</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    NetProperties[i]-&gt;RepIndex = (uint16)ClassReps.<span class="built_in">Num</span>();</span><br><span class="line">    <span class="keyword">for</span> (int32 j = <span class="number">0</span>; j &lt; NetProperties[i]-&gt;ArrayDim; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        ClassReps.<span class="built_in">Emplace</span>(NetProperties[i], j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">check</span>(ClassReps.<span class="built_in">Num</span>() &lt;= <span class="number">65535</span>);</span><br><span class="line"></span><br><span class="line">NetFields.<span class="built_in">Shrink</span>();</span><br><span class="line"></span><br><span class="line">Algo::<span class="built_in">SortBy</span>(NetFields, &amp;UField::GetFName, <span class="built_in">FNameLexicalLess</span>());</span><br><span class="line"></span><br><span class="line">ClassFlags |= CLASS_ReplicationDataIsSetUp;</span><br></pre></td></tr></table></figure><p>ClassReps 存的内容很简单，一个是属性的指针，另一个是索引。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** List of replication records */</span></span><br><span class="line">TArray&lt;FRepRecord&gt; ClassReps;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FRepRecord</span></span><br><span class="line">&#123;</span><br><span class="line">    FProperty* Property;</span><br><span class="line">    int32 Index;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在已经找出了所有需要同步的字段，以及 RPC 函数，但根据一开始的思路，还需要一段内存来存储上一次刷新的属性，这样才能做内存比对，知道哪些属性有变更。</p><h3 id="计算每个属性在-ShadowBuffer-的位置"><a href="#计算每个属性在-ShadowBuffer-的位置" class="headerlink" title="计算每个属性在 ShadowBuffer 的位置"></a>计算每个属性在 ShadowBuffer 的位置</h3><p>ShadowBuffer 就是一段用来存储上一次刷新时的属性的一段内存，每个 Actor 都有一个，既然知道要用它来存储同步属性，那么首先要计算属性应该被放到 ShadowBuffer 的哪一处，也就是内存偏移，这就是 Cmd 的作用。</p><p>Cmd 分为 <code>FRepParentCmd</code>和<code>FRepLayoutCmd</code> ，每个 RepParentCmd 包含一个或多个 RepLayoutCmd，之所以需要这样，是因为需要同步的属性有可能是个 <code>Struct</code> 或者是 <code>Array</code> ，需要更确切的知道每个槽位的内存偏移，如果同步的都是 int 这种平坦的内存，那自然就不需要多弄一层 Cmd。</p><p><code>FRepParentCmd</code> 的结构如下，其中 <code>CmdStart</code> 和 <code>CmdEnd</code> 指的是这个 ParentCmd 包含的 LayoutCmd 的左右边界。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FRepParentCmd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FProperty* Property;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * If the Property is a C-Style fixed size array, then a command will be created for every element in the array.</span></span><br><span class="line"><span class="comment">        * This is the index of the element in the array for which the command represents.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * This will always be 0 for non array properties.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    int32 ArrayIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Absolute offset of property in Object Memory. */</span></span><br><span class="line">    int32 Offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Absolute offset of property in Shadow Memory. */</span></span><br><span class="line">    int32 ShadowOffset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * CmdStart and CmdEnd define the range of FRepLayoutCommands (by index in FRepLayouts Cmd array) of commands</span></span><br><span class="line"><span class="comment">        * that are associated with this Parent Command.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * This is used to track and access nested Properties from the parent.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    uint16 CmdStart;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @see CmdStart */</span></span><br><span class="line">    uint16 CmdEnd;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FRepLayoutCmd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Pointer back to property, used for NetSerialize calls, etc. */</span></span><br><span class="line">    FProperty* Property;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** For arrays, this is the cmd index to jump to, to skip this arrays inner elements. */</span></span><br><span class="line">    uint16 EndCmd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** For arrays, element size of data. */</span></span><br><span class="line">    uint16 ElementSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Absolute offset of property in Object Memory. */</span></span><br><span class="line">    int32 Offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Absolute offset of property in Shadow Memory. */</span></span><br><span class="line">    int32 ShadowOffset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Handle relative to start of array, or top list. */</span></span><br><span class="line">    uint16 RelativeHandle;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Index into Parents. */</span></span><br><span class="line">    uint16 ParentIndex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此处就是根据 <code>ClassReps</code> 构建 ParentCmd 和 LayoutCmd。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FRepLayout::InitFromClass</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	UClass* InObjectClass,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">const</span> UNetConnection* ServerConnection,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">const</span> ECreateRepLayoutFlags CreateFlags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (int32 i = <span class="number">0</span>; i &lt; InObjectClass-&gt;ClassReps.<span class="built_in">Num</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        FProperty * Property = InObjectClass-&gt;ClassReps[i].Property;</span><br><span class="line">        <span class="type">const</span> int32 ArrayIdx = InObjectClass-&gt;ClassReps[i].Index;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> int32 ParentHandle = <span class="built_in">AddParentProperty</span>(Parents, Property, ArrayIdx);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">check</span>(ParentHandle == i);</span><br><span class="line">        <span class="built_in">check</span>(Parents[i].Property-&gt;RepIndex + Parents[i].ArrayIndex == i);</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> int32 ParentOffset = Property-&gt;ElementSize * ArrayIdx;</span><br><span class="line"></span><br><span class="line">        FInitFromPropertySharedParams SharedParams</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*Cmds=*/</span>Cmds,</span><br><span class="line">            <span class="comment">/*ServerConnection=*/</span>ServerConnection,</span><br><span class="line">            <span class="comment">/*ParentIndex=*/</span>ParentHandle,</span><br><span class="line">            <span class="comment">/*Parent=*/</span>Parents[ParentHandle],</span><br><span class="line">            <span class="comment">/*bHasObjectProperties=*/</span><span class="literal">false</span>,</span><br><span class="line">            <span class="comment">/*bHasNetSerializeProperties=*/</span><span class="literal">false</span>,</span><br><span class="line">            <span class="comment">/*NetSerializeLayouts=*/</span>GbTrackNetSerializeObjectReferences ? &amp;TempNetSerializeLayouts : <span class="literal">nullptr</span>,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        FInitFromPropertyStackParams StackParams</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*Property=*/</span>Property,</span><br><span class="line">            <span class="comment">/*Offset=*/</span>ParentOffset, <span class="comment">// 当前属性的 offset 根据元素大小Elementsize*arrayIdx算出</span></span><br><span class="line">            <span class="comment">/*RelativeHandle=*/</span>RelativeHandle, <span class="comment">//Cmd在Cmds数组中的下标+1</span></span><br><span class="line">            <span class="comment">/*ParentChecksum=*/</span><span class="number">0</span>,</span><br><span class="line">            <span class="comment">/*StaticArrayIndex=*/</span>ArrayIdx <span class="comment">// arrayIdx</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Parents[ParentHandle].CmdStart = Cmds.<span class="built_in">Num</span>();</span><br><span class="line">        RelativeHandle = <span class="built_in">InitFromProperty_r</span>&lt;ERepBuildType::Class&gt;(SharedParams, StackParams);</span><br><span class="line">        Parents[ParentHandle].CmdEnd = Cmds.<span class="built_in">Num</span>();</span><br><span class="line">        Parents[ParentHandle].Flags |= ERepParentFlags::IsConditional;</span><br><span class="line">        <span class="comment">// parentoffset 是因为有可能是固定数组，固定数组的元素是会被拆分成一个个 parent的</span></span><br><span class="line">        Parents[ParentHandle].Offset = <span class="built_in">GetOffsetForProperty</span>&lt;ERepBuildType::Class&gt;(*Property) + ParentOffset;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在继续之前，需要知道支持属性同步的类型是不包括 <code>TMap</code> 和 <code>TSet</code> 的。对普通类型的处理非常简单，就是一个 ParentCmd 对应一个 LayoutCmd。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Add actual property</span><br><span class="line">++StackParams.RelativeHandle;</span><br><span class="line">StackParams.Offset += GetOffsetForProperty&lt;BuildType&gt;(*StackParams.Property);</span><br><span class="line"></span><br><span class="line">AddPropertyCmd(SharedParams, StackParams);</span><br></pre></td></tr></table></figure><p>对 Array 属性的特殊处理，可以看出 Array 的 LayoutCmd 最后一个 Cmd 为 ReturnCmd。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> uint32 ArrayChecksum = <span class="built_in">AddArrayCmd</span>(SharedParams, StackParams);</span><br><span class="line"></span><br><span class="line">FInitFromPropertyStackParams NewStackParams&#123;</span><br><span class="line">    <span class="comment">/*Property=*/</span>ArrayProp-&gt;Inner,</span><br><span class="line">    <span class="comment">/*Offset=*/</span><span class="number">0</span>,</span><br><span class="line">    <span class="comment">/*RelativeHandle=*/</span><span class="number">0</span>,</span><br><span class="line">    <span class="comment">/*ParentChecksum=*/</span>ArrayChecksum,</span><br><span class="line">    <span class="comment">/*StaticArrayIndex=*/</span><span class="number">0</span>,</span><br><span class="line">    <span class="comment">/*RecursingNetSerializeStruct=*/</span>StackParams.RecursingNetSerializeStruct</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">InitFromProperty_r</span>&lt;BuildType&gt;(SharedParams, NewStackParams);</span><br><span class="line"></span><br><span class="line"><span class="built_in">AddReturnCmd</span>(SharedParams.Cmds);</span><br></pre></td></tr></table></figure><p>对 Struct 的特殊处理，实现了NetDeltaSerialize函数的 Struct，不会生成 LayoutCmd，原因如注释所示。</p><ul><li><code>*These structs will not have Child Rep Commands, but they will still have Parent Commands. This is because we generally don&#39;t care about their Memory Layout, but we need to be able to initialize them properly.*</code></li></ul><p>这是提供了一个方法来用用户自定义如何进行计算增量逻辑，若无这个函数，则会默认用 <code>UStructProperty::NetDeltaSerializeItem</code> ，最经典的使用是 FastArray，因为普通的 Array 属性同步时，若增删了其中一个值，则需要发送该 Array 剩下的所有值。</p><p>Struct 若实现了 NetSerialize 则表明是自己决定如何序列化的，只会生成一个 LayoutCmd。</p><ul><li><code>*These structs will have a single Child Rep Command for the FStructProperty. Similar to NetDeltaSerialize, we don&#39;t really care about the memory layout of NetSerialize structs, but we still need to know where they live so we can diff them, etc.</code>*</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">UScriptStruct* Struct = StructProp-&gt;Struct;</span><br><span class="line"></span><br><span class="line">StackParams.Offset += <span class="built_in">GetOffsetForProperty</span>&lt;BuildType&gt;(*StructProp);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">EnumHasAnyFlags</span>(Struct-&gt;StructFlags, STRUCT_NetSerializeNative))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UE_CLOG</span>(<span class="built_in">EnumHasAnyFlags</span>(Struct-&gt;StructFlags, STRUCT_NetDeltaSerializeNative), LogRep, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;RepLayout InitFromProperty_r: Struct marked both NetSerialize and NetDeltaSerialize: %s&quot;</span>), *StructProp-&gt;<span class="built_in">GetName</span>());</span><br><span class="line"></span><br><span class="line">    SharedParams.bHasNetSerializeProperties = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ERepBuildType::Class == BuildType &amp;&amp; GbTrackNetSerializeObjectReferences &amp;&amp; <span class="literal">nullptr</span> != SharedParams.NetSerializeLayouts &amp;&amp; !<span class="built_in">EnumHasAnyFlags</span>(Struct-&gt;StructFlags, STRUCT_IdenticalNative))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// We can&#x27;t directly rely on FProperty::Identical because it&#x27;s not safe for GC&#x27;d objects.</span></span><br><span class="line">        <span class="comment">// So, we&#x27;ll recursively build up set of layout commands for this struct, and if any</span></span><br><span class="line">        <span class="comment">// are Objects, we&#x27;ll use that for storing items in Shadow State and comparison.</span></span><br><span class="line">        <span class="comment">// Otherwise, we&#x27;ll fall back to the old behavior.</span></span><br><span class="line">        <span class="type">const</span> int32 PrevCmdNum = SharedParams.Cmds.<span class="built_in">Num</span>();</span><br><span class="line"></span><br><span class="line">        TArray&lt;FRepLayoutCmd&gt; TempCmds;</span><br><span class="line">        TArray&lt;FRepLayoutCmd&gt;* NewCmds = &amp;TempCmds;</span><br><span class="line">        </span><br><span class="line">        FInitFromPropertyStackParams NewStackParams&#123;</span><br><span class="line">            <span class="comment">/*Property=*/</span>StackParams.Property,</span><br><span class="line">            <span class="comment">/*Offset=*/</span><span class="number">0</span>,</span><br><span class="line">            <span class="comment">/*RelativeHandle=*/</span>StackParams.RelativeHandle,</span><br><span class="line">            <span class="comment">/*ParentChecksum=*/</span>StackParams.ParentChecksum,</span><br><span class="line">            <span class="comment">/*StaticArrayIndex=*/</span>StackParams.StaticArrayIndex,</span><br><span class="line">            <span class="comment">/*RecursingNetSerialize=*/</span>StructProp-&gt;<span class="built_in">GetFName</span>()</span><br><span class="line">            </span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StackParams.RecursingNetSerializeStruct != NAME_None)</span><br><span class="line">        &#123;</span><br><span class="line">            NewCmds = &amp;SharedParams.Cmds;</span><br><span class="line">            NewStackParams.RelativeHandle = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        FInitFromPropertySharedParams NewSharedParams&#123;</span><br><span class="line">            <span class="comment">/*Cmds=*/</span>*NewCmds,</span><br><span class="line">            <span class="comment">/*ServerConnection=*/</span>SharedParams.ServerConnection,</span><br><span class="line">            <span class="comment">/*ParentIndex=*/</span>SharedParams.ParentIndex,</span><br><span class="line">            <span class="comment">/*Parent=*/</span>SharedParams.Parent,</span><br><span class="line">            <span class="comment">/*bHasObjectProperties=*/</span><span class="literal">false</span>,</span><br><span class="line">            <span class="comment">/*bHasNetSerializeProperties=*/</span><span class="literal">false</span>,</span><br><span class="line">            <span class="comment">/*NetSerializeLayouts=*/</span>SharedParams.NetSerializeLayouts</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> int32 NetSerializeStructOffset = <span class="built_in">InitFromStructProperty</span>&lt;BuildType&gt;(NewSharedParams, NewStackParams, StructProp, Struct);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StackParams.RecursingNetSerializeStruct == NAME_None)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (NewSharedParams.bHasObjectProperties)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// If this is a top level Net Serialize Struct, and we found any any objects,</span></span><br><span class="line">                <span class="comment">// then we need to make sure this is tracked in our map.</span></span><br><span class="line">                SharedParams.NetSerializeLayouts-&gt;<span class="built_in">Add</span>(SharedParams.Cmds.<span class="built_in">Num</span>(), <span class="built_in">MoveTemp</span>(TempCmds));</span><br><span class="line">                StackParams.bNetSerializeStructWithObjects = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!NewSharedParams.bHasObjectProperties)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// If this wasn&#x27;t a top level Net Serialize Struct, and we didn&#x27;t find any objects,</span></span><br><span class="line">            <span class="comment">// we need to remove any nested entries we added to the Net Serialize Struct&#x27;s layout.</span></span><br><span class="line">            <span class="comment">// Instead, we&#x27;ll assume this layout is FProperty safe, and add it as single command (below).</span></span><br><span class="line">            SharedParams.Cmds.<span class="built_in">SetNum</span>(PrevCmdNum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// This wasn&#x27;t a top level Net Serialize Struct, but we did find some objects.</span></span><br><span class="line">            <span class="comment">// We want to keep the layout we generated, so keep that layout</span></span><br><span class="line">            <span class="keyword">return</span> NetSerializeStructOffset;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ++StackParams.RelativeHandle;</span><br><span class="line">    <span class="built_in">AddPropertyCmd</span>(SharedParams, StackParams);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> StackParams.RelativeHandle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的图示如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+------------------+------------------+</span><br><span class="line">|     <span class="type">int</span> a        |  TArray&lt;<span class="type">int</span>&gt; b   |</span><br><span class="line">+------------------+------------------+</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+------------------+------------------+</span><br><span class="line">|RepParentCmd a    |RepParentCmd b   |</span><br><span class="line">|Offset:<span class="number">0</span>          |Offset:<span class="number">4</span>         |</span><br><span class="line">|CmdStart:<span class="number">0</span>        |CmdStart:<span class="number">1</span>       |</span><br><span class="line">|CmdEnd:<span class="number">1</span>          |CmdEnd:<span class="number">3</span>         |</span><br><span class="line">+------------------+------------------+</span><br></pre></td></tr></table></figure><p>此处<strong>设置同步条件</strong>，并赋值给 ParentCmd，比如说是不是初始化同步，或者是只同步给 Owner 之类的条件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize lifetime props</span></span><br><span class="line"><span class="comment">// Properties that replicate for the lifetime of the channel</span></span><br><span class="line">TArray&lt;FLifetimeProperty&gt; LifetimeProps;</span><br><span class="line">LifetimeProps.<span class="built_in">Reserve</span>(Parents.<span class="built_in">Num</span>());</span><br><span class="line"></span><br><span class="line">UObject* Object = InObjectClass-&gt;<span class="built_in">GetDefaultObject</span>();</span><br><span class="line"></span><br><span class="line">Object-&gt;<span class="built_in">GetLifetimeReplicatedProps</span>(LifetimeProps);</span><br></pre></td></tr></table></figure><p>建立Handle到Cmd数组的映射，主要因为动态Array需要特殊处理，存到 <code>TArray&lt;FHandleToCmdIndex&gt; BaseHandleToCmdIndex;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!ServerConnection || <span class="built_in">EnumHasAnyFlags</span>(CreateFlags, ECreateRepLayoutFlags::MaySendProperties))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">BuildHandleToCmdIndexTable_r</span>(<span class="number">0</span>, Cmds.<span class="built_in">Num</span>() - <span class="number">1</span>, BaseHandleToCmdIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后计算 ShadowOffset 也就是在 ShadowBuffer 的偏移。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BuildShadowOffsets</span>&lt;ERepBuildType::Class&gt;(InObjectClass, Parents, Cmds, ShadowDataBufferSize);</span><br></pre></td></tr></table></figure><p>按内存对齐，减小内存占用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;ERepBuildType ShadowType&gt;</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">BuildShadowOffsets</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	UStruct* Owner,</span></span></span><br><span class="line"><span class="params"><span class="function">	TArray&lt;FRepParentCmd&gt;&amp; Parents,</span></span></span><br><span class="line"><span class="params"><span class="function">	TArray&lt;FRepLayoutCmd&gt;&amp; Cmds,</span></span></span><br><span class="line"><span class="params"><span class="function">	int32&amp; ShadowOffset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">FParentCmdIndexAndAlignment</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">FParentCmdIndexAndAlignment</span>(int32 ParentIndex, <span class="type">const</span> FRepParentCmd&amp; Parent):</span><br><span class="line">            <span class="built_in">Index</span>(ParentIndex),</span><br><span class="line">            <span class="built_in">Alignment</span>(Parent.Property-&gt;<span class="built_in">GetMinAlignment</span>())</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> int32 Index;</span><br><span class="line">        <span class="type">const</span> int32 Alignment;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Needed for sorting.</span></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> FParentCmdIndexAndAlignment&amp; RHS) <span class="type">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> Alignment &lt; RHS.Alignment;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    TArray&lt;FParentCmdIndexAndAlignment&gt; IndexAndAlignmentArray;</span><br><span class="line">    IndexAndAlignmentArray.<span class="built_in">Reserve</span>(Parents.<span class="built_in">Num</span>());</span><br><span class="line">    <span class="keyword">for</span> (int32 i = <span class="number">0</span>; i &lt; Parents.<span class="built_in">Num</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        IndexAndAlignmentArray.<span class="built_in">Emplace</span>(i, Parents[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IndexAndAlignmentArray.<span class="built_in">StableSort</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还会对 bool 进行特殊处理，每个 bool 值只占 1bit，具体可以查阅 <code>BuildShadowOffsets_r</code> ，就不一一列出了。至此解决了属性应该如何存放到 ShadowBuffer 的问题。</p><p><code>FRepLayout</code> 会被存放到 <code>NetDriver</code> 中，而不是只放到 <code>NetConnection</code> 中，因为一个 Actor 可能同步给多个 Client，没必要比较多次。</p><h3 id="理解同步过程中所需的数据结构"><a href="#理解同步过程中所需的数据结构" class="headerlink" title="理解同步过程中所需的数据结构"></a>理解同步过程中所需的数据结构</h3><p>在继续往下学习属性同步之前，需要先理解以下一些数据结构。</p><ul><li>FObjectReplicator</li></ul><p>可以理解为对象的同步器，内部存有 <code>FRepLayout</code>、<code>FRepState</code>、<code>FReplicationChangelistMgr</code>，将这些功能串联起来。</p><ul><li>FRepLayout</li></ul><p>描述同步属性的信息和内存布局，NetDriver 中存放，可给多条连接共享。</p><ul><li>FRepState</li></ul><p>表示该对象在一条连接下的发送接收状态，因为每条连接的同步速率可能是不同的，所以需要单独记录。</p><ul><li>FReplicationChangelistMgr</li></ul><p>里面有个 <code>RepChangelistState</code> 是用来做属性对比的，里面还会记录历史变更。</p><ul><li>FRepChangedPropertyTracker</li></ul><p>因为属性同步是有条件的，比如同步条件是仅在初始化时同步，那么之后就不需要同步该属性了，这个类就是用来跟踪哪些属性的同步条件发生了变更的。</p><p>这些数据结构会在 <code>UActorChannel::SetChannelActor</code> 中构造，前面为 Actor 创建 ActorChannel 时提到过，此处重点在于 创建了 <code>FObjectReplicator</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UActorChannel::SetChannelActor</span><span class="params">(AActor* InActor, ESetChannelActorFlags Flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">EnumHasAnyFlags</span>(Flags, ESetChannelActorFlags::SkipReplicatorCreation))</span><br><span class="line">    &#123;</span><br><span class="line">        ActorReplicator = <span class="built_in">FindOrCreateReplicator</span>(Actor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TSharedPtr&lt;FObjectReplicator&gt; <span class="title">UNetConnection::CreateReplicatorForNewActorChannel</span><span class="params">(UObject* Object)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TSharedPtr&lt;FObjectReplicator&gt; NewReplicator = <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">FObjectReplicator</span>());</span><br><span class="line">    NewReplicator-&gt;<span class="built_in">InitWithObject</span>( Object, <span class="keyword">this</span>, <span class="literal">true</span> );</span><br><span class="line">    <span class="keyword">return</span> NewReplicator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后创建了 <code>FRepState</code> ，用于记录该连接下的属性发送接收状态信息。</p><p>在 <code>FObjectReplicator</code> StartReplicating 时，先构造出 <code>FReplicationChangelistMgr</code> 然后立刻构造出 <code>FRepChangelistState</code> 它就是用来做属性比对的，自然 ShadowBuffer 就是它构造的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FObjectReplicator::StartReplicating</span><span class="params">(<span class="keyword">class</span> UActorChannel * InActorChannel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (WorldNetDriver &amp;&amp; WorldNetDriver-&gt;<span class="built_in">IsServer</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        ChangelistMgr = WorldNetDriver-&gt;<span class="built_in">GetReplicationChangeListMgr</span>(Object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FRepChangelistState::<span class="built_in">FRepChangelistState</span>(</span><br><span class="line">    <span class="type">const</span> TSharedRef&lt;<span class="type">const</span> FRepLayout&gt;&amp; InRepLayout,</span><br><span class="line">    <span class="type">const</span> uint8* InSource,</span><br><span class="line">    <span class="type">const</span> UObject* InRepresenting,</span><br><span class="line">    FCustomDeltaChangelistState* InDeltaChangelistState)</span><br><span class="line"></span><br><span class="line">    : <span class="built_in">CustomDeltaChangelistState</span>(InDeltaChangelistState)</span><br><span class="line">    , <span class="built_in">HistoryStart</span>(<span class="number">0</span>)</span><br><span class="line">    , <span class="built_in">HistoryEnd</span>(<span class="number">0</span>)</span><br><span class="line">    , <span class="built_in">CompareIndex</span>(<span class="number">0</span>)</span><br><span class="line">    , <span class="built_in">StaticBuffer</span>(InRepLayout-&gt;<span class="built_in">CreateShadowBuffer</span>(InSource))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造出 ShadowBuffer，里面就是需要同步的属性的内存，</p><h3 id="比较属性"><a href="#比较属性" class="headerlink" title="比较属性"></a>比较属性</h3><p>比较属性的调用路径如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">FObjectReplicator::ReplicateProperties</span><span class="params">(FOutBunch&amp; Bunch, FReplicationFlags RepFlags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">LLM_SCOPE_BYTAG</span>(NetObjReplicator);</span><br><span class="line">    <span class="function">FNetBitWriter <span class="title">Writer</span><span class="params">(Bunch.PackageMap, <span class="number">8192</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ReplicateProperties_r</span>(Bunch, RepFlags, Writer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">FObjectReplicator::ReplicateProperties_r</span><span class="params">( FOutBunch &amp; Bunch, FReplicationFlags RepFlags, FNetBitWriter&amp; Writer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UObject* Object = <span class="built_in">GetObject</span>();</span><br><span class="line"></span><br><span class="line">    FSendingRepState* SendingRepState = (bUseCheckpointRepState &amp;&amp; CheckpointRepState.<span class="built_in">IsValid</span>()) ? CheckpointRepState-&gt;<span class="built_in">GetSendingRepState</span>() : RepState-&gt;<span class="built_in">GetSendingRepState</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> ERepLayoutResult UpdateResult = FNetSerializeCB::<span class="built_in">UpdateChangelistMgr</span>(*RepLayout, SendingRepState, *ChangelistMgr, Object, Connection-&gt;Driver-&gt;ReplicationFrame, RepFlags, OwningChannel-&gt;bForceCompareProperties || bUseCheckpointRepState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ERepLayoutResult <span class="title">FRepLayout::UpdateChangelistMgr</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	FSendingRepState* RESTRICT RepState,</span></span></span><br><span class="line"><span class="params"><span class="function">	FReplicationChangelistMgr&amp; InChangelistMgr,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">const</span> UObject* InObject,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">const</span> uint32 ReplicationFrame,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">const</span> FReplicationFlags&amp; RepFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">const</span> <span class="type">bool</span> bForceCompare)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Result = <span class="built_in">CompareProperties</span>(RepState, &amp;InChangelistMgr.RepChangelistState, (<span class="type">const</span> uint8*)InObject, RepFlags, bForceCompare);</span><br><span class="line">    <span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在比较属性之前，通过循环队列开辟一个新的 changeHistory，记录这次的属性变更。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ERepLayoutResult <span class="title">FRepLayout::CompareProperties</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	FSendingRepState* RESTRICT RepState,</span></span></span><br><span class="line"><span class="params"><span class="function">	FRepChangelistState* RESTRICT RepChangelistState,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">const</span> FConstRepObjectDataBuffer Data,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">const</span> FReplicationFlags&amp; RepFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">const</span> <span class="type">bool</span> bForceCompare)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RepChangelistState-&gt;CompareIndex++;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> int32 HistoryIndex = RepChangelistState-&gt;HistoryEnd % FRepChangelistState::MAX_CHANGE_HISTORY;</span><br><span class="line">    FRepChangedHistory&amp; NewHistoryItem = RepChangelistState-&gt;ChangeHistory[HistoryIndex];</span><br><span class="line"></span><br><span class="line">    TArray&lt;uint16&gt;&amp; Changed = NewHistoryItem.Changed;</span><br><span class="line">    Changed.<span class="built_in">Empty</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    ERepLayoutResult Result = ERepLayoutResult::Success;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CompareParentProperties</span>(SharedParams, StackParams);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Null terminator</span></span><br><span class="line">    Changed.<span class="built_in">Add</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Move end pointer</span></span><br><span class="line">    RepChangelistState-&gt;HistoryEnd++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若 变更记录满了，则进行合并。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((RepChangelistState-&gt;HistoryEnd - RepChangelistState-&gt;HistoryStart) == FRepChangelistState::MAX_CHANGE_HISTORY)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> int32 FirstHistoryIndex = RepChangelistState-&gt;HistoryStart % FRepChangelistState::MAX_CHANGE_HISTORY;</span><br><span class="line"></span><br><span class="line">    RepChangelistState-&gt;HistoryStart++;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> int32 SecondHistoryIndex = RepChangelistState-&gt;HistoryStart % FRepChangelistState::MAX_CHANGE_HISTORY;</span><br><span class="line"></span><br><span class="line">    TArray&lt;uint16&gt;&amp; FirstChangelistRef = RepChangelistState-&gt;ChangeHistory[FirstHistoryIndex].Changed;</span><br><span class="line">    TArray&lt;uint16&gt; SecondChangelistCopy = <span class="built_in">MoveTemp</span>(RepChangelistState-&gt;ChangeHistory[SecondHistoryIndex].Changed);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MergeChangeList</span>(Data, FirstChangelistRef, SecondChangelistCopy, RepChangelistState-&gt;ChangeHistory[SecondHistoryIndex].Changed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性比较最终会到这，若发生变更，则将 Handle 加入到 Changed 中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> uint16 <span class="title">CompareProperties_r</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">const</span> FComparePropertiesSharedParams&amp; SharedParams,</span></span></span><br><span class="line"><span class="params"><span class="function">	FComparePropertiesStackParams&amp; StackParams,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">const</span> uint16 CmdStart,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">const</span> uint16 CmdEnd,</span></span></span><br><span class="line"><span class="params"><span class="function">	uint16 Handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (int32 CmdIndex = CmdStart; CmdIndex &lt; CmdEnd; ++CmdIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> FRepLayoutCmd&amp; Cmd = SharedParams.Cmds[CmdIndex];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">check</span>(Cmd.Type != ERepLayoutCmdType::Return);</span><br><span class="line"></span><br><span class="line">        ++Handle;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> FConstRepObjectDataBuffer Data = StackParams.Data + Cmd;</span><br><span class="line">        FRepShadowDataBuffer ShadowData = StackParams.ShadowData + Cmd;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Cmd.Type == ERepLayoutCmdType::DynamicArray)</span><br><span class="line">        &#123;</span><br><span class="line">            FComparePropertiesStackParams NewStackParams&#123;</span><br><span class="line">                Data,</span><br><span class="line">                ShadowData,</span><br><span class="line">                StackParams.Changed,</span><br><span class="line">                StackParams.Result</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Once we hit an array, start using a stack based approach</span></span><br><span class="line">            <span class="built_in">CompareProperties_Array_r</span>(SharedParams, NewStackParams, CmdIndex, Handle);</span><br><span class="line">            CmdIndex = Cmd.EndCmd - <span class="number">1</span>;		<span class="comment">// The -1 to handle the ++ in the for loop</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (SharedParams.bForceFail || !<span class="built_in">PropertiesAreIdentical</span>(Cmd, ShadowData.Data, Data.Data, SharedParams.NetSerializeLayouts))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">StoreProperty</span>(Cmd, ShadowData.Data, Data.Data);</span><br><span class="line">            StackParams.Changed.<span class="built_in">Add</span>(Handle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Handle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里需要特别注意对动态数组的处理，因为动态数组你不知道具体是有多少个，你只能写入有多少个值变更了，然后写入具体变更的 Handle，计算方式也很简单，<code>index * 子元素数量 + 改变的子元素handle</code>，若动态数组存放的是一个 int，则子元素数量为1，可简化为 index + 1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StackParams.Changed.<span class="built_in">Add</span>(Handle);</span><br><span class="line">StackParams.Changed.<span class="built_in">Add</span>((uint16)NumChangedEntries);		<span class="comment">// This is so we can jump over the array if we need to</span></span><br><span class="line">StackParams.Changed.<span class="built_in">Append</span>(ChangedLocal);</span><br><span class="line">StackParams.Changed.<span class="built_in">Add</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>也有可能数组长度减小，但数组原有的那部分完全一致，就不需要变更。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ArrayNum != ShadowArrayNum)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// If nothing below us changed, we either shrunk, or we grew and our inner was an array that didn&#x27;t have any elements</span></span><br><span class="line">    <span class="built_in">check</span>(ArrayNum &lt; ShadowArrayNum || SharedParams.Cmds[CmdIndex + <span class="number">1</span>].Type == ERepLayoutCmdType::DynamicArray);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Array got smaller, send the array handle to force array size change</span></span><br><span class="line">    StackParams.Changed.<span class="built_in">Add</span>(Handle);</span><br><span class="line">    StackParams.Changed.<span class="built_in">Add</span>(<span class="number">0</span>);</span><br><span class="line">    StackParams.Changed.<span class="built_in">Add</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但数组若出现中间插入或删除值，则需要把后面一连串的数据一起发送，非常浪费，这也是为什么后面引入了 FastArray。</p><p>简单看下属性根据类型进行比较。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> FORCEINLINE <span class="type">bool</span> <span class="title">PropertiesAreIdenticalNative</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">const</span> FRepLayoutCmd&amp; Cmd,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">const</span> <span class="type">void</span>* A,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">const</span> <span class="type">void</span>* B,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">const</span> TMap&lt;FRepLayoutCmd*, TArray&lt;FRepLayoutCmd&gt;&gt;&amp; NetSerializeLayouts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (Cmd.Type)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> ERepLayoutCmdType::PropertyBool:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">CompareBool</span>(Cmd, A, B);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> ERepLayoutCmdType::PropertyNativeBool:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">CompareValue</span>&lt;<span class="type">bool</span>&gt;(A, B);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> ERepLayoutCmdType::PropertyByte:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">CompareValue</span>&lt;uint8&gt;(A, B);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较属性只需要走一次就可以了，后续同一帧内，不同的连接可以直接复用，所以 <code>UpdateChangelistMgr</code> 可以直接返回结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ERepLayoutResult <span class="title">FRepLayout::UpdateChangelistMgr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!bForceCompare &amp;&amp; GShareShadowState &amp;&amp; !RepFlags.bNetInitial &amp;&amp; RepState-&gt;LastCompareIndex &gt; <span class="number">1</span> &amp;&amp; InChangelistMgr.LastReplicationFrame == ReplicationFrame)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Result;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>属性比较完成后，还会将新属性更新到 ShadowBuffer 中。</p><h3 id="发送变更属性"><a href="#发送变更属性" class="headerlink" title="发送变更属性"></a>发送变更属性</h3><p>将所有变更记录，合并到当前连接所属的变更记录中，也就是 RepState 中，还是那句话，每条连接的同步进度是不同的，所以要为每条连接单独弄个 History 循环队列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">FObjectReplicator::ReplicateProperties_r</span><span class="params">( FOutBunch &amp; Bunch, FReplicationFlags RepFlags, FNetBitWriter&amp; Writer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> bHasRepLayout = RepLayout-&gt;<span class="built_in">ReplicateProperties</span>(SendingRepState, ChangelistMgr-&gt;<span class="built_in">GetRepChangelistState</span>(), (uint8*)Object, ObjectClass, OwningChannel, Writer, RepFlags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">FRepLayout::ReplicateProperties</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	FSendingRepState* RESTRICT RepState,</span></span></span><br><span class="line"><span class="params"><span class="function">	FRepChangelistState* RESTRICT RepChangelistState,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">const</span> FConstRepObjectDataBuffer Data,</span></span></span><br><span class="line"><span class="params"><span class="function">	UClass* ObjectClass,</span></span></span><br><span class="line"><span class="params"><span class="function">	UActorChannel* OwningChannel,</span></span></span><br><span class="line"><span class="params"><span class="function">	FNetBitWriter&amp; Writer,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">const</span> FReplicationFlags&amp; RepFlags)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Gather all change lists that are new since we last looked, and merge them all together into a single CL</span></span><br><span class="line">    <span class="keyword">for</span> (int32 i = RepState-&gt;LastChangelistIndex; i &lt; RepChangelistState-&gt;HistoryEnd; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> int32 HistoryIndex = i % FRepChangelistState::MAX_CHANGE_HISTORY;</span><br><span class="line"></span><br><span class="line">        FRepChangedHistory&amp; HistoryItem = RepChangelistState-&gt;ChangeHistory[HistoryIndex];</span><br><span class="line"></span><br><span class="line">        TArray&lt;uint16&gt; Temp = <span class="built_in">MoveTemp</span>(Changed);</span><br><span class="line">        <span class="built_in">MergeChangeList</span>(Data, HistoryItem.Changed, Temp, Changed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Merge in newly active properties so they can be sent.</span></span><br><span class="line">    <span class="keyword">if</span> (NewlyActiveChangelist.<span class="built_in">Num</span>() &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TArray&lt;uint16&gt; Temp = <span class="built_in">MoveTemp</span>(Changed);</span><br><span class="line">        <span class="built_in">MergeChangeList</span>(Data, NewlyActiveChangelist, Temp, Changed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>UpdateChangelistHistory</code> 指的是更新当前 RepState 的 历史记录，就是更新当前连接的历史项，当对方已经确认收到之后，就可以去掉这条历史记录了。</p><p><code>PreOpenAckHistory</code> 指的是在对方打开这个 ActorChannel 的过程，产生的变更，需要临时记下来，随着对端创建该 ActorChannel 也要把这些属性变更下发过去。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Changed.<span class="built_in">Num</span>() &gt; <span class="number">0</span> || RepState-&gt;NumNaks &gt; <span class="number">0</span> || bFlushPreOpenAckHistory)</span><br><span class="line">&#123;</span><br><span class="line">    RepState-&gt;HistoryEnd++;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UpdateChangelistHistory</span>(RepState, ObjectClass, Data, OwningChannel-&gt;Connection, &amp;Changed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Merge in the PreOpenAckHistory (unreliable properties sent before the bunch was initially acked)</span></span><br><span class="line">    <span class="keyword">if</span> (bFlushPreOpenAckHistory)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (int32 i = <span class="number">0</span>; i &lt; RepState-&gt;PreOpenAckHistory.<span class="built_in">Num</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            TArray&lt;uint16&gt; Temp = <span class="built_in">MoveTemp</span>(Changed);</span><br><span class="line">            <span class="built_in">MergeChangeList</span>(Data, RepState-&gt;PreOpenAckHistory[i].Changed, Temp, Changed);</span><br><span class="line">        &#125;</span><br><span class="line">        RepState-&gt;PreOpenAckHistory.<span class="built_in">Empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Nothing changed and there are no nak&#x27;s, so just do normal housekeeping and remove acked history items</span></span><br><span class="line">    <span class="built_in">UpdateChangelistHistory</span>(RepState, ObjectClass, Data, OwningChannel-&gt;Connection, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个小优化，共享序列化好的数据，避免反复序列化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!OwningChannel-&gt;Connection-&gt;<span class="built_in">IsInternalAck</span>() &amp;&amp; (GNetSharedSerializedData != <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// if no shared serialization info exists, build it</span></span><br><span class="line">    <span class="keyword">if</span> (!RepChangelistState-&gt;SharedSerialization.<span class="built_in">IsValid</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">BuildSharedSerialization</span>(Data, Changed, <span class="literal">true</span>, RepChangelistState-&gt;SharedSerialization);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终将属性发送出去。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Changed.<span class="built_in">Num</span>() &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">SendProperties</span>(RepState, ChangeTracker, Data, ObjectClass, Writer, Changed, RepChangelistState-&gt;SharedSerialization, RepFlags.bSerializePropertyNames ? ESerializePropertyType::Name : ESerializePropertyType::Handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WriteContentBlockPayload</code> 主要用于区分当前数据来自于 Actor 还是 ActorComponent。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">FObjectReplicator::ReplicateProperties_r</span><span class="params">( FOutBunch &amp; Bunch, FReplicationFlags RepFlags, FNetBitWriter&amp; Writer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( WroteImportantData )</span><br><span class="line">    &#123;</span><br><span class="line">        OwningChannel-&gt;<span class="built_in">WriteContentBlockPayload</span>( Object, Bunch, bHasRepLayout, Writer );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> WroteImportantData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 Block 会追加到 真正的属性数据之前，所以才叫 BlockHeader。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">int32 <span class="title">UActorChannel::WriteContentBlockPayload</span><span class="params">( UObject* Obj, FNetBitWriter &amp;Bunch, <span class="type">const</span> <span class="type">bool</span> bHasRepLayout, FNetBitWriter&amp; Payload )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> int32 StartHeaderBits = Bunch.<span class="built_in">GetNumBits</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Trace header</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">WriteContentBlockHeader</span>( Obj, Bunch, bHasRepLayout );</span><br><span class="line"></span><br><span class="line">        uint32 NumPayloadBits = Payload.<span class="built_in">GetNumBits</span>();</span><br><span class="line"></span><br><span class="line">        Bunch.<span class="built_in">SerializeIntPacked</span>( NumPayloadBits );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> int32 HeaderNumBits = Bunch.<span class="built_in">GetNumBits</span>() - StartHeaderBits;</span><br><span class="line"></span><br><span class="line">    Bunch.<span class="built_in">SerializeBits</span>( Payload.<span class="built_in">GetData</span>(), Payload.<span class="built_in">GetNumBits</span>() );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> HeaderNumBits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SendBunch</code> 之后，会返回 PacketRange，将其和发出的历史记录关联起来，这样丢了什么数据，马上就能查出来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">int64 <span class="title">UActorChannel::ReplicateActor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bWroteSomethingImportant)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// We must exit the collection scope to report data correctly</span></span><br><span class="line">        FPacketIdRange PacketRange = <span class="built_in">SendBunch</span>( &amp;Bunch, <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!bIsNewlyReplicationPaused)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> RepComp = ReplicationMap.<span class="built_in">CreateIterator</span>(); RepComp; ++RepComp)</span><br><span class="line">            &#123;</span><br><span class="line">                RepComp.<span class="built_in">Value</span>()-&gt;<span class="built_in">PostSendBunch</span>(PacketRange, Bunch.bReliable);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="属性同步丢包"><a href="#属性同步丢包" class="headerlink" title="属性同步丢包"></a>属性同步丢包</h3><p>收到 Nak 后，会通知到 ActorChannel，随后通知到该 Packet 所携带的 Actor 的 FObjectReplicator 中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TMap&lt; UObject*, TSharedRef&lt; FObjectReplicator &gt; &gt; ReplicationMap;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UActorChannel::ReceivedNak</span><span class="params">( int32 NakPacketId )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UChannel::<span class="built_in">ReceivedNak</span>(NakPacketId);	</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> CompIt = ReplicationMap.<span class="built_in">CreateIterator</span>(); CompIt; ++CompIt)</span><br><span class="line">    &#123;</span><br><span class="line">        CompIt.<span class="built_in">Value</span>()-&gt;<span class="built_in">ReceivedNak</span>(NakPacketId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处会将该属性变更的历史记录的 Resend 标记位 置为 true，等待后续重传(<code>void FRepLayout::UpdateChangelistHistory</code>)，属性同步丢了就丢了，反正保证每次同步的是最新的值就行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FObjectReplicator::ReceivedNak</span><span class="params">( int32 NakPacketId )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> UObject* Object = <span class="built_in">GetObject</span>();</span><br><span class="line">    <span class="keyword">if</span> (!RepLayout-&gt;<span class="built_in">IsEmpty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (FSendingRepState* SendingRepState = RepState.<span class="built_in">IsValid</span>() ? RepState-&gt;<span class="built_in">GetSendingRepState</span>() : <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            SendingRepState-&gt;CustomDeltaChangeIndex--;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Go over properties tracked with histories, and mark them as needing to be resent.</span></span><br><span class="line">            <span class="keyword">for</span> (int32 i = SendingRepState-&gt;HistoryStart; i &lt; SendingRepState-&gt;HistoryEnd; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">const</span> int32 HistoryIndex = i % FSendingRepState::MAX_CHANGE_HISTORY;</span><br><span class="line"></span><br><span class="line">                FRepChangedHistory&amp; HistoryItem = SendingRepState-&gt;ChangeHistory[HistoryIndex];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!HistoryItem.Resend &amp;&amp; HistoryItem.OutPacketIdRange.<span class="built_in">InRange</span>(NakPacketId))</span><br><span class="line">                &#123;</span><br><span class="line">                    HistoryItem.Resend = <span class="literal">true</span>;</span><br><span class="line">                    ++SendingRepState-&gt;NumNaks;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同步指针"><a href="#同步指针" class="headerlink" title="同步指针"></a>同步指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(Replicated)</span><br><span class="line">AActor* MyActorReference;</span><br></pre></td></tr></table></figure><p>同步指针，有可能会出现这个对象还未同步给客户端，此时会先将其置空。一种很直观的思路是 记录这个属性在该类的内存偏移，下次当该 Actor 同步过来之后，再将它和这个 Actor 的 GUID 绑定。</p><p>收到 <code>MyActorReference</code> 属性后，需要将其反序列化，此时找不到该对象，则将其添加到 跟踪列表中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">UPackageMapClient::SerializeObject</span><span class="params">( FArchive&amp; Ar, UClass* Class, UObject*&amp; Object, FNetworkGUID *OutNetGUID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (Ar.<span class="built_in">IsLoading</span>())</span><br><span class="line">        <span class="keyword">if</span> ( NetGUID.<span class="built_in">IsValid</span>() &amp;&amp; bShouldTrackUnmappedGuids &amp;&amp; !GuidCache-&gt;<span class="built_in">IsGUIDBroken</span>( NetGUID, <span class="literal">false</span> ) )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( Object == <span class="literal">nullptr</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                TrackedUnmappedNetGuids.<span class="built_in">Add</span>( NetGUID );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( NetGUID.<span class="built_in">IsDynamic</span>() )</span><br><span class="line">            &#123;</span><br><span class="line">                TrackedMappedDynamicNetGuids.<span class="built_in">Add</span>( NetGUID );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>NetDriver::TickFlush</code> 会调用 <code>FObjectReplicator::UpdateUnmappedObjects</code> 最终调用<code>UpdateUnmappedObjects_r</code> 来更新 unmapped 的对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FRepLayout::UpdateUnmappedObjects_r</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    FReceivingRepState* RESTRICT RepState,</span></span></span><br><span class="line"><span class="params"><span class="function">    FGuidReferencesMap* GuidReferencesMap,</span></span></span><br><span class="line"><span class="params"><span class="function">    UObject* OriginalObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    UNetConnection* Connection,</span></span></span><br><span class="line"><span class="params"><span class="function">    FRepShadowDataBuffer ShadowData,</span></span></span><br><span class="line"><span class="params"><span class="function">    FRepObjectDataBuffer Data,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> int32 MaxAbsOffset,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span>&amp; bCalledPreNetReceive,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span>&amp; bOutSomeObjectsWereMapped,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span>&amp; bOutHasMoreUnmapped)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> It = GuidReferencesMap-&gt;<span class="built_in">CreateIterator</span>(); It; ++It)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> int32 AbsOffset = It.<span class="built_in">Key</span>();</span><br><span class="line">        Cmd.Property-&gt;<span class="built_in">NetSerializeItem</span>(Reader, Connection-&gt;PackageMap, Data + AbsOffset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="/images/UE5_network_replicator3.png" alt="UE5_network_replicator3.png"></p><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>以 <code>ClientSetHUD</code> 为例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;HUD&quot;</span>, Reliable, Client)</span><br><span class="line"><span class="function">ENGINE_API <span class="type">void</span> <span class="title">ClientSetHUD</span><span class="params">(TSubclassOf&lt;AHUD&gt; NewHUDClass)</span></span>;</span><br></pre></td></tr></table></figure><p>接收RPC 堆栈：</p><p><img data-src="/images/UE5_network_replicator4.png" alt="UE5_network_replicator4.png"></p><p><code>ClientSetHUD</code> 其实和属性一样，都有个索引，至于参数也是用的 <code>FProperty</code> ，FRepLayout 会为 RPC 函数的参数创建一个单独的内存布局。</p></div><footer class="post-footer"><div class="post-tags"><a href="/tags/UE5/" rel="tag"># UE5</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag"># 网络</a></div><div class="post-nav"><div class="post-nav-item"><a href="/UE5%20%E7%BD%91%E7%BB%9C%E5%89%96%E6%9E%90(%E4%B8%89)%20%E7%99%BB%E5%BD%95/" rel="prev" title="UE5 网络剖析(三) 登录"><i class="fa fa-angle-left"></i> UE5 网络剖析(三) 登录</a></div><div class="post-nav-item"><a href="/UE5%20%E5%8F%8D%E5%B0%84%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E4%B8%8E%E6%B3%A8%E5%86%8C/" rel="next" title="UE5 反射代码生成与注册">UE5 反射代码生成与注册 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Yuerer</span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://unpkg.com/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://unpkg.com/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/comments.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/utils.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/motion.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/sidebar.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/next-boot.min.js"></script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://yuerer-comment-xufei-0bea01e6f05-1307930306.ap-shanghai.app.tcloudbase.com","cssUrl":"https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.css","commentCount":true,"pageview":true,"libUrl":"https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.js","locale":{"placeholder":"有何高见？"},"emoji":["https://unpkg.com/@waline/emojis@1.0.1/qq"],"meta":["nick","mail"],"requiredMeta":[["nick","mail"]],"wordLimit":0,"login":"disable","pageSize":10,"el":"#waline","comment":true,"path":"/UE5%20%E7%BD%91%E7%BB%9C%E5%89%96%E6%9E%90(%E5%9B%9B)%20%E5%B1%9E%E6%80%A7%E5%90%8C%E6%AD%A5%E4%B8%8ERPC/"}</script><link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.css"><script>document.addEventListener("page:loaded",()=>{NexT.utils.loadComments(CONFIG.waline.el).then(()=>NexT.utils.getScript(CONFIG.waline.libUrl,{condition:window.Waline})).then(()=>Waline.init(Object.assign({},CONFIG.waline,{el:document.querySelector(CONFIG.waline.el)})))})</script></body></html>