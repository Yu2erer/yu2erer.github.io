<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.jpeg"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.ico"><link rel="mask-icon" href="/images/avatar.jpeg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous"><link rel="stylesheet" href="https://unpkg.com/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"yuerer.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"hide","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":true,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/config.min.js"></script><meta name="description" content="本篇是 Redis 6 剖析的第二篇，主要探讨 Redis 是怎么做主从同步的，对代码会有所删减。 SLAVE通常启用主从同步，只要在从服务器执行 SLAVEOF HOST PORT 即可，这个时候就会执行到 replicaofCommand 。由于主从同步是从服务器发起的，因此我们先从 Slave 开始进行剖析。"><meta property="og:type" content="article"><meta property="og:title" content="Redis 6 剖析(二) 主从同步"><meta property="og:url" content="https://yuerer.com/Redis-6-%E5%89%96%E6%9E%90(%E4%BA%8C)-%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/index.html"><meta property="og:site_name" content="Yuerer&#39;s Blog"><meta property="og:description" content="本篇是 Redis 6 剖析的第二篇，主要探讨 Redis 是怎么做主从同步的，对代码会有所删减。 SLAVE通常启用主从同步，只要在从服务器执行 SLAVEOF HOST PORT 即可，这个时候就会执行到 replicaofCommand 。由于主从同步是从服务器发起的，因此我们先从 Slave 开始进行剖析。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://yuerer.com/images/Redis6-Replication.png"><meta property="article:published_time" content="2021-04-03T15:31:20.000Z"><meta property="article:modified_time" content="2025-10-21T13:50:52.260Z"><meta property="article:author" content="Yuerer"><meta property="article:tag" content="Redis"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://yuerer.com/images/Redis6-Replication.png"><link rel="canonical" href="https://yuerer.com/Redis-6-%E5%89%96%E6%9E%90(%E4%BA%8C)-%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://yuerer.com/Redis-6-%E5%89%96%E6%9E%90(%E4%BA%8C)-%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/","path":"Redis-6-剖析(二)-主从同步/","title":"Redis 6 剖析(二) 主从同步"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Redis 6 剖析(二) 主从同步 | Yuerer's Blog</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-129491388-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-129491388-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/third-party/analytics/google-analytics.min.js"></script><link rel="dns-prefetch" href="https://yuerer-comment-xufei-0bea01e6f05-1307930306.ap-shanghai.app.tcloudbase.com"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Yuerer's Blog</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">钰儿的Blog</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#SLAVE"><span class="nav-text">SLAVE</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#repl-state"><span class="nav-text">repl_state</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#replicaofCommand"><span class="nav-text">replicaofCommand</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#replicationSetMaster"><span class="nav-text">replicationSetMaster</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#connectWithMaster"><span class="nav-text">connectWithMaster</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#syncWithMaster"><span class="nav-text">syncWithMaster</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#slaveTryPartialResynchronization"><span class="nav-text">slaveTryPartialResynchronization</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#readSyncBulkPayload"><span class="nav-text">readSyncBulkPayload</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#replicationCron"><span class="nav-text">replicationCron</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Master"><span class="nav-text">Master</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#syncCommand"><span class="nav-text">syncCommand</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#startBgsaveForReplication"><span class="nav-text">startBgsaveForReplication</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rdbSaveToSlavesSockets"><span class="nav-text">rdbSaveToSlavesSockets</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E7%9A%84%E5%9D%91"><span class="nav-text">主从同步的坑</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Yuerer" src="/images/avatar.jpeg"><p class="site-author-name" itemprop="name">Yuerer</p><div class="site-description" itemprop="description">钰儿的Blog</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">65</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">16</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">90</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/Yu2erer" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Yu2erer" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:yu2erer#gmail.com" title="E-Mail → mailto:yu2erer#gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://yuerer.com/Redis-6-%E5%89%96%E6%9E%90(%E4%BA%8C)-%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpeg"><meta itemprop="name" content="Yuerer"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Yuerer's Blog"><meta itemprop="description" content="钰儿的Blog"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Redis 6 剖析(二) 主从同步 | Yuerer's Blog"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Redis 6 剖析(二) 主从同步</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-04-03 23:31:20" itemprop="dateCreated datePublished" datetime="2021-04-03T23:31:20+08:00">2021-04-03</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a> </span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Waline：</span> <a title="waline" href="/Redis-6-%E5%89%96%E6%9E%90(%E4%BA%8C)-%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/Redis-6-%E5%89%96%E6%9E%90(%E4%BA%8C)-%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/" itemprop="commentCount"></span> </a></span><span class="post-meta-item" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="waline-pageview-count" data-path="/Redis-6-%E5%89%96%E6%9E%90(%E4%BA%8C)-%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/"></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>本篇是 <code>Redis 6</code> 剖析的第二篇，主要探讨 <code>Redis</code> 是怎么做主从同步的，对代码会有所删减。</p><h2 id="SLAVE"><a href="#SLAVE" class="headerlink" title="SLAVE"></a>SLAVE</h2><p>通常启用主从同步，只要在从服务器执行 <code>SLAVEOF HOST PORT</code> 即可，这个时候就会执行到 <code>replicaofCommand</code> 。由于主从同步是从服务器发起的，因此我们先从 <code>Slave</code> 开始进行剖析。</p><p><img data-src="/images/Redis6-Replication.png" alt="Redis6-Replication"></p><span id="more"></span><h2 id="repl-state"><a href="#repl-state" class="headerlink" title="repl_state"></a>repl_state</h2><p><code>Redis</code> 的主从同步，是通过状态机驱动的，因此有必要在本篇一开始前，就先看看有哪些状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    REPL_STATE_NONE = <span class="number">0</span>,            <span class="comment">/* No active replication */</span></span><br><span class="line">    REPL_STATE_CONNECT,             <span class="comment">/* Must connect to master */</span></span><br><span class="line">    REPL_STATE_CONNECTING,          <span class="comment">/* Connecting to master */</span></span><br><span class="line">    <span class="comment">/* --- Handshake states, must be ordered --- */</span></span><br><span class="line">    REPL_STATE_RECEIVE_PING_REPLY,  <span class="comment">/* Wait for PING reply */</span></span><br><span class="line">    REPL_STATE_SEND_HANDSHAKE,      <span class="comment">/* Send handshake sequance to master */</span></span><br><span class="line">    REPL_STATE_RECEIVE_AUTH_REPLY,  <span class="comment">/* Wait for AUTH reply */</span></span><br><span class="line">    REPL_STATE_RECEIVE_PORT_REPLY,  <span class="comment">/* Wait for REPLCONF reply */</span></span><br><span class="line">    REPL_STATE_RECEIVE_IP_REPLY,    <span class="comment">/* Wait for REPLCONF reply */</span></span><br><span class="line">    REPL_STATE_RECEIVE_CAPA_REPLY,  <span class="comment">/* Wait for REPLCONF reply */</span></span><br><span class="line">    REPL_STATE_SEND_PSYNC,          <span class="comment">/* Send PSYNC */</span></span><br><span class="line">    REPL_STATE_RECEIVE_PSYNC_REPLY, <span class="comment">/* Wait for PSYNC reply */</span></span><br><span class="line">    <span class="comment">/* --- End of handshake states --- */</span></span><br><span class="line">    REPL_STATE_TRANSFER,        <span class="comment">/* Receiving .rdb from master */</span></span><br><span class="line">    REPL_STATE_CONNECTED,       <span class="comment">/* Connected to master */</span></span><br><span class="line">&#125; repl_state;</span><br></pre></td></tr></table></figure><ul><li><code>REPL_STATE_NONE</code>，未启动同步。</li><li><code>REPL_STATE_CONNECT</code>，需要连接到 <code>Master</code> 。</li><li><code>REPL_STATE_RECEIVE_PING_REPLY</code>，等待 <code>PING</code> 的回包。</li><li><code>REPL_STATE_SEND_HANDSHAKE</code>，验证密码。</li><li><code>REPL_STATE_RECEIVE_AUTH_REPLY</code> ，等待 <code>AUTH</code> 的回包。</li><li><code>REPL_STATE_RECEIVE_PORT_REPLY</code>，等待 <code>REPLCONF</code> 针对端口的回包。</li><li><code>REPL_STATE_RECEIVE_IP_REPLY</code> ，等待 <code>REPLCONF</code> 针对IP的回包。</li><li><code>REPL_STATE_RECEIVE_CAPA_REPLY</code> ，等待 <code>REPLCONF</code> 针对”能力”(即支持的功能)的回包。</li><li><code>REPL_STATE_SEND_PSYNC</code> ，发送 <code>PSYNC</code> 。</li><li><code>REPL_STATE_RECEIVE_PSYNC_REPLY</code> ，等待 <code>PSYNC</code> 的回包。</li><li><code>REPL_STATE_TRANSFER</code> ，传送快照。</li><li><code>REPL_STATE_CONNECTED</code> ，主从同步完成。</li></ul><h3 id="replicaofCommand"><a href="#replicaofCommand" class="headerlink" title="replicaofCommand"></a>replicaofCommand</h3><p>拿到 <code>Master</code> 的 <code>IP</code> 和 <code>Port</code> 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">replicaofCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="type">long</span> port;</span><br><span class="line">    replicationSetMaster(c-&gt;argv[<span class="number">1</span>]-&gt;ptr, port);</span><br><span class="line">    addReply(c,shared.ok);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="replicationSetMaster"><a href="#replicationSetMaster" class="headerlink" title="replicationSetMaster"></a>replicationSetMaster</h3><p>断连所有的 <code>Slave</code> ，然后取消掉原先的主从连接（如果有），设置 <code>Cache Master</code> 为了复用 <code>PSYNC</code> （保存当前进度，不进行全量同步）。</p><ul><li>设置状态 <code>REPL_STATE_CONNECT</code> ，表示需要连接 <code>Master</code> 。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">replicationSetMaster</span><span class="params">(<span class="type">char</span> *ip, <span class="type">int</span> port)</span> &#123;</span><br><span class="line">    server.masterhost = sdsnew(ip);</span><br><span class="line">    server.masterport = port;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Force our slaves to resync with us as well. They may hopefully be able</span></span><br><span class="line"><span class="comment">     * to partially resync with us, but we can notify the replid change. */</span></span><br><span class="line">    disconnectSlaves();</span><br><span class="line">    cancelReplicationHandshake(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* Before destroying our master state, create a cached master using</span></span><br><span class="line"><span class="comment">     * our own parameters, to later PSYNC with the new master. */</span></span><br><span class="line">    <span class="keyword">if</span> (was_master) &#123;</span><br><span class="line">        replicationDiscardCachedMaster();</span><br><span class="line">        replicationCacheMasterUsingMyself();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server.repl_state = REPL_STATE_CONNECT;</span><br><span class="line">    connectWithMaster();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="connectWithMaster"><a href="#connectWithMaster" class="headerlink" title="connectWithMaster"></a>connectWithMaster</h3><p><code>Redis 6</code> 支持 <code>TLS</code>，为了简化剖析过程，此处默认不采用 <code>TLS 连接</code>。</p><ul><li><code>server.repl_transfer_lastio</code>，最后一次 IO 时间，用于超时处理。</li><li>设置状态 <code>REPL_STATE_CONNECTING</code> ，表示已连接到 <code>Master</code> 。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">connectWithMaster</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    server.repl_transfer_s = server.tls_replication ? connCreateTLS() : connCreateSocket();</span><br><span class="line">    <span class="keyword">if</span> (connConnect(server.repl_transfer_s, server.masterhost, server.masterport,</span><br><span class="line">                NET_FIRST_BIND_ADDR, syncWithMaster) == C_ERR) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Unable to connect to MASTER: %s&quot;</span>,</span><br><span class="line">                connGetLastError(server.repl_transfer_s));</span><br><span class="line">        connClose(server.repl_transfer_s);</span><br><span class="line">        server.repl_transfer_s = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server.repl_transfer_lastio = server.unixtime;</span><br><span class="line">    server.repl_state = REPL_STATE_CONNECTING;</span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">&quot;MASTER &lt;-&gt; REPLICA sync started&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="syncWithMaster"><a href="#syncWithMaster" class="headerlink" title="syncWithMaster"></a>syncWithMaster</h3><p><code>Slave → Master</code> 连接完成后，会进入到 <code>syncWithMaster</code> 回调。这个函数共有 <code>300多行</code>，因此分为多个部分讲解。</p><ol><li>若当前状态机状态为 <code>REPL_STATE_NONE</code> ，直接返回。</li><li>检查链接是否正常。</li></ol><p>这种情况主要是出现在 <code>Slave</code> 连接上 <code>Master</code> 之后，Client 后悔了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">syncWithMaster</span><span class="params">(connection *conn)</span> &#123;</span><br><span class="line">    <span class="type">char</span> tmpfile[<span class="number">256</span>], *err = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> dfd = <span class="number">-1</span>, maxtries = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> psync_result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If this event fired after the user turned the instance into a master</span></span><br><span class="line"><span class="comment">     * with SLAVEOF NO ONE we must just return ASAP. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.repl_state == REPL_STATE_NONE) &#123;</span><br><span class="line">        connClose(conn);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check for errors in the socket: after a non blocking connect() we</span></span><br><span class="line"><span class="comment">     * may find that the socket is in error state. */</span></span><br><span class="line">    <span class="keyword">if</span> (connGetState(conn) != CONN_STATE_CONNECTED) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Error condition on socket for SYNC: %s&quot;</span>,</span><br><span class="line">                connGetLastError(conn));</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p><code>REPL_STATE_CONNECTING</code> ，设置 <code>Read Handler</code> 为当前函数。</p></li><li><p>发送命令 <code>PING</code> 到 <code>Master</code> 。</p></li><li><p>设置状态 <code>REPL_STATE_RECEIVE_PING_REPLY</code> ，表示等待 <code>Master</code> 返回 <code>PONG</code> 。</p></li></ol><p>主要是因为 <code>Connect Handler</code> 只会执行一次，后面的状态机的处理流程都在本函数，因此需要再次进入该函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Send a PING to check the master is able to reply without errors. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_CONNECTING) &#123;</span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">&quot;Non blocking connect for SYNC fired the event.&quot;</span>);</span><br><span class="line">    <span class="comment">/* Delete the writable event so that the readable event remains</span></span><br><span class="line"><span class="comment">     * registered and we can wait for the PONG reply. */</span></span><br><span class="line">    connSetReadHandler(conn, syncWithMaster);</span><br><span class="line">    connSetWriteHandler(conn, <span class="literal">NULL</span>);</span><br><span class="line">    server.repl_state = REPL_STATE_RECEIVE_PING_REPLY;</span><br><span class="line">    <span class="comment">/* Send the PING, don&#x27;t check for errors at all, we have the timeout</span></span><br><span class="line"><span class="comment">     * that will take care about this. */</span></span><br><span class="line">    err = sendCommand(conn,<span class="string">&quot;PING&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">goto</span> write_error;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li><p>同步读 <code>Master</code> 对 <code>PING</code> 的回包，正常情况只要有回包都是没错误的，除非对方是旧版本。</p></li><li><p>设置状态 <code>REPL_STATE_SEND_HANDSHAKE</code> ，表示需要进行握手。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Receive the PONG command. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_RECEIVE_PING_REPLY) &#123;</span><br><span class="line">    err = receiveSynchronousResponse(conn);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We accept only two replies as valid, a positive +PONG reply</span></span><br><span class="line"><span class="comment">     * (we just check for &quot;+&quot;) or an authentication error.</span></span><br><span class="line"><span class="comment">     * Note that older versions of Redis replied with &quot;operation not</span></span><br><span class="line"><span class="comment">     * permitted&quot; instead of using a proper error code, so we test</span></span><br><span class="line"><span class="comment">     * both. */</span></span><br><span class="line">    <span class="keyword">if</span> (err[<span class="number">0</span>] != <span class="string">&#x27;+&#x27;</span> &amp;&amp;</span><br><span class="line">        <span class="built_in">strncmp</span>(err,<span class="string">&quot;-NOAUTH&quot;</span>,<span class="number">7</span>) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        <span class="built_in">strncmp</span>(err,<span class="string">&quot;-NOPERM&quot;</span>,<span class="number">7</span>) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        <span class="built_in">strncmp</span>(err,<span class="string">&quot;-ERR operation not permitted&quot;</span>,<span class="number">28</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Error reply to PING from master: &#x27;%s&#x27;&quot;</span>,err);</span><br><span class="line">        sdsfree(err);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverLog(LL_NOTICE,</span><br><span class="line">            <span class="string">&quot;Master replied to PING, replication can continue...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sdsfree(err);</span><br><span class="line">    err = <span class="literal">NULL</span>;</span><br><span class="line">    server.repl_state = REPL_STATE_SEND_HANDSHAKE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li><p>握手阶段主要是进行密码验证，将 <code>Slave</code> 的 <code>IP</code> 和 <code>PORT</code> 传给 <code>Master</code> 方便查询，同时告诉 <code>Master</code> 我当前的能力，比如 <code>EOF</code> 为我支持 <code>无盘传输</code> ， <code>psync2</code> 表示支持部分同步。</p></li><li><p>设置状态 <code>REPL_STATE_RECEIVE_AUTH_REPLY</code> ，表示等待认证回包。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_SEND_HANDSHAKE) &#123;</span><br><span class="line">    <span class="comment">/* AUTH with the master if required. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterauth) &#123;</span><br><span class="line">        <span class="type">char</span> *args[<span class="number">3</span>] = &#123;<span class="string">&quot;AUTH&quot;</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line">        <span class="type">size_t</span> lens[<span class="number">3</span>] = &#123;<span class="number">4</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> argc = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (server.masteruser) &#123;</span><br><span class="line">            args[argc] = server.masteruser;</span><br><span class="line">            lens[argc] = <span class="built_in">strlen</span>(server.masteruser);</span><br><span class="line">            argc++;</span><br><span class="line">        &#125;</span><br><span class="line">        args[argc] = server.masterauth;</span><br><span class="line">        lens[argc] = sdslen(server.masterauth);</span><br><span class="line">        argc++;</span><br><span class="line">        err = sendCommandArgv(conn, argc, args, lens);</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">goto</span> write_error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the slave port, so that Master&#x27;s INFO command can list the</span></span><br><span class="line"><span class="comment">     * slave listening port correctly. */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> port;</span><br><span class="line">        <span class="keyword">if</span> (server.slave_announce_port)</span><br><span class="line">            port = server.slave_announce_port;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (server.tls_replication &amp;&amp; server.tls_port)</span><br><span class="line">            port = server.tls_port;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            port = server.port;</span><br><span class="line">        sds portstr = sdsfromlonglong(port);</span><br><span class="line">        err = sendCommand(conn,<span class="string">&quot;REPLCONF&quot;</span>,</span><br><span class="line">                <span class="string">&quot;listening-port&quot;</span>,portstr, <span class="literal">NULL</span>);</span><br><span class="line">        sdsfree(portstr);</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">goto</span> write_error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the slave ip, so that Master&#x27;s INFO command can list the</span></span><br><span class="line"><span class="comment">     * slave IP address port correctly in case of port forwarding or NAT.</span></span><br><span class="line"><span class="comment">     * Skip REPLCONF ip-address if there is no slave-announce-ip option set. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.slave_announce_ip) &#123;</span><br><span class="line">        err = sendCommand(conn,<span class="string">&quot;REPLCONF&quot;</span>,</span><br><span class="line">                <span class="string">&quot;ip-address&quot;</span>,server.slave_announce_ip, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">goto</span> write_error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Inform the master of our (slave) capabilities.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * EOF: supports EOF-style RDB transfer for diskless replication.</span></span><br><span class="line"><span class="comment">     * PSYNC2: supports PSYNC v2, so understands +CONTINUE &lt;new repl ID&gt;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The master will ignore capabilities it does not understand. */</span></span><br><span class="line">    err = sendCommand(conn,<span class="string">&quot;REPLCONF&quot;</span>,</span><br><span class="line">            <span class="string">&quot;capa&quot;</span>,<span class="string">&quot;eof&quot;</span>,<span class="string">&quot;capa&quot;</span>,<span class="string">&quot;psync2&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">goto</span> write_error;</span><br><span class="line"></span><br><span class="line">    server.repl_state = REPL_STATE_RECEIVE_AUTH_REPLY;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="10"><li><p>检测认证情况。</p></li><li><p>设置状态 <code>REPL_STATE_RECEIVE_PORT_REPLY</code> ，表示等待 <code>Master</code> 确认端口配置是否正常。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_RECEIVE_AUTH_REPLY &amp;&amp; !server.masterauth)</span><br><span class="line">      server.repl_state = REPL_STATE_RECEIVE_PORT_REPLY;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Receive AUTH reply. */</span></span><br><span class="line">  <span class="keyword">if</span> (server.repl_state == REPL_STATE_RECEIVE_AUTH_REPLY) &#123;</span><br><span class="line">      err = receiveSynchronousResponse(conn);</span><br><span class="line">      <span class="keyword">if</span> (err[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">          serverLog(LL_WARNING,<span class="string">&quot;Unable to AUTH to MASTER: %s&quot;</span>,err);</span><br><span class="line">          sdsfree(err);</span><br><span class="line">          <span class="keyword">goto</span> error;</span><br><span class="line">      &#125;</span><br><span class="line">      sdsfree(err);</span><br><span class="line">      err = <span class="literal">NULL</span>;</span><br><span class="line">      server.repl_state = REPL_STATE_RECEIVE_PORT_REPLY;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol start="12"><li><p>检测端口配置情况。</p></li><li><p>设置状态 <code>REPL_STATE_RECEIVE_CAPA_REPLY</code>，表示 <code>Master</code> 确认能力回包。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_RECEIVE_IP_REPLY &amp;&amp; !server.slave_announce_ip)</span><br><span class="line">      server.repl_state = REPL_STATE_RECEIVE_CAPA_REPLY;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Receive REPLCONF ip-address reply. */</span></span><br><span class="line">  <span class="keyword">if</span> (server.repl_state == REPL_STATE_RECEIVE_IP_REPLY) &#123;</span><br><span class="line">      err = receiveSynchronousResponse(conn);</span><br><span class="line">      <span class="comment">/* Ignore the error if any, not all the Redis versions support</span></span><br><span class="line"><span class="comment">       * REPLCONF listening-port. */</span></span><br><span class="line">      <span class="keyword">if</span> (err[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">          serverLog(LL_NOTICE,<span class="string">&quot;(Non critical) Master does not understand &quot;</span></span><br><span class="line">                              <span class="string">&quot;REPLCONF ip-address: %s&quot;</span>, err);</span><br><span class="line">      &#125;</span><br><span class="line">      sdsfree(err);</span><br><span class="line">      server.repl_state = REPL_STATE_RECEIVE_CAPA_REPLY;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol start="14"><li><p>检测能力设置是否正常。</p></li><li><p>设置状态 <code>REPL_STATE_SEND_PSYNC</code> ，表示 开始进行同步。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Receive CAPA reply. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_RECEIVE_CAPA_REPLY) &#123;</span><br><span class="line">    err = receiveSynchronousResponse(conn);</span><br><span class="line">    <span class="comment">/* Ignore the error if any, not all the Redis versions support</span></span><br><span class="line"><span class="comment">     * REPLCONF capa. */</span></span><br><span class="line">    <span class="keyword">if</span> (err[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">&quot;(Non critical) Master does not understand &quot;</span></span><br><span class="line">                              <span class="string">&quot;REPLCONF capa: %s&quot;</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">    sdsfree(err);</span><br><span class="line">    err = <span class="literal">NULL</span>;</span><br><span class="line">    server.repl_state = REPL_STATE_SEND_PSYNC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="16"><li><p><code>slaveTryPartialResynchronization(conn, 0)</code> 表示给 <code>Master</code> 发送 <code>PSYNC ? -1</code> ? 为 <code>Master RunID</code> ， <code>-1</code> 为进度。</p></li><li><p>设置状态 <code>REPL_STATE_RECEIVE_PSYNC_REPLY</code> ，表示等待 <code>Master</code> 对 <code>PSYNC</code> 回包。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Try a partial resynchonization. If we don&#x27;t have a cached master</span></span><br><span class="line"><span class="comment">   * slaveTryPartialResynchronization() will at least try to use PSYNC</span></span><br><span class="line"><span class="comment">   * to start a full resynchronization so that we get the master replid</span></span><br><span class="line"><span class="comment">   * and the global offset, to try a partial resync at the next</span></span><br><span class="line"><span class="comment">   * reconnection attempt. */</span></span><br><span class="line">  <span class="keyword">if</span> (server.repl_state == REPL_STATE_SEND_PSYNC) &#123;</span><br><span class="line">      <span class="keyword">if</span> (slaveTryPartialResynchronization(conn,<span class="number">0</span>) == PSYNC_WRITE_ERROR) &#123;</span><br><span class="line">          err = sdsnew(<span class="string">&quot;Write error sending the PSYNC command.&quot;</span>);</span><br><span class="line">          abortFailover(<span class="string">&quot;Write error to failover target&quot;</span>);</span><br><span class="line">          <span class="keyword">goto</span> write_error;</span><br><span class="line">      &#125;</span><br><span class="line">      server.repl_state = REPL_STATE_RECEIVE_PSYNC_REPLY;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol start="18"><li><code>slaveTryPartialResynchronization(conn,1)</code> 表示同步读 <code>Master</code> 针对 <code>PSYNC</code> 的回包，看是要全量同步，还是要增量同步。不支持 <code>PSYNC</code> 则进行全量同步。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">psync_result = slaveTryPartialResynchronization(conn,<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (psync_result == PSYNC_WAIT_REPLY) <span class="keyword">return</span>; <span class="comment">/* Try again later... */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the status of the planned failover. We expect PSYNC_CONTINUE,</span></span><br><span class="line"><span class="comment">   * but there is nothing technically wrong with a full resync which</span></span><br><span class="line"><span class="comment">   * could happen in edge cases. */</span></span><br><span class="line">  <span class="keyword">if</span> (server.failover_state == FAILOVER_IN_PROGRESS) &#123;</span><br><span class="line">      <span class="keyword">if</span> (psync_result == PSYNC_CONTINUE || psync_result == PSYNC_FULLRESYNC) &#123;</span><br><span class="line">          clearFailoverState();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          abortFailover(<span class="string">&quot;Failover target rejected psync request&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol start="19"><li>能够增量同步，在 <code>slaveTryPartialResynchronization</code> 中设置状态 <code>REPL_STATE_CONNECTED</code> ，表示已连接成功，直接返回。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If the master is in an transient error, we should try to PSYNC</span></span><br><span class="line"><span class="comment"> * from scratch later, so go to the error path. This happens when</span></span><br><span class="line"><span class="comment"> * the server is loading the dataset or is not connected with its</span></span><br><span class="line"><span class="comment"> * master and so forth. */</span></span><br><span class="line"><span class="keyword">if</span> (psync_result == PSYNC_TRY_LATER) <span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Note: if PSYNC does not return WAIT_REPLY, it will take care of</span></span><br><span class="line"><span class="comment"> * uninstalling the read handler from the file descriptor. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (psync_result == PSYNC_CONTINUE) &#123;</span><br><span class="line">    serverLog(LL_NOTICE, <span class="string">&quot;MASTER &lt;-&gt; REPLICA sync: Master accepted a Partial Resynchronization.&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (server.supervised_mode == SUPERVISED_SYSTEMD) &#123;</span><br><span class="line">        redisCommunicateSystemd(<span class="string">&quot;STATUS=MASTER &lt;-&gt; REPLICA sync: Partial Resynchronization accepted. Ready to accept connections in read-write mode.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="20"><li>不支持增量同步，与所有 Slaves 端口，清空 <code>backLog</code> ，毕竟要重头开始了，通过 <code>SYNC</code> 进行同步。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* PSYNC failed or is not supported: we want our slaves to resync with us</span></span><br><span class="line"><span class="comment"> * as well, if we have any sub-slaves. The master may transfer us an</span></span><br><span class="line"><span class="comment"> * entirely different data set and we have no way to incrementally feed</span></span><br><span class="line"><span class="comment"> * our slaves after that. */</span></span><br><span class="line">disconnectSlaves(); <span class="comment">/* Force our slaves to resync with us as well. */</span></span><br><span class="line">freeReplicationBacklog(); <span class="comment">/* Don&#x27;t allow our chained slaves to PSYNC. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Fall back to SYNC if needed. Otherwise psync_result == PSYNC_FULLRESYNC</span></span><br><span class="line"><span class="comment"> * and the server.master_replid and master_initial_offset are</span></span><br><span class="line"><span class="comment"> * already populated. */</span></span><br><span class="line"><span class="keyword">if</span> (psync_result == PSYNC_NOT_SUPPORTED) &#123;</span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">&quot;Retrying with SYNC...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (connSyncWrite(conn,<span class="string">&quot;SYNC\r\n&quot;</span>,<span class="number">6</span>,server.repl_syncio_timeout*<span class="number">1000</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;I/O error writing to MASTER: %s&quot;</span>,</span><br><span class="line">            strerror(errno));</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="21"><li>通过 <code>RDB</code> 文件传输，则先创建临时文件。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Prepare a suitable temp file for bulk transfer */</span></span><br><span class="line"><span class="keyword">if</span> (!useDisklessLoad()) &#123;</span><br><span class="line">    <span class="keyword">while</span>(maxtries--) &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(tmpfile,<span class="number">256</span>,</span><br><span class="line">            <span class="string">&quot;temp-%d.%ld.rdb&quot;</span>,(<span class="type">int</span>)server.unixtime,(<span class="type">long</span> <span class="type">int</span>)getpid());</span><br><span class="line">        dfd = open(tmpfile,O_CREAT|O_WRONLY|O_EXCL,<span class="number">0644</span>);</span><br><span class="line">        <span class="keyword">if</span> (dfd != <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Opening the temp file needed for MASTER &lt;-&gt; REPLICA synchronization: %s&quot;</span>,strerror(errno));</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    server.repl_transfer_tmpfile = zstrdup(tmpfile);</span><br><span class="line">    server.repl_transfer_fd = dfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="22"><li>设置 <code>Read Handler</code>，读文件，同时 设置状态 <code>REPL_STATE_TRANSFER</code> ，表示文件传送中。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Setup the non blocking download of the bulk file. */</span></span><br><span class="line"><span class="keyword">if</span> (connSetReadHandler(conn, readSyncBulkPayload)</span><br><span class="line">        == C_ERR)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> conninfo[CONN_INFO_LEN];</span><br><span class="line">    serverLog(LL_WARNING,</span><br><span class="line">        <span class="string">&quot;Can&#x27;t create readable event for SYNC: %s (%s)&quot;</span>,</span><br><span class="line">        strerror(errno), connGetInfo(conn, conninfo, <span class="keyword">sizeof</span>(conninfo)));</span><br><span class="line">    <span class="keyword">goto</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server.repl_state = REPL_STATE_TRANSFER;</span><br><span class="line">server.repl_transfer_size = <span class="number">-1</span>;</span><br><span class="line">server.repl_transfer_read = <span class="number">0</span>;</span><br><span class="line">server.repl_transfer_last_fsync_off = <span class="number">0</span>;</span><br><span class="line">server.repl_transfer_lastio = server.unixtime;</span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><h2 id="slaveTryPartialResynchronization"><a href="#slaveTryPartialResynchronization" class="headerlink" title="slaveTryPartialResynchronization"></a>slaveTryPartialResynchronization</h2><p><code>slaveTryPartialResynchronization</code> 主要是和 <code>Master</code> 通信获取是否可以增量同步的信息。</p><p>前半部分，则是通过发送命令 <code>PSYNC</code> 来进行对接， <code>cached_master</code> 是之前意外断开的 <code>Master</code> 节点信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PSYNC_WRITE_ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PSYNC_WAIT_REPLY 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PSYNC_CONTINUE 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PSYNC_FULLRESYNC 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PSYNC_NOT_SUPPORTED 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PSYNC_TRY_LATER 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">slaveTryPartialResynchronization</span><span class="params">(connection *conn, <span class="type">int</span> read_reply)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *psync_replid;</span><br><span class="line">    <span class="type">char</span> psync_offset[<span class="number">32</span>];</span><br><span class="line">    sds reply;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Writing half */</span></span><br><span class="line">    <span class="keyword">if</span> (!read_reply) &#123;</span><br><span class="line">        <span class="comment">/* Initially set master_initial_offset to -1 to mark the current</span></span><br><span class="line"><span class="comment">         * master replid and offset as not valid. Later if we&#x27;ll be able to do</span></span><br><span class="line"><span class="comment">         * a FULL resync using the PSYNC command we&#x27;ll set the offset at the</span></span><br><span class="line"><span class="comment">         * right value, so that this information will be propagated to the</span></span><br><span class="line"><span class="comment">         * client structure representing the master into server.master. */</span></span><br><span class="line">        server.master_initial_offset = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (server.cached_master) &#123;</span><br><span class="line">            psync_replid = server.cached_master-&gt;replid;</span><br><span class="line">            <span class="built_in">snprintf</span>(psync_offset,<span class="keyword">sizeof</span>(psync_offset),<span class="string">&quot;%lld&quot;</span>, server.cached_master-&gt;reploff+<span class="number">1</span>);</span><br><span class="line">            serverLog(LL_NOTICE,<span class="string">&quot;Trying a partial resynchronization (request %s:%s).&quot;</span>, psync_replid, psync_offset);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            serverLog(LL_NOTICE,<span class="string">&quot;Partial resynchronization not possible (no cached master)&quot;</span>);</span><br><span class="line">            psync_replid = <span class="string">&quot;?&quot;</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(psync_offset,<span class="string">&quot;-1&quot;</span>,<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Issue the PSYNC command, if this is a master with a failover in</span></span><br><span class="line"><span class="comment">         * progress then send the failover argument to the replica to cause it</span></span><br><span class="line"><span class="comment">         * to become a master */</span></span><br><span class="line">        <span class="keyword">if</span> (server.failover_state == FAILOVER_IN_PROGRESS) &#123;</span><br><span class="line">            reply = sendCommand(conn,<span class="string">&quot;PSYNC&quot;</span>,psync_replid,psync_offset,<span class="string">&quot;FAILOVER&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            reply = sendCommand(conn,<span class="string">&quot;PSYNC&quot;</span>,psync_replid,psync_offset,<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (reply != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            serverLog(LL_WARNING,<span class="string">&quot;Unable to send PSYNC to master: %s&quot;</span>,reply);</span><br><span class="line">            sdsfree(reply);</span><br><span class="line">            connSetReadHandler(conn, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">return</span> PSYNC_WRITE_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> PSYNC_WAIT_REPLY;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>后半部分则是读到 <code>Master</code> 的回包，并确认其是 <code>全量同步 +FULLRESYNC</code> 还是 <code>增量同步 +CONTINUE</code>。</p><p>其中 <code>RUN_ID</code> 为一个40字符的随机值，每次启动实例随机生成， <code>offset</code> 相当于一个偏移量，用于之后同步完 <code>RDB</code> 后进行增量同步。</p><p><code>replid2</code> 的出现主要是因为若从服务器被提拔为主服务器，其他的从服务器连到现在新的主服务器时，若直接校验 <code>replid</code> 则必然失败，因此出现了这个变量来保存上次同步的主服务器ID。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* Reading half */</span></span><br><span class="line">    reply = receiveSynchronousResponse(conn);</span><br><span class="line">    <span class="keyword">if</span> (sdslen(reply) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* The master may send empty newlines after it receives PSYNC</span></span><br><span class="line"><span class="comment">         * and before to reply, just to keep the connection alive. */</span></span><br><span class="line">        sdsfree(reply);</span><br><span class="line">        <span class="keyword">return</span> PSYNC_WAIT_REPLY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    connSetReadHandler(conn, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(reply,<span class="string">&quot;+FULLRESYNC&quot;</span>,<span class="number">11</span>)) &#123;</span><br><span class="line">        <span class="type">char</span> *replid = <span class="literal">NULL</span>, *offset = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* FULL RESYNC, parse the reply in order to extract the replid</span></span><br><span class="line"><span class="comment">         * and the replication offset. */</span></span><br><span class="line">        replid = <span class="built_in">strchr</span>(reply,<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (replid) &#123;</span><br><span class="line">            replid++;</span><br><span class="line">            offset = <span class="built_in">strchr</span>(replid,<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (offset) offset++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!replid || !offset || (offset-replid<span class="number">-1</span>) != CONFIG_RUN_ID_SIZE) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">&quot;Master replied with wrong +FULLRESYNC syntax.&quot;</span>);</span><br><span class="line">            <span class="comment">/* This is an unexpected condition, actually the +FULLRESYNC</span></span><br><span class="line"><span class="comment">             * reply means that the master supports PSYNC, but the reply</span></span><br><span class="line"><span class="comment">             * format seems wrong. To stay safe we blank the master</span></span><br><span class="line"><span class="comment">             * replid to make sure next PSYNCs will fail. */</span></span><br><span class="line">            <span class="built_in">memset</span>(server.master_replid,<span class="number">0</span>,CONFIG_RUN_ID_SIZE+<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(server.master_replid, replid, offset-replid<span class="number">-1</span>);</span><br><span class="line">            server.master_replid[CONFIG_RUN_ID_SIZE] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            server.master_initial_offset = strtoll(offset,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">            serverLog(LL_NOTICE,<span class="string">&quot;Full resync from master: %s:%lld&quot;</span>,</span><br><span class="line">                server.master_replid,</span><br><span class="line">                server.master_initial_offset);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* We are going to full resync, discard the cached master structure. */</span></span><br><span class="line">        replicationDiscardCachedMaster();</span><br><span class="line">        sdsfree(reply);</span><br><span class="line">        <span class="keyword">return</span> PSYNC_FULLRESYNC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(reply,<span class="string">&quot;+CONTINUE&quot;</span>,<span class="number">9</span>)) &#123;</span><br><span class="line">        <span class="comment">/* Partial resync was accepted. */</span></span><br><span class="line">        serverLog(LL_NOTICE,</span><br><span class="line">            <span class="string">&quot;Successful partial resynchronization with master.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Check the new replication ID advertised by the master. If it</span></span><br><span class="line"><span class="comment">         * changed, we need to set the new ID as primary ID, and set or</span></span><br><span class="line"><span class="comment">         * secondary ID as the old master ID up to the current offset, so</span></span><br><span class="line"><span class="comment">         * that our sub-slaves will be able to PSYNC with us after a</span></span><br><span class="line"><span class="comment">         * disconnection. */</span></span><br><span class="line">        <span class="type">char</span> *start = reply+<span class="number">10</span>;</span><br><span class="line">        <span class="type">char</span> *end = reply+<span class="number">9</span>;</span><br><span class="line">        <span class="keyword">while</span>(end[<span class="number">0</span>] != <span class="string">&#x27;\r&#x27;</span> &amp;&amp; end[<span class="number">0</span>] != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; end[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span>) end++;</span><br><span class="line">        <span class="keyword">if</span> (end-start == CONFIG_RUN_ID_SIZE) &#123;</span><br><span class="line">            <span class="type">char</span> new[CONFIG_RUN_ID_SIZE+<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">memcpy</span>(new,start,CONFIG_RUN_ID_SIZE);</span><br><span class="line">            new[CONFIG_RUN_ID_SIZE] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(new,server.cached_master-&gt;replid)) &#123;</span><br><span class="line">                <span class="comment">/* Master ID changed. */</span></span><br><span class="line">                serverLog(LL_WARNING,<span class="string">&quot;Master replication ID changed to %s&quot;</span>,new);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Set the old ID as our ID2, up to the current offset+1. */</span></span><br><span class="line">                <span class="built_in">memcpy</span>(server.replid2,server.cached_master-&gt;replid,</span><br><span class="line">                    <span class="keyword">sizeof</span>(server.replid2));</span><br><span class="line">                server.second_replid_offset = server.master_repl_offset+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Update the cached master ID and our own primary ID to the</span></span><br><span class="line"><span class="comment">                 * new one. */</span></span><br><span class="line">                <span class="built_in">memcpy</span>(server.replid,new,<span class="keyword">sizeof</span>(server.replid));</span><br><span class="line">                <span class="built_in">memcpy</span>(server.cached_master-&gt;replid,new,<span class="keyword">sizeof</span>(server.replid));</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Disconnect all the sub-slaves: they need to be notified. */</span></span><br><span class="line">                disconnectSlaves();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Setup the replication to continue. */</span></span><br><span class="line">        sdsfree(reply);</span><br><span class="line">        replicationResurrectCachedMaster(conn);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If this instance was restarted and we read the metadata to</span></span><br><span class="line"><span class="comment">         * PSYNC from the persistence file, our replication backlog could</span></span><br><span class="line"><span class="comment">         * be still not initialized. Create it. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.repl_backlog == <span class="literal">NULL</span>) createReplicationBacklog();</span><br><span class="line">        <span class="keyword">return</span> PSYNC_CONTINUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we reach this point we received either an error (since the master does</span></span><br><span class="line"><span class="comment">     * not understand PSYNC or because it is in a special state and cannot</span></span><br><span class="line"><span class="comment">     * serve our request), or an unexpected reply from the master.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Return PSYNC_NOT_SUPPORTED on errors we don&#x27;t understand, otherwise</span></span><br><span class="line"><span class="comment">     * return PSYNC_TRY_LATER if we believe this is a transient error. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(reply,<span class="string">&quot;-NOMASTERLINK&quot;</span>,<span class="number">13</span>) ||</span><br><span class="line">        !<span class="built_in">strncmp</span>(reply,<span class="string">&quot;-LOADING&quot;</span>,<span class="number">8</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        serverLog(LL_NOTICE,</span><br><span class="line">            <span class="string">&quot;Master is currently unable to PSYNC &quot;</span></span><br><span class="line">            <span class="string">&quot;but should be in the future: %s&quot;</span>, reply);</span><br><span class="line">        sdsfree(reply);</span><br><span class="line">        <span class="keyword">return</span> PSYNC_TRY_LATER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncmp</span>(reply,<span class="string">&quot;-ERR&quot;</span>,<span class="number">4</span>)) &#123;</span><br><span class="line">        <span class="comment">/* If it&#x27;s not an error, log the unexpected event. */</span></span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">&quot;Unexpected reply to PSYNC from master: %s&quot;</span>, reply);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverLog(LL_NOTICE,</span><br><span class="line">            <span class="string">&quot;Master does not support PSYNC or is in &quot;</span></span><br><span class="line">            <span class="string">&quot;error state (reply: %s)&quot;</span>, reply);</span><br><span class="line">    &#125;</span><br><span class="line">    sdsfree(reply);</span><br><span class="line">    replicationDiscardCachedMaster();</span><br><span class="line">    <span class="keyword">return</span> PSYNC_NOT_SUPPORTED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="readSyncBulkPayload"><a href="#readSyncBulkPayload" class="headerlink" title="readSyncBulkPayload"></a>readSyncBulkPayload</h2><p><code>readSyncBulkPayload</code> 主要负责读取 <code>Master</code> 的 <code>RDB</code> 文件（也可以是无盘传输）。</p><ol><li>如果刚开始传输（通过 <code>server.repl_transfer_size == 1</code> 判断），则先检查协议，同时查看是通过文件传输还是无盘传输，如果是文件，则可以提前获取文件大小，否则通过 <code>EOF</code> 标记代表无盘传输，以 <code>eofmark</code> 作为结尾的标记。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REPL_MAX_WRITTEN_BEFORE_FSYNC (1024*1024*8) <span class="comment">/* 8 MB */</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">readSyncBulkPayload</span><span class="params">(connection *conn)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[PROTO_IOBUF_LEN];</span><br><span class="line">    <span class="type">ssize_t</span> nread, readlen, nwritten;</span><br><span class="line">    <span class="type">int</span> use_diskless_load = useDisklessLoad();</span><br><span class="line">    dbBackup *diskless_load_backup = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> empty_db_flags = server.repl_slave_lazy_flush ? EMPTYDB_ASYNC :</span><br><span class="line">                                                        EMPTYDB_NO_FLAGS;</span><br><span class="line">    <span class="type">off_t</span> left;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Static vars used to hold the EOF mark, and the last bytes received</span></span><br><span class="line"><span class="comment">     * from the server: when they match, we reached the end of the transfer. */</span></span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> eofmark[CONFIG_RUN_ID_SIZE];</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> lastbytes[CONFIG_RUN_ID_SIZE];</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> usemark = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If repl_transfer_size == -1 we still have to read the bulk length</span></span><br><span class="line"><span class="comment">     * from the master reply. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.repl_transfer_size == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (connSyncReadLine(conn,buf,<span class="number">1024</span>,server.repl_syncio_timeout*<span class="number">1000</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">&quot;I/O error reading bulk count from MASTER: %s&quot;</span>,</span><br><span class="line">                strerror(errno));</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (buf[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">&quot;MASTER aborted replication with an error: %s&quot;</span>,</span><br><span class="line">                buf+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (buf[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">/* At this stage just a newline works as a PING in order to take</span></span><br><span class="line"><span class="comment">             * the connection live. So we refresh our last interaction</span></span><br><span class="line"><span class="comment">             * timestamp. */</span></span><br><span class="line">            server.repl_transfer_lastio = server.unixtime;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (buf[<span class="number">0</span>] != <span class="string">&#x27;$&#x27;</span>) &#123;</span><br><span class="line">            serverLog(LL_WARNING,<span class="string">&quot;Bad protocol from MASTER, the first byte is not &#x27;$&#x27; (we received &#x27;%s&#x27;), are you sure the host and port are right?&quot;</span>, buf);</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* There are two possible forms for the bulk payload. One is the</span></span><br><span class="line"><span class="comment">         * usual $&lt;count&gt; bulk format. The other is used for diskless transfers</span></span><br><span class="line"><span class="comment">         * when the master does not know beforehand the size of the file to</span></span><br><span class="line"><span class="comment">         * transfer. In the latter case, the following format is used:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * $EOF:&lt;40 bytes delimiter&gt;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * At the end of the file the announced delimiter is transmitted. The</span></span><br><span class="line"><span class="comment">         * delimiter is long and random enough that the probability of a</span></span><br><span class="line"><span class="comment">         * collision with the actual file content can be ignored. */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strncmp</span>(buf+<span class="number">1</span>,<span class="string">&quot;EOF:&quot;</span>,<span class="number">4</span>) == <span class="number">0</span> &amp;&amp; <span class="built_in">strlen</span>(buf+<span class="number">5</span>) &gt;= CONFIG_RUN_ID_SIZE) &#123;</span><br><span class="line">            usemark = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(eofmark,buf+<span class="number">5</span>,CONFIG_RUN_ID_SIZE);</span><br><span class="line">            <span class="built_in">memset</span>(lastbytes,<span class="number">0</span>,CONFIG_RUN_ID_SIZE);</span><br><span class="line">            <span class="comment">/* Set any repl_transfer_size to avoid entering this code path</span></span><br><span class="line"><span class="comment">             * at the next call. */</span></span><br><span class="line">            server.repl_transfer_size = <span class="number">0</span>;</span><br><span class="line">            serverLog(LL_NOTICE,</span><br><span class="line">                <span class="string">&quot;MASTER &lt;-&gt; REPLICA sync: receiving streamed RDB from master with EOF %s&quot;</span>,</span><br><span class="line">                use_diskless_load? <span class="string">&quot;to parser&quot;</span>:<span class="string">&quot;to disk&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            usemark = <span class="number">0</span>;</span><br><span class="line">            server.repl_transfer_size = strtol(buf+<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">            serverLog(LL_NOTICE,</span><br><span class="line">                <span class="string">&quot;MASTER &lt;-&gt; REPLICA sync: receiving %lld bytes from master %s&quot;</span>,</span><br><span class="line">                (<span class="type">long</span> <span class="type">long</span>) server.repl_transfer_size,</span><br><span class="line">                use_diskless_load? <span class="string">&quot;to parser&quot;</span>:<span class="string">&quot;to disk&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>非无盘加载 则无论文件传输还是无盘传输都先写入文件再读取。</li></ol><p>若是无盘传输，通过 <code>eofmark</code> 与 <code>lastbytes</code> 对比得到是否传输完成。</p><p><code>Redis</code> 源码将 无盘加载和有盘加载的代码进行拆分，为了方便剖析，此处进行合并。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!use_diskless_load) &#123;</span><br><span class="line">    <span class="comment">/* Read the data from the socket, store it to a file and search</span></span><br><span class="line"><span class="comment">     * for the EOF. */</span></span><br><span class="line">    <span class="keyword">if</span> (usemark) &#123;</span><br><span class="line">        readlen = <span class="keyword">sizeof</span>(buf);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        left = server.repl_transfer_size - server.repl_transfer_read;</span><br><span class="line">        readlen = (left &lt; (<span class="type">signed</span>)<span class="keyword">sizeof</span>(buf)) ? left : (<span class="type">signed</span>)<span class="keyword">sizeof</span>(buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nread = connRead(conn,buf,readlen);</span><br><span class="line">    <span class="keyword">if</span> (nread &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (connGetState(conn) == CONN_STATE_CONNECTED) &#123;</span><br><span class="line">            <span class="comment">/* equivalent to EAGAIN */</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;I/O error trying to sync with MASTER: %s&quot;</span>,</span><br><span class="line">            (nread == <span class="number">-1</span>) ? strerror(errno) : <span class="string">&quot;connection lost&quot;</span>);</span><br><span class="line">        cancelReplicationHandshake(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    atomicIncr(server.stat_net_input_bytes, nread);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When a mark is used, we want to detect EOF asap in order to avoid</span></span><br><span class="line"><span class="comment">     * writing the EOF mark into the file... */</span></span><br><span class="line">    <span class="type">int</span> eof_reached = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (usemark) &#123;</span><br><span class="line">        <span class="comment">/* Update the last bytes array, and check if it matches our</span></span><br><span class="line"><span class="comment">         * delimiter. */</span></span><br><span class="line">        <span class="keyword">if</span> (nread &gt;= CONFIG_RUN_ID_SIZE) &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(lastbytes,buf+nread-CONFIG_RUN_ID_SIZE,</span><br><span class="line">                   CONFIG_RUN_ID_SIZE);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> rem = CONFIG_RUN_ID_SIZE-nread;</span><br><span class="line">            memmove(lastbytes,lastbytes+nread,rem);</span><br><span class="line">            <span class="built_in">memcpy</span>(lastbytes+rem,buf,nread);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">memcmp</span>(lastbytes,eofmark,CONFIG_RUN_ID_SIZE) == <span class="number">0</span>)</span><br><span class="line">            eof_reached = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Update the last I/O time for the replication transfer (used in</span></span><br><span class="line"><span class="comment">     * order to detect timeouts during replication), and write what we</span></span><br><span class="line"><span class="comment">     * got from the socket to the dump file on disk. */</span></span><br><span class="line">    server.repl_transfer_lastio = server.unixtime;</span><br><span class="line">    <span class="keyword">if</span> ((nwritten = write(server.repl_transfer_fd,buf,nread)) != nread) &#123;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">&quot;Write error or short write writing to the DB dump file &quot;</span></span><br><span class="line">            <span class="string">&quot;needed for MASTER &lt;-&gt; REPLICA synchronization: %s&quot;</span>,</span><br><span class="line">            (nwritten == <span class="number">-1</span>) ? strerror(errno) : <span class="string">&quot;short write&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    server.repl_transfer_read += nread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Delete the last 40 bytes from the file if we reached EOF. */</span></span><br><span class="line">    <span class="keyword">if</span> (usemark &amp;&amp; eof_reached) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ftruncate(server.repl_transfer_fd,</span><br><span class="line">            server.repl_transfer_read - CONFIG_RUN_ID_SIZE) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">&quot;Error truncating the RDB file received from the master &quot;</span></span><br><span class="line">                <span class="string">&quot;for SYNC: %s&quot;</span>, strerror(errno));</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Sync data on disk from time to time, otherwise at the end of the</span></span><br><span class="line"><span class="comment">     * transfer we may suffer a big delay as the memory buffers are copied</span></span><br><span class="line"><span class="comment">     * into the actual disk. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.repl_transfer_read &gt;=</span><br><span class="line">        server.repl_transfer_last_fsync_off + REPL_MAX_WRITTEN_BEFORE_FSYNC)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">off_t</span> sync_size = server.repl_transfer_read -</span><br><span class="line">                          server.repl_transfer_last_fsync_off;</span><br><span class="line">        rdb_fsync_range(server.repl_transfer_fd,</span><br><span class="line">            server.repl_transfer_last_fsync_off, sync_size);</span><br><span class="line">        server.repl_transfer_last_fsync_off += sync_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if the transfer is now complete */</span></span><br><span class="line">    <span class="keyword">if</span> (!usemark) &#123;</span><br><span class="line">        <span class="keyword">if</span> (server.repl_transfer_read == server.repl_transfer_size)</span><br><span class="line">            eof_reached = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the transfer is yet not complete, we need to read more, so</span></span><br><span class="line"><span class="comment">     * return ASAP and wait for the handler to be called again. */</span></span><br><span class="line">    <span class="keyword">if</span> (!eof_reached) <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* We reach this point in one of the following cases:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. The replica is using diskless replication, that is, it reads data</span></span><br><span class="line"><span class="comment"> *    directly from the socket to the Redis memory, without using</span></span><br><span class="line"><span class="comment"> *    a temporary RDB file on disk. In that case we just block and</span></span><br><span class="line"><span class="comment"> *    read everything from the socket.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. Or when we are done reading from the socket to the RDB file, in</span></span><br><span class="line"><span class="comment"> *    such case we want just to read the RDB file in memory. */</span></span><br><span class="line">serverLog(LL_NOTICE, <span class="string">&quot;MASTER &lt;-&gt; REPLICA sync: Flushing old data&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We need to stop any AOF rewriting child before flusing and parsing</span></span><br><span class="line"><span class="comment"> * the RDB, otherwise we&#x27;ll create a copy-on-write disaster. */</span></span><br><span class="line"><span class="keyword">if</span> (server.aof_state != AOF_OFF) stopAppendOnly();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* When diskless RDB loading is used by replicas, it may be configured</span></span><br><span class="line"><span class="comment"> * in order to save the current DB instead of throwing it away,</span></span><br><span class="line"><span class="comment"> * so that we can restore it in case of failed transfer. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Ensure background save doesn&#x27;t overwrite synced data */</span></span><br><span class="line">    <span class="keyword">if</span> (server.child_type == CHILD_TYPE_RDB) &#123;</span><br><span class="line">        serverLog(LL_NOTICE,</span><br><span class="line">            <span class="string">&quot;Replica is about to load the RDB file received from the &quot;</span></span><br><span class="line">            <span class="string">&quot;master, but there is a pending RDB child running. &quot;</span></span><br><span class="line">            <span class="string">&quot;Killing process %ld and removing its temp file to avoid &quot;</span></span><br><span class="line">            <span class="string">&quot;any race&quot;</span>,</span><br><span class="line">            (<span class="type">long</span>) server.child_pid);</span><br><span class="line">        killRDBChild();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure the new file (also used for persistence) is fully synced</span></span><br><span class="line"><span class="comment">     * (not covered by earlier calls to rdb_fsync_range). */</span></span><br><span class="line">    <span class="keyword">if</span> (fsync(server.repl_transfer_fd) == <span class="number">-1</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">&quot;Failed trying to sync the temp DB to disk in &quot;</span></span><br><span class="line">            <span class="string">&quot;MASTER &lt;-&gt; REPLICA synchronization: %s&quot;</span>,</span><br><span class="line">            strerror(errno));</span><br><span class="line">        cancelReplicationHandshake(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Rename rdb like renaming rewrite aof asynchronously. */</span></span><br><span class="line">    <span class="type">int</span> old_rdb_fd = open(server.rdb_filename,O_RDONLY|O_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span> (rename(server.repl_transfer_tmpfile,server.rdb_filename) == <span class="number">-1</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">&quot;Failed trying to rename the temp DB into %s in &quot;</span></span><br><span class="line">            <span class="string">&quot;MASTER &lt;-&gt; REPLICA synchronization: %s&quot;</span>,</span><br><span class="line">            server.rdb_filename, strerror(errno));</span><br><span class="line">        cancelReplicationHandshake(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (old_rdb_fd != <span class="number">-1</span>) close(old_rdb_fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Close old rdb asynchronously. */</span></span><br><span class="line">    <span class="keyword">if</span> (old_rdb_fd != <span class="number">-1</span>) bioCreateCloseJob(old_rdb_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rdbLoad(server.rdb_filename,&amp;rsi,RDBFLAGS_REPLICATION) != C_OK) &#123;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">&quot;Failed trying to load the MASTER synchronization &quot;</span></span><br><span class="line">            <span class="string">&quot;DB from disk&quot;</span>);</span><br><span class="line">        cancelReplicationHandshake(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (server.rdb_del_sync_files &amp;&amp; allPersistenceDisabled()) &#123;</span><br><span class="line">            serverLog(LL_NOTICE,<span class="string">&quot;Removing the RDB file obtained from &quot;</span></span><br><span class="line">                                <span class="string">&quot;the master. This replica has persistence &quot;</span></span><br><span class="line">                                <span class="string">&quot;disabled&quot;</span>);</span><br><span class="line">            bg_unlink(server.rdb_filename);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Note that there&#x27;s no point in restarting the AOF on sync failure,</span></span><br><span class="line"><span class="comment">           it&#x27;ll be restarted when sync succeeds or replica promoted. */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Cleanup. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.rdb_del_sync_files &amp;&amp; allPersistenceDisabled()) &#123;</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">&quot;Removing the RDB file obtained from &quot;</span></span><br><span class="line">                            <span class="string">&quot;the master. This replica has persistence &quot;</span></span><br><span class="line">                            <span class="string">&quot;disabled&quot;</span>);</span><br><span class="line">        bg_unlink(server.rdb_filename);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    zfree(server.repl_transfer_tmpfile);</span><br><span class="line">    close(server.repl_transfer_fd);</span><br><span class="line">    server.repl_transfer_fd = <span class="number">-1</span>;</span><br><span class="line">    server.repl_transfer_tmpfile = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>无盘加载</li></ol><p>删除 <code>socket</code> 的 <code>Read Handler</code> ，因为后续的加载操作通过 <code>RIO</code> 去加载，一边读取 <code>TCP流</code>，一边进行加载。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (use_diskless_load &amp;&amp;</span><br><span class="line">    server.repl_diskless_load == REPL_DISKLESS_LOAD_SWAPDB)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Create a backup of server.db[] and initialize to empty</span></span><br><span class="line"><span class="comment">     * dictionaries. */</span></span><br><span class="line">    diskless_load_backup = disklessLoadMakeBackup();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* We call to emptyDb even in case of REPL_DISKLESS_LOAD_SWAPDB</span></span><br><span class="line"><span class="comment"> * (Where disklessLoadMakeBackup left server.db empty) because we</span></span><br><span class="line"><span class="comment"> * want to execute all the auxiliary logic of emptyDb (Namely,</span></span><br><span class="line"><span class="comment"> * fire module events) */</span></span><br><span class="line">emptyDb(<span class="number">-1</span>,empty_db_flags,replicationEmptyDbCallback);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Before loading the DB into memory we need to delete the readable</span></span><br><span class="line"><span class="comment"> * handler, otherwise it will get called recursively since</span></span><br><span class="line"><span class="comment"> * rdbLoad() will call the event loop to process events from time to</span></span><br><span class="line"><span class="comment"> * time for non blocking loading. */</span></span><br><span class="line">connSetReadHandler(conn, <span class="literal">NULL</span>);</span><br><span class="line">serverLog(LL_NOTICE, <span class="string">&quot;MASTER &lt;-&gt; REPLICA sync: Loading DB in memory&quot;</span>);</span><br><span class="line">rdbSaveInfo rsi = RDB_SAVE_INFO_INIT;</span><br><span class="line"><span class="keyword">if</span> (use_diskless_load) &#123;</span><br><span class="line">    rio rdb;</span><br><span class="line">    rioInitWithConn(&amp;rdb,conn,server.repl_transfer_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Put the socket in blocking mode to simplify RDB transfer.</span></span><br><span class="line"><span class="comment">     * We&#x27;ll restore it when the RDB is received. */</span></span><br><span class="line">    connBlock(conn);</span><br><span class="line">    connRecvTimeout(conn, server.repl_timeout*<span class="number">1000</span>);</span><br><span class="line">    startLoading(server.repl_transfer_size, RDBFLAGS_REPLICATION);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rdbLoadRio(&amp;rdb,RDBFLAGS_REPLICATION,&amp;rsi) != C_OK) &#123;</span><br><span class="line">        <span class="comment">/* RDB loading failed. */</span></span><br><span class="line">        stopLoading(<span class="number">0</span>);</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">&quot;Failed trying to load the MASTER synchronization DB &quot;</span></span><br><span class="line">            <span class="string">&quot;from socket&quot;</span>);</span><br><span class="line">        cancelReplicationHandshake(<span class="number">1</span>);</span><br><span class="line">        rioFreeConn(&amp;rdb, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Remove the half-loaded data in case we started with</span></span><br><span class="line"><span class="comment">         * an empty replica. */</span></span><br><span class="line">        emptyDb(<span class="number">-1</span>,empty_db_flags,replicationEmptyDbCallback);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (server.repl_diskless_load == REPL_DISKLESS_LOAD_SWAPDB) &#123;</span><br><span class="line">            <span class="comment">/* Restore the backed up databases. */</span></span><br><span class="line">            disklessLoadRestoreBackup(diskless_load_backup);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Note that there&#x27;s no point in restarting the AOF on SYNC</span></span><br><span class="line"><span class="comment">         * failure, it&#x27;ll be restarted when sync succeeds or the replica</span></span><br><span class="line"><span class="comment">         * gets promoted. */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* RDB loading succeeded if we reach this point. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.repl_diskless_load == REPL_DISKLESS_LOAD_SWAPDB) &#123;</span><br><span class="line">        <span class="comment">/* Delete the backup databases we created before starting to load</span></span><br><span class="line"><span class="comment">         * the new RDB. Now the RDB was loaded with success so the old</span></span><br><span class="line"><span class="comment">         * data is useless. */</span></span><br><span class="line">        disklessLoadDiscardBackup(diskless_load_backup, empty_db_flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Verify the end mark is correct. */</span></span><br><span class="line">    <span class="keyword">if</span> (usemark) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!rioRead(&amp;rdb,buf,CONFIG_RUN_ID_SIZE) ||</span><br><span class="line">            <span class="built_in">memcmp</span>(buf,eofmark,CONFIG_RUN_ID_SIZE) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            stopLoading(<span class="number">0</span>);</span><br><span class="line">            serverLog(LL_WARNING,<span class="string">&quot;Replication stream EOF marker is broken&quot;</span>);</span><br><span class="line">            cancelReplicationHandshake(<span class="number">1</span>);</span><br><span class="line">            rioFreeConn(&amp;rdb, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stopLoading(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Cleanup and restore the socket to the original state to continue</span></span><br><span class="line"><span class="comment">     * with the normal replication. */</span></span><br><span class="line">    rioFreeConn(&amp;rdb, <span class="literal">NULL</span>);</span><br><span class="line">    connNonBlock(conn);</span><br><span class="line">    connRecvTimeout(conn,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="replicationCron"><a href="#replicationCron" class="headerlink" title="replicationCron"></a>replicationCron</h2><p><code>replicationCron</code> 在 <code>Master</code> 和 <code>Slave</code> 都会走到， <code>Master</code> 给 <code>Slave</code> 发心跳，而 <code>Slave</code> 给 <code>Master</code> 发当前的进度，用于展示时使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">replicationCron</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/* Non blocking connection timeout? */</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost &amp;&amp;</span><br><span class="line">        (server.repl_state == REPL_STATE_CONNECTING ||</span><br><span class="line">         slaveIsInHandshakeState()) &amp;&amp;</span><br><span class="line">         (time(<span class="literal">NULL</span>)-server.repl_transfer_lastio) &gt; server.repl_timeout)</span><br><span class="line">    &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Timeout connecting to the MASTER...&quot;</span>);</span><br><span class="line">        cancelReplicationHandshake(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Bulk transfer I/O timeout? */</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost &amp;&amp; server.repl_state == REPL_STATE_TRANSFER &amp;&amp;</span><br><span class="line">        (time(<span class="literal">NULL</span>)-server.repl_transfer_lastio) &gt; server.repl_timeout)</span><br><span class="line">    &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Timeout receiving bulk data from MASTER... If the problem persists try to set the &#x27;repl-timeout&#x27; parameter in redis.conf to a larger value.&quot;</span>);</span><br><span class="line">        cancelReplicationHandshake(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Timed out master when we are an already connected slave? */</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost &amp;&amp; server.repl_state == REPL_STATE_CONNECTED &amp;&amp;</span><br><span class="line">        (time(<span class="literal">NULL</span>)-server.master-&gt;lastinteraction) &gt; server.repl_timeout)</span><br><span class="line">    &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;MASTER timeout: no data nor PING received...&quot;</span>);</span><br><span class="line">        freeClient(server.master);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we should connect to a MASTER */</span></span><br><span class="line">    <span class="keyword">if</span> (server.repl_state == REPL_STATE_CONNECT) &#123;</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">&quot;Connecting to MASTER %s:%d&quot;</span>,</span><br><span class="line">            server.masterhost, server.masterport);</span><br><span class="line">        connectWithMaster();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Send ACK to master from time to time.</span></span><br><span class="line"><span class="comment">     * Note that we do not send periodic acks to masters that don&#x27;t</span></span><br><span class="line"><span class="comment">     * support PSYNC and replication offsets. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost &amp;&amp; server.master &amp;&amp;</span><br><span class="line">        !(server.master-&gt;flags &amp; CLIENT_PRE_PSYNC))</span><br><span class="line">        replicationSendAck();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h2><p><code>Master</code> 在收到 <code>PSYNC</code> 或者 <code>SYNC</code> 后，会调用 <code>syncCommand</code> 。</p><h3 id="syncCommand"><a href="#syncCommand" class="headerlink" title="syncCommand"></a>syncCommand</h3><ol><li>若是 <code>PSYNC</code> 则会调用 <code>masterTryPartialResynchronization</code> 来判断是否可以增量同步（从 <code>repl_backlog</code> 缓冲区中查找），否则全量同步。</li><li>若为 <code>SYNC</code> 则 设置 <code>Client→flags</code> 为 <code>CLIENT_PRE_PSYNC</code> ，表示 <code>Slave</code> 不会发送 <code>ACK</code> ，不能因为其不发就认为其宕机。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">syncCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">		....</span><br><span class="line">    <span class="comment">/* Try a partial resynchronization if this is a PSYNC command.</span></span><br><span class="line"><span class="comment">     * If it fails, we continue with usual full resynchronization, however</span></span><br><span class="line"><span class="comment">     * when this happens masterTryPartialResynchronization() already</span></span><br><span class="line"><span class="comment">     * replied with:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * +FULLRESYNC &lt;replid&gt; &lt;offset&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * So the slave knows the new replid and offset to try a PSYNC later</span></span><br><span class="line"><span class="comment">     * if the connection with the master is lost. */</span></span><br><span class="line">    <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">0</span>]-&gt;ptr,<span class="string">&quot;psync&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (masterTryPartialResynchronization(c) == C_OK) &#123;</span><br><span class="line">            server.stat_sync_partial_ok++;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">/* No full resync needed, return. */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* If a slave uses SYNC, we are dealing with an old implementation</span></span><br><span class="line"><span class="comment">         * of the replication protocol (like redis-cli --slave). Flag the client</span></span><br><span class="line"><span class="comment">         * so that we don&#x27;t expect to receive REPLCONF ACK feedbacks. */</span></span><br><span class="line">        c-&gt;flags |= CLIENT_PRE_PSYNC;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>往下走就全是全量同步了，若已有 <code>BGSAVE</code> 命令再执行，则尝试复用 生成出来的 <code>RDB</code> ，将其他 <code>Slave</code> 的输出缓冲区拷给当前 <code>Slave</code> 来达到同步的目的。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">c-&gt;replstate = SLAVE_STATE_WAIT_BGSAVE_START;</span><br><span class="line"><span class="keyword">if</span> (server.repl_disable_tcp_nodelay)</span><br><span class="line">    connDisableTcpNoDelay(c-&gt;conn); <span class="comment">/* Non critical if it fails. */</span></span><br><span class="line">c-&gt;repldbfd = <span class="number">-1</span>;</span><br><span class="line">c-&gt;flags |= CLIENT_SLAVE;</span><br><span class="line">listAddNodeTail(server.slaves,c);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create the replication backlog if needed. */</span></span><br><span class="line"><span class="keyword">if</span> (listLength(server.slaves) == <span class="number">1</span> &amp;&amp; server.repl_backlog == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">/* When we create the backlog from scratch, we always use a new</span></span><br><span class="line"><span class="comment">     * replication ID and clear the ID2, since there is no valid</span></span><br><span class="line"><span class="comment">     * past history. */</span></span><br><span class="line">    changeReplicationId();</span><br><span class="line">    clearReplicationId2();</span><br><span class="line">    createReplicationBacklog();</span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">&quot;Replication backlog created, my new &quot;</span></span><br><span class="line">                        <span class="string">&quot;replication IDs are &#x27;%s&#x27; and &#x27;%s&#x27;&quot;</span>,</span><br><span class="line">                        server.replid, server.replid2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* CASE 1: BGSAVE is in progress, with disk target. */</span></span><br><span class="line"><span class="keyword">if</span> (server.child_type == CHILD_TYPE_RDB &amp;&amp;</span><br><span class="line">    server.rdb_child_type == RDB_CHILD_TYPE_DISK)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Ok a background save is in progress. Let&#x27;s check if it is a good</span></span><br><span class="line"><span class="comment">     * one for replication, i.e. if there is another slave that is</span></span><br><span class="line"><span class="comment">     * registering differences since the server forked to save. */</span></span><br><span class="line">    client *slave;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    listIter li;</span><br><span class="line"></span><br><span class="line">    listRewind(server.slaves,&amp;li);</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        slave = ln-&gt;value;</span><br><span class="line">        <span class="comment">/* If the client needs a buffer of commands, we can&#x27;t use</span></span><br><span class="line"><span class="comment">         * a replica without replication buffer. */</span></span><br><span class="line">        <span class="keyword">if</span> (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_END &amp;&amp;</span><br><span class="line">            (!(slave-&gt;flags &amp; CLIENT_REPL_RDBONLY) ||</span><br><span class="line">             (c-&gt;flags &amp; CLIENT_REPL_RDBONLY)))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* To attach this slave, we check that it has at least all the</span></span><br><span class="line"><span class="comment">     * capabilities of the slave that triggered the current BGSAVE. */</span></span><br><span class="line">    <span class="keyword">if</span> (ln &amp;&amp; ((c-&gt;slave_capa &amp; slave-&gt;slave_capa) == slave-&gt;slave_capa)) &#123;</span><br><span class="line">        <span class="comment">/* Perfect, the server is already registering differences for</span></span><br><span class="line"><span class="comment">         * another slave. Set the right state, and copy the buffer.</span></span><br><span class="line"><span class="comment">         * We don&#x27;t copy buffer if clients don&#x27;t want. */</span></span><br><span class="line">        <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_REPL_RDBONLY)) copyClientOutputBuffer(c,slave);</span><br><span class="line">        replicationSetupSlaveForFullResync(c,slave-&gt;psync_initial_offset);</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">&quot;Waiting for end of BGSAVE for SYNC&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* No way, we need to wait for the next BGSAVE in order to</span></span><br><span class="line"><span class="comment">         * register differences. */</span></span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">&quot;Can&#x27;t attach the replica to the current BGSAVE. Waiting for next BGSAVE for SYNC&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>若在执行无盘传送，说明启用了子进程进行序列化，再通过匿名管道传给父进程，父进程再通过 <code>Socket</code> 发给 <code>Slave</code> ，因此我们在这个时候应该等待。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* CASE 2: BGSAVE is in progress, with socket target. */</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.child_type == CHILD_TYPE_RDB &amp;&amp;</span><br><span class="line">           server.rdb_child_type == RDB_CHILD_TYPE_SOCKET)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* There is an RDB child process but it is writing directly to</span></span><br><span class="line"><span class="comment">     * children sockets. We need to wait for the next BGSAVE</span></span><br><span class="line"><span class="comment">     * in order to synchronize. */</span></span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">&quot;Current BGSAVE has socket target. Waiting for next BGSAVE for SYNC&quot;</span>);</span><br></pre></td></tr></table></figure><ol start="5"><li>没有后台进程再运行，则无论是 <code>无盘同步</code> 还是 <code>RDB同步</code> 都会走到 <code>startBgsaveForReplication</code> 这个函数。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* CASE 3: There is no BGSAVE is progress. */</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (server.repl_diskless_sync &amp;&amp; (c-&gt;slave_capa &amp; SLAVE_CAPA_EOF) &amp;&amp;</span><br><span class="line">        server.repl_diskless_sync_delay)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Diskless replication RDB child is created inside</span></span><br><span class="line"><span class="comment">         * replicationCron() since we want to delay its start a</span></span><br><span class="line"><span class="comment">         * few seconds to wait for more slaves to arrive. */</span></span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">&quot;Delay next BGSAVE for diskless SYNC&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* We don&#x27;t have a BGSAVE in progress, let&#x27;s start one. Diskless</span></span><br><span class="line"><span class="comment">         * or disk-based mode is determined by replica&#x27;s capacity. */</span></span><br><span class="line">        <span class="keyword">if</span> (!hasActiveChildProcess()) &#123;</span><br><span class="line">            startBgsaveForReplication(c-&gt;slave_capa);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            serverLog(LL_NOTICE,</span><br><span class="line">                <span class="string">&quot;No BGSAVE in progress, but another BG operation is active. &quot;</span></span><br><span class="line">                <span class="string">&quot;BGSAVE for replication delayed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="startBgsaveForReplication"><a href="#startBgsaveForReplication" class="headerlink" title="startBgsaveForReplication"></a>startBgsaveForReplication</h3><p>决定无盘同步还是RDB同步， <code>rdbSaveToSlavesSocket</code> 和 <code>rdbSaveBackground</code> 名字已经很清晰了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">startBgsaveForReplication</span><span class="params">(<span class="type">int</span> mincapa)</span> &#123;</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line">    <span class="type">int</span> socket_target = server.repl_diskless_sync &amp;&amp; (mincapa &amp; SLAVE_CAPA_EOF);</span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line"></span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">&quot;Starting BGSAVE for SYNC with target: %s&quot;</span>,</span><br><span class="line">        socket_target ? <span class="string">&quot;replicas sockets&quot;</span> : <span class="string">&quot;disk&quot;</span>);</span><br><span class="line"></span><br><span class="line">    rdbSaveInfo rsi, *rsiptr;</span><br><span class="line">    rsiptr = rdbPopulateSaveInfo(&amp;rsi);</span><br><span class="line">    <span class="comment">/* Only do rdbSave* when rsiptr is not NULL,</span></span><br><span class="line"><span class="comment">     * otherwise slave will miss repl-stream-db. */</span></span><br><span class="line">    <span class="keyword">if</span> (rsiptr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (socket_target)</span><br><span class="line">            retval = rdbSaveToSlavesSockets(rsiptr);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            retval = rdbSaveBackground(server.rdb_filename,rsiptr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;BGSAVE for replication: replication information not available, can&#x27;t generate the RDB file right now. Try later.&quot;</span>);</span><br><span class="line">        retval = C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the target is socket, rdbSaveToSlavesSockets() already setup</span></span><br><span class="line"><span class="comment">     * the slaves for a full resync. Otherwise for disk target do it now.*/</span></span><br><span class="line">    <span class="keyword">if</span> (!socket_target) &#123;</span><br><span class="line">        listRewind(server.slaves,&amp;li);</span><br><span class="line">        <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">            client *slave = ln-&gt;value;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START) &#123;</span><br><span class="line">                    replicationSetupSlaveForFullResync(slave,</span><br><span class="line">                            getPsyncInitialOffset());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别注意的是，无盘传输也是采用子进程的形式完成，但是绝不是通过子进程进行发送，而是子进程序列化好后通过匿名管道发给父进程，父进程再读取将其发往 <code>Slave</code> 。</p><h3 id="rdbSaveToSlavesSockets"><a href="#rdbSaveToSlavesSockets" class="headerlink" title="rdbSaveToSlavesSockets"></a>rdbSaveToSlavesSockets</h3><p>创建 <code>匿名管道</code> ，通过 <code>RIO</code> 将内存序列化后写入 <code>管道</code> 中，父进程通过管道取出发到 <code>Slave</code> 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Spawn an RDB child that writes the RDB to the sockets of the slaves</span></span><br><span class="line"><span class="comment"> * that are currently in SLAVE_STATE_WAIT_BGSAVE_START state. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rdbSaveToSlavesSockets</span><span class="params">(rdbSaveInfo *rsi)</span> &#123;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    listIter li;</span><br><span class="line">    <span class="type">pid_t</span> childpid;</span><br><span class="line">    <span class="type">int</span> pipefds[<span class="number">2</span>], rdb_pipe_write, safe_to_exit_pipe;</span><br><span class="line"></span><br><span class="line">    server.rdb_pipe_read = pipefds[<span class="number">0</span>]; <span class="comment">/* read end */</span></span><br><span class="line">    rdb_pipe_write = pipefds[<span class="number">1</span>]; <span class="comment">/* write end */</span></span><br><span class="line">    anetNonBlock(<span class="literal">NULL</span>, server.rdb_pipe_read);</span><br><span class="line"></span><br><span class="line">    safe_to_exit_pipe = pipefds[<span class="number">0</span>]; <span class="comment">/* read end */</span></span><br><span class="line">    server.rdb_child_exit_pipe = pipefds[<span class="number">1</span>]; <span class="comment">/* write end */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Collect the connections of the replicas we want to transfer</span></span><br><span class="line"><span class="comment">     * the RDB to, which are i WAIT_BGSAVE_START state. */</span></span><br><span class="line">    server.rdb_pipe_conns = zmalloc(<span class="keyword">sizeof</span>(connection *)*listLength(server.slaves));</span><br><span class="line">    server.rdb_pipe_numconns = <span class="number">0</span>;</span><br><span class="line">    server.rdb_pipe_numconns_writing = <span class="number">0</span>;</span><br><span class="line">    listRewind(server.slaves,&amp;li);</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *slave = ln-&gt;value;</span><br><span class="line">        <span class="keyword">if</span> (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START) &#123;</span><br><span class="line">            server.rdb_pipe_conns[server.rdb_pipe_numconns++] = slave-&gt;conn;</span><br><span class="line">            replicationSetupSlaveForFullResync(slave,getPsyncInitialOffset());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create the child process. */</span></span><br><span class="line">    <span class="keyword">if</span> ((childpid = redisFork(CHILD_TYPE_RDB)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Child */</span></span><br><span class="line">        <span class="type">int</span> retval, dummy;</span><br><span class="line">        rio rdb;</span><br><span class="line"></span><br><span class="line">        rioInitWithFd(&amp;rdb,rdb_pipe_write);</span><br><span class="line"></span><br><span class="line">        retval = rdbSaveRioWithEOFMark(&amp;rdb,<span class="literal">NULL</span>,rsi);</span><br><span class="line">        <span class="keyword">if</span> (retval == C_OK &amp;&amp; rioFlush(&amp;rdb) == <span class="number">0</span>)</span><br><span class="line">            retval = C_ERR;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (retval == C_OK) &#123;</span><br><span class="line">            sendChildCowInfo(CHILD_INFO_TYPE_RDB_COW_SIZE, <span class="string">&quot;RDB&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rioFreeFd(&amp;rdb);</span><br><span class="line">        <span class="comment">/* wake up the reader, tell it we&#x27;re done. */</span></span><br><span class="line">        close(rdb_pipe_write);</span><br><span class="line">        close(server.rdb_child_exit_pipe); <span class="comment">/* close write end so that we can detect the close on the parent. */</span></span><br><span class="line">        <span class="comment">/* hold exit until the parent tells us it&#x27;s safe. we&#x27;re not expecting</span></span><br><span class="line"><span class="comment">         * to read anything, just get the error when the pipe is closed. */</span></span><br><span class="line">        dummy = read(safe_to_exit_pipe, pipefds, <span class="number">1</span>);</span><br><span class="line">        UNUSED(dummy);</span><br><span class="line">        exitFromChild((retval == C_OK) ? <span class="number">0</span> : <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>父进程注册管道的可读事件，从 <code>rdbPipeReadHandler</code> 读取。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Parent */</span></span><br><span class="line">        close(safe_to_exit_pipe);</span><br><span class="line">        <span class="keyword">if</span> (childpid == <span class="number">-1</span>) &#123;</span><br><span class="line">            serverLog(LL_WARNING,<span class="string">&quot;Can&#x27;t save in background: fork: %s&quot;</span>,</span><br><span class="line">                strerror(errno));</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Undo the state change. The caller will perform cleanup on</span></span><br><span class="line"><span class="comment">             * all the slaves in BGSAVE_START state, but an early call to</span></span><br><span class="line"><span class="comment">             * replicationSetupSlaveForFullResync() turned it into BGSAVE_END */</span></span><br><span class="line">            listRewind(server.slaves,&amp;li);</span><br><span class="line">            <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">                client *slave = ln-&gt;value;</span><br><span class="line">                <span class="keyword">if</span> (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_END) &#123;</span><br><span class="line">                    slave-&gt;replstate = SLAVE_STATE_WAIT_BGSAVE_START;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            close(rdb_pipe_write);</span><br><span class="line">            close(server.rdb_pipe_read);</span><br><span class="line">            zfree(server.rdb_pipe_conns);</span><br><span class="line">            server.rdb_pipe_conns = <span class="literal">NULL</span>;</span><br><span class="line">            server.rdb_pipe_numconns = <span class="number">0</span>;</span><br><span class="line">            server.rdb_pipe_numconns_writing = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            serverLog(LL_NOTICE,<span class="string">&quot;Background RDB transfer started by pid %ld&quot;</span>,</span><br><span class="line">                (<span class="type">long</span>) childpid);</span><br><span class="line">            server.rdb_save_time_start = time(<span class="literal">NULL</span>);</span><br><span class="line">            server.rdb_child_type = RDB_CHILD_TYPE_SOCKET;</span><br><span class="line">            close(rdb_pipe_write); <span class="comment">/* close write in parent so that it can detect the close on the child. */</span></span><br><span class="line">            <span class="keyword">if</span> (aeCreateFileEvent(server.el, server.rdb_pipe_read, AE_READABLE, rdbPipeReadHandler,<span class="literal">NULL</span>) == AE_ERR) &#123;</span><br><span class="line">                serverPanic(<span class="string">&quot;Unrecoverable error creating server.rdb_pipe_read file event.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (childpid == <span class="number">-1</span>) ? C_ERR : C_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C_OK; <span class="comment">/* Unreached. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此主从同步就已剖析完了，之后的命令传送则通过 <code>propagate</code> 函数进行传递。</p><h2 id="主从同步的坑"><a href="#主从同步的坑" class="headerlink" title="主从同步的坑"></a>主从同步的坑</h2><p>主从数据不一致</p><ul><li>主从同步本来就是异步过程，应从部署方面考虑。</li></ul><p>读到过期数据</p><ul><li>带有相对时间过期的命令发送到从服务器后，已经滞后了，最好使用绝对时间。</li><li>Redis 旧版本的从库就算读过期数据，也会原样返回（新版本返回空值）。</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Redis/" rel="tag"># Redis</a></div><div class="post-nav"><div class="post-nav-item"><a href="/Redis-6-%E5%89%96%E6%9E%90(%E4%B8%80)-%E5%BC%82%E6%AD%A5%E6%9C%BA%E5%88%B6/" rel="prev" title="Redis 6 剖析(一) 异步机制"><i class="fa fa-angle-left"></i> Redis 6 剖析(一) 异步机制</a></div><div class="post-nav-item"><a href="/LuaJIT-5.3.6/" rel="next" title="LuaJIT 5.3.6 方案">LuaJIT 5.3.6 方案 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Yuerer</span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://unpkg.com/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://unpkg.com/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/comments.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/utils.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/motion.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/sidebar.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/next-boot.min.js"></script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://yuerer-comment-xufei-0bea01e6f05-1307930306.ap-shanghai.app.tcloudbase.com","cssUrl":"https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.css","commentCount":true,"pageview":true,"libUrl":"https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.js","locale":{"placeholder":"有何高见？"},"emoji":["https://unpkg.com/@waline/emojis@1.0.1/qq"],"meta":["nick","mail"],"requiredMeta":[["nick","mail"]],"wordLimit":0,"login":"disable","pageSize":10,"el":"#waline","comment":true,"path":"/Redis-6-%E5%89%96%E6%9E%90(%E4%BA%8C)-%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/"}</script><link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.css"><script>document.addEventListener("page:loaded",()=>{NexT.utils.loadComments(CONFIG.waline.el).then(()=>NexT.utils.getScript(CONFIG.waline.libUrl,{condition:window.Waline})).then(()=>Waline.init(Object.assign({},CONFIG.waline,{el:document.querySelector(CONFIG.waline.el)})))})</script></body></html>