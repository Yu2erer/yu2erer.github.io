<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.jpeg"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.ico"><link rel="mask-icon" href="/images/avatar.jpeg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous"><link rel="stylesheet" href="https://unpkg.com/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"yuerer.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"hide","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":true,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/config.min.js"></script><meta name="description" content="本文剖析 UnLua 是如何将 Lua 接入到 UE5中。尽可能少贴代码，将部分 Lua C API 的操作转为 Lua 伪代码，同时每个小节只关注主线内容，方便阅读和理解。 对象绑定本小节只关注当 UE5 创建一个对象时，是如何将其和 Lua 脚本给绑定起来的。 1. 创建虚拟机我们需要创建一个 Lua 虚拟机来执行游戏逻辑，但有时又希望每个 GameInstance 各自拥有自己的虚拟机，这样"><meta property="og:type" content="article"><meta property="og:title" content="UE5 UnLua 脚本方案原理"><meta property="og:url" content="https://yuerer.com/UE5%20UnLua%20%E8%84%9A%E6%9C%AC%E6%96%B9%E6%A1%88%E5%8E%9F%E7%90%86/index.html"><meta property="og:site_name" content="Yuerer&#39;s Blog"><meta property="og:description" content="本文剖析 UnLua 是如何将 Lua 接入到 UE5中。尽可能少贴代码，将部分 Lua C API 的操作转为 Lua 伪代码，同时每个小节只关注主线内容，方便阅读和理解。 对象绑定本小节只关注当 UE5 创建一个对象时，是如何将其和 Lua 脚本给绑定起来的。 1. 创建虚拟机我们需要创建一个 Lua 虚拟机来执行游戏逻辑，但有时又希望每个 GameInstance 各自拥有自己的虚拟机，这样"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://yuerer.com/images/UE5_UnLua_%E8%84%9A%E6%9C%AC%E6%96%B9%E6%A1%88%E5%8E%9F%E7%90%86-1760930848012.png"><meta property="og:image" content="https://yuerer.com/images/UE5_UnLua_%E8%84%9A%E6%9C%AC%E6%96%B9%E6%A1%88%E5%8E%9F%E7%90%86-1760941234186.png"><meta property="og:image" content="https://yuerer.com/images/UE5_UnLua_%E8%84%9A%E6%9C%AC%E6%96%B9%E6%A1%88%E5%8E%9F%E7%90%86-1760959091705.png"><meta property="og:image" content="https://yuerer.com/images/UE5_UnLua_%E8%84%9A%E6%9C%AC%E6%96%B9%E6%A1%88%E5%8E%9F%E7%90%86-1761016392303.png"><meta property="og:image" content="https://yuerer.com/images/UE5_UnLua_%E8%84%9A%E6%9C%AC%E6%96%B9%E6%A1%88%E5%8E%9F%E7%90%86-1761028762295.jpg"><meta property="article:published_time" content="2025-10-24T15:21:20.000Z"><meta property="article:modified_time" content="2025-10-30T13:38:24.504Z"><meta property="article:author" content="Yuerer"><meta property="article:tag" content="UE5"><meta property="article:tag" content="UnLua"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://yuerer.com/images/UE5_UnLua_%E8%84%9A%E6%9C%AC%E6%96%B9%E6%A1%88%E5%8E%9F%E7%90%86-1760930848012.png"><link rel="canonical" href="https://yuerer.com/UE5%20UnLua%20%E8%84%9A%E6%9C%AC%E6%96%B9%E6%A1%88%E5%8E%9F%E7%90%86/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://yuerer.com/UE5%20UnLua%20%E8%84%9A%E6%9C%AC%E6%96%B9%E6%A1%88%E5%8E%9F%E7%90%86/","path":"UE5 UnLua 脚本方案原理/","title":"UE5 UnLua 脚本方案原理"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>UE5 UnLua 脚本方案原理 | Yuerer's Blog</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-129491388-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-129491388-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/third-party/analytics/google-analytics.min.js"></script><link rel="dns-prefetch" href="https://yuerer-comment-xufei-0bea01e6f05-1307930306.ap-shanghai.app.tcloudbase.com"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Yuerer's Blog</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">钰儿的Blog</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%BB%91%E5%AE%9A"><span class="nav-text">对象绑定</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="nav-text">1. 创建虚拟机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%BB%91%E5%AE%9A-UE-%E5%8F%8D%E5%B0%84%E5%AF%B9%E8%B1%A1%E5%88%B0-Lua"><span class="nav-text">2. 绑定 UE 反射对象到 Lua</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%9D%E8%AF%95%E7%BB%91%E5%AE%9A"><span class="nav-text">尝试绑定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%BC%E5%87%BA%E7%B1%BB%E6%8F%8F%E8%BF%B0"><span class="nav-text">导出类描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD-Lua-%E6%A8%A1%E5%9D%97"><span class="nav-text">加载 Lua 模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%86%99%E5%87%BD%E6%95%B0"><span class="nav-text">重写函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B-%E8%A1%A8"><span class="nav-text">创建实例(表)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E3%80%81%E5%87%BD%E6%95%B0%E6%9F%A5%E6%89%BE"><span class="nav-text">属性、函数查找</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%BE%E5%88%B0%E5%B1%9E%E6%80%A7%EF%BC%88Property%EF%BC%89"><span class="nav-text">找到属性（Property）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%BE%E5%88%B0%E5%87%BD%E6%95%B0%EF%BC%88Function%EF%BC%89"><span class="nav-text">找到函数（Function）</span></a></li></ol></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E7%94%A8-UFunction"><span class="nav-text">调用 UFunction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Latent-%E5%87%BD%E6%95%B0"><span class="nav-text">Latent 函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Delegate"><span class="nav-text">Delegate</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A6%86%E5%86%99%E5%87%BD%E6%95%B0%E6%B5%81%E7%A8%8B"><span class="nav-text">覆写函数流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-text">生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%90%8E"><span class="nav-text">最后</span></a></li></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Yuerer" src="/images/avatar.jpeg"><p class="site-author-name" itemprop="name">Yuerer</p><div class="site-description" itemprop="description">钰儿的Blog</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">65</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">16</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">90</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/Yu2erer" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Yu2erer" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:yu2erer#gmail.com" title="E-Mail → mailto:yu2erer#gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://yuerer.com/UE5%20UnLua%20%E8%84%9A%E6%9C%AC%E6%96%B9%E6%A1%88%E5%8E%9F%E7%90%86/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpeg"><meta itemprop="name" content="Yuerer"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Yuerer's Blog"><meta itemprop="description" content="钰儿的Blog"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="UE5 UnLua 脚本方案原理 | Yuerer's Blog"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">UE5 UnLua 脚本方案原理</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-10-24 23:21:20" itemprop="dateCreated datePublished" datetime="2025-10-24T23:21:20+08:00">2025-10-24</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UE/" itemprop="url" rel="index"><span itemprop="name">UE</span></a> </span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Waline：</span> <a title="waline" href="/UE5%20UnLua%20%E8%84%9A%E6%9C%AC%E6%96%B9%E6%A1%88%E5%8E%9F%E7%90%86/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/UE5%20UnLua%20%E8%84%9A%E6%9C%AC%E6%96%B9%E6%A1%88%E5%8E%9F%E7%90%86/" itemprop="commentCount"></span> </a></span><span class="post-meta-item" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="waline-pageview-count" data-path="/UE5%20UnLua%20%E8%84%9A%E6%9C%AC%E6%96%B9%E6%A1%88%E5%8E%9F%E7%90%86/"></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>本文剖析 UnLua 是如何将 Lua 接入到 UE5中。尽可能少贴代码，将部分 Lua C API 的操作转为 Lua 伪代码，同时每个小节只关注主线内容，方便阅读和理解。</p><h2 id="对象绑定"><a href="#对象绑定" class="headerlink" title="对象绑定"></a>对象绑定</h2><p>本小节只关注当 UE5 创建一个对象时，是如何将其和 Lua 脚本给绑定起来的。</p><h3 id="1-创建虚拟机"><a href="#1-创建虚拟机" class="headerlink" title="1. 创建虚拟机"></a>1. 创建虚拟机</h3><p>我们需要创建一个 Lua 虚拟机来执行游戏逻辑，但有时又希望每个 <code>GameInstance</code> 各自拥有自己的虚拟机，这样会更方便调试和管理，这就意味着需要确定每个 <code>Object</code> 会被分配到哪个虚拟机（以后为和代码保持一致，会简称为 <code>Env</code>），抽象出 <code>ULuaEnvLocator</code> 用于定位 <code>Object</code> 所属 <code>Env</code>，并创建 <code>Env</code>，<code>Env</code> 的一些简单操作会封装到 <code>FLuaEnv</code> 中。<br>大部分情况下，只需认为整个客户端只会开启一个 Lua 虚拟机就可以了，基于这个前提，甚至可以去掉这个类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UNLUA_API</span> ULuaEnvLocator : <span class="keyword">public</span> UObject</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> UnLua::FLuaEnv* <span class="title">Locate</span><span class="params">(<span class="type">const</span> UObject* Object)</span></span>;</span><br><span class="line">    TSharedPtr&lt;UnLua::FLuaEnv, ESPMode::ThreadSafe&gt; Env;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>定位当前 Object 属于哪个 Env</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EnvLocator = <span class="built_in">NewObject</span>&lt;ULuaEnvLocator&gt;(<span class="built_in">GetTransientPackage</span>(), EnvLocatorClass);</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> Env = EnvLocator-&gt;<span class="built_in">Locate</span>(Class);</span><br></pre></td></tr></table></figure><p>从以上代码能看出 <code>FLuaEnv</code> 就是虚拟机本身的封装类。</p><h3 id="2-绑定-UE-反射对象到-Lua"><a href="#2-绑定-UE-反射对象到-Lua" class="headerlink" title="2. 绑定 UE 反射对象到 Lua"></a>2. 绑定 UE 反射对象到 Lua</h3><p>通过继承以下两个类，来进行监听当前创建、销毁哪些 <code>UObject</code> ，从而实现绑定，内部实现为了解耦，会在多处监听。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FUnLuaModule</span> : <span class="keyword">public</span> IUnLuaModule,  </span><br><span class="line">                     <span class="keyword">public</span> FUObjectArray::FUObjectCreateListener,  </span><br><span class="line">                     <span class="keyword">public</span> FUObjectArray::FUObjectDeleteListener</span><br><span class="line"></span><br><span class="line">GUObjectArray.<span class="built_in">AddUObjectCreateListener</span>(<span class="keyword">this</span>);</span><br><span class="line">GUObjectArray.<span class="built_in">AddUObjectDeleteListener</span>(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>知道了哪些对象创建出来后，还需要知道该对象跟哪份 Lua 文件进行绑定，<code>Unlua</code> 有好几种方案，第一种是最好理解的，要求实现 <code>IUnLuaInterface</code> 接口：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UNLUA_API</span> IUnLuaInterface</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UFUNCTION</span>(BlueprintNativeEvent)</span><br><span class="line">    <span class="function">FString <span class="title">GetModuleName</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><span id="more"></span><p><code>UnLua</code> 能通过<code>GetModuleName</code> 得知当前对象绑定的 Lua Module Path。<br>但这样又不够灵活，最好是通过一个字符串路径告知我创建的对象绑定哪份 Lua 文件最好，因此 引出了 <code>FLuaDynamicBinding</code> 这个动态绑定辅助类，支持你在 Lua 中写出以下代码：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NewObject(WidgetClass, <span class="built_in">self</span>, <span class="literal">nil</span>, <span class="string">&quot;Tutorials.IconWidget&quot;</span>)</span><br></pre></td></tr></table></figure><p>本质是个栈结构。此处不重要，只是个扩展，这是第二种方案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FLuaDynamicBinding</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">FLuaDynamicBindingStackNode</span></span><br><span class="line">    &#123;</span><br><span class="line">        UClass *Class;</span><br><span class="line">        FString ModuleName;</span><br><span class="line">        int32 InitializerTableRef;</span><br><span class="line">    &#125;;</span><br><span class="line">    TArray&lt;FLuaDynamicBindingStackNode&gt; Stack;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="尝试绑定"><a href="#尝试绑定" class="headerlink" title="尝试绑定"></a>尝试绑定</h4><p>尝试绑定逻辑很简单，一个是避免该 <code>Object</code> 是旧的（编辑器模式下），另一个是避免是骨架类（<code>SKEL</code> 如有疑问，可以看看蓝图编译）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">FLuaEnv::TryBind</span><span class="params">(UObject* Object)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> Class = Object-&gt;<span class="built_in">IsA</span>&lt;UClass&gt;() ? <span class="built_in">static_cast</span>&lt;UClass*&gt;(Object) : Object-&gt;<span class="built_in">GetClass</span>();</span><br><span class="line">    <span class="keyword">if</span> (Class-&gt;<span class="built_in">HasAnyClassFlags</span>(CLASS_NewerVersionExists))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> UClass* InterfaceClass = UUnLuaInterface::<span class="built_in">StaticClass</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> bImplUnluaInterface = Class-&gt;<span class="built_in">ImplementsInterface</span>(InterfaceClass);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsInAsyncLoadingThread</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (bImplUnluaInterface || (!bImplUnluaInterface &amp;&amp; GLuaDynamicBinding.<span class="built_in">IsValid</span>(Class)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">FScopeLock <span class="title">Lock</span><span class="params">(&amp;CandidatesLock)</span></span>;</span><br><span class="line">            Candidates.<span class="built_in">AddUnique</span>(Object);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!bImplUnluaInterface)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!GLuaDynamicBinding.<span class="built_in">IsValid</span>(Class))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">GetManager</span>()-&gt;<span class="built_in">Bind</span>(Object, *GLuaDynamicBinding.ModuleName, GLuaDynamicBinding.InitializerTableRef);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Class-&gt;<span class="built_in">GetName</span>().<span class="built_in">Contains</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;SKEL_&quot;</span>)))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> ModuleName = ModuleLocator-&gt;<span class="built_in">Locate</span>(Object);</span><br><span class="line">    <span class="keyword">if</span> (ModuleName.<span class="built_in">IsEmpty</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">GetManager</span>()-&gt;<span class="built_in">Bind</span>(Object, *ModuleName, GLuaDynamicBinding.InitializerTableRef);</span><br></pre></td></tr></table></figure><p>最后是我们在静态绑定下需要调用 <code>GetModuleName</code> ，这个操作被封装到了 <code>ModuleLocator</code> 中。之所以需要封装，是作者希望提供一种根据蓝图资源的路径映射到对应 Lua 文件路径的方式，省的每个文件都需要自己实现一下那个 <code>GetModuleName</code> 接口，初次阅读的读者可以忽略，只需要知道有这种用法即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FString <span class="title">ULuaModuleLocator::Locate</span><span class="params">(<span class="type">const</span> UObject* Object)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> UObject* CDO;</span><br><span class="line">    <span class="keyword">if</span> (Object-&gt;<span class="built_in">HasAnyFlags</span>(RF_ClassDefaultObject | RF_ArchetypeObject))</span><br><span class="line">    &#123;</span><br><span class="line">        CDO = Object;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> Class = <span class="built_in">Cast</span>&lt;UClass&gt;(Object);</span><br><span class="line">        CDO = Class ? Class-&gt;<span class="built_in">GetDefaultObject</span>() : Object-&gt;<span class="built_in">GetClass</span>()-&gt;<span class="built_in">GetDefaultObject</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 各种检查...</span></span><br><span class="line">    <span class="keyword">return</span> IUnLuaInterface::<span class="built_in">Execute_GetModuleName</span>(CDO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="导出类描述"><a href="#导出类描述" class="headerlink" title="导出类描述"></a>导出类描述</h4><p>现在我们认为这个对象可以被绑定了。<br>在 UE 的反射系统里：</p><blockquote><p><strong><code>UClass</code> 是“类的对象（类的描述体）”，<code>UObject</code> 是“实例”。</strong></p></blockquote><p>也就是说，<code>UClass</code> 自身就是一个 <code>UObject</code>，但代表的是“类型”，而不是“实体对象”。<br>因此假定我要绑定 <code>AMyActor</code>，首先要把 <code>UClass(AMyActor)</code> 的信息导出出去，作为 <code>AMyActor</code> 这个实例的 <code>Metatable</code>，进而能访问该类的属性、方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">UUnLuaManager::Bind</span><span class="params">(UObject *Object, <span class="type">const</span> TCHAR *InModuleName, int32 InitializerTableRef)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> Class = Object-&gt;<span class="built_in">IsA</span>&lt;UClass&gt;() ? <span class="built_in">static_cast</span>&lt;UClass*&gt;(Object) : Object-&gt;<span class="built_in">GetClass</span>();</span><br><span class="line">    lua_State *L = Env-&gt;<span class="built_in">GetMainState</span>();</span><br><span class="line">    <span class="keyword">if</span> (!Env-&gt;<span class="built_in">GetClassRegistry</span>()-&gt;<span class="built_in">Register</span>(Class))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>此处逻辑过长，有兴趣的读者可以去阅读 <code>FClassRegistry</code> 这个类，它会绑定以下 <code>MetaMethod</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Functions to handle UClass */</span></span><br><span class="line"><span class="function">int32 <span class="title">Class_Index</span><span class="params">(lua_State* L)</span></span>;</span><br><span class="line"><span class="function">int32 <span class="title">Class_NewIndex</span><span class="params">(lua_State* L)</span></span>;</span><br><span class="line"><span class="function">int32 <span class="title">Class_StaticClass</span><span class="params">(lua_State *L)</span></span>;</span><br><span class="line"><span class="function">int32 <span class="title">Class_Cast</span><span class="params">(lua_State* L)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Functions to handle UScriptStruct */</span></span><br><span class="line"><span class="function">int32 <span class="title">ScriptStruct_Index</span><span class="params">(lua_State *L)</span></span>;</span><br><span class="line"><span class="function">int32 <span class="title">ScriptStruct_New</span><span class="params">(lua_State *L)</span></span>;</span><br><span class="line"><span class="function">int32 <span class="title">ScriptStruct_Delete</span><span class="params">(lua_State *L)</span></span>;</span><br><span class="line"><span class="function">int32 <span class="title">ScriptStruct_Copy</span><span class="params">(lua_State *L)</span></span>;</span><br><span class="line"><span class="function">int32 <span class="title">ScriptStruct_CopyFrom</span><span class="params">(lua_State *L)</span></span>;</span><br><span class="line"><span class="function">int32 <span class="title">ScriptStruct_Compare</span><span class="params">(lua_State *L)</span></span>;</span><br></pre></td></tr></table></figure><p>值得注意的是，它允许你通过 <code>TExportedClassBase</code> 来增加属性、函数，这样就能用来补充要导出的类，无论是否是反射类，一旦发现 Export 它会递归的将父类先进行注册。<br>此处我觉得有必要多说几句，假定我们有个 <code>AMyActor</code> 它的父类是 <code>AActor</code>，若你没有为 <code>AActor</code> 导出到 Lua 的话，它是不会将递归走进去的 <code>ExportedClass = nullptr</code> 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TArray&lt;IExportedClass*&gt; ExportedClasses;</span><br><span class="line"><span class="keyword">for</span> (int32 i = ClassDescChain.<span class="built_in">Num</span>() - <span class="number">1</span>; i &gt; <span class="number">-1</span>; --i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> ExportedClass = <span class="built_in">FindExportedReflectedClass</span>(*ClassDescChain[i]-&gt;<span class="built_in">GetName</span>());</span><br><span class="line">    <span class="keyword">if</span> (ExportedClass)</span><br><span class="line">        ExportedClass-&gt;<span class="built_in">Register</span>(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="加载-Lua-模块"><a href="#加载-Lua-模块" class="headerlink" title="加载 Lua 模块"></a>加载 Lua 模块</h4><p><code>UnLua::Call</code> 封装了一些简单的 Lua 操作，调用了 <code>require &quot;InModuleName&quot;</code> ，获取到覆写的 Lua Table，为了篇幅简单，本文不会提及任何关于 Lua C API 封装的剖析，因为没有意义，现在的AI都很好用了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UnLua::FLuaRetValues RetValues = UnLua::<span class="built_in">Call</span>(L, <span class="string">&quot;require&quot;</span>, <span class="built_in">TCHAR_TO_UTF8</span>(InModuleName));</span><br><span class="line"></span><br><span class="line"><span class="built_in">BindClass</span>(Class, InModuleName, Error);</span><br></pre></td></tr></table></figure><h4 id="重写函数"><a href="#重写函数" class="headerlink" title="重写函数"></a>重写函数</h4><p>加载到了 Lua 模块，就要让 UE5 的函数路径能够执行到 Lua，换句话说就是 Lua 函数能覆盖 UE5 的函数。<br>首先完整的拷贝一份 Lua Module Table 出来，作为实例的 Metatable，并将其存入 Lua 注册表里，保持强引用，因为可能会有多个实例，比如多个 <code>AMyActor</code> 绑定同一个 Lua Module Table，为了防止 Metatable 被更改，自然就会拷贝多份 Lua Module Table。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">UUnLuaManager::BindClass</span><span class="params">(UClass* Class, <span class="type">const</span> FString&amp; InModuleName, FString&amp; Error)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Class-&gt;<span class="built_in">HasAnyFlags</span>(RF_NeedPostLoad | RF_NeedPostLoadSubobjects))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>  L = Env-&gt;<span class="built_in">GetMainState</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> Top = <span class="built_in">lua_gettop</span>(L);</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> Type = UnLua::LowLevel::<span class="built_in">GetLoadedModule</span>(L, <span class="built_in">TCHAR_TO_UTF8</span>(*InModuleName));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!Class-&gt;<span class="built_in">IsChildOf</span>&lt;UBlueprintFunctionLibrary&gt;())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">lua_newtable</span>(L);</span><br><span class="line">        <span class="built_in">lua_pushnil</span>(L);</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">lua_next</span>(L, <span class="number">-3</span>) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">lua_pushvalue</span>(L, <span class="number">-2</span>);</span><br><span class="line">            <span class="built_in">lua_insert</span>(L, <span class="number">-2</span>);</span><br><span class="line">            <span class="built_in">lua_settable</span>(L, <span class="number">-4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lua_pushvalue</span>(L, <span class="number">-1</span>);</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> Ref = <span class="built_in">luaL_ref</span>(L, LUA_REGISTRYINDEX);</span><br><span class="line">    <span class="built_in">lua_settop</span>(L, Top);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; BindInfo = Classes.<span class="built_in">Add</span>(Class);</span><br><span class="line">    BindInfo.Class = Class;</span><br><span class="line">    BindInfo.ModuleName = InModuleName;</span><br><span class="line">    BindInfo.TableRef = Ref;</span><br></pre></td></tr></table></figure><p>找出所有的 Lua 函数和可重写的 UE 函数，使用 <code>ULuaFunction</code> 来替换掉原本 <code>UFunction</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">UnLua::LowLevel::<span class="built_in">GetFunctionNames</span>(Env-&gt;<span class="built_in">GetMainState</span>(), Ref, BindInfo.LuaFunctions);</span><br><span class="line">ULuaFunction::<span class="built_in">GetOverridableFunctions</span>(Class, BindInfo.UEFunctions);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用LuaTable里所有的函数来替换Class上对应的UFunction</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; LuaFuncName : BindInfo.LuaFunctions)</span><br><span class="line">&#123;</span><br><span class="line">    UFunction** Func = BindInfo.UEFunctions.<span class="built_in">Find</span>(LuaFuncName);</span><br><span class="line">    <span class="keyword">if</span> (Func)</span><br><span class="line">    &#123;</span><br><span class="line">        UFunction* Function = *Func;</span><br><span class="line">        ULuaFunction::<span class="built_in">Override</span>(Function, Class, LuaFuncName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时函数已经替换完成，为了保证思路连贯，此处暂时不解释是怎么替换掉 <code>UFunction</code> 的，先暂时认为它就能做到，后面会有详细分析。</p><h4 id="创建实例-表"><a href="#创建实例-表" class="headerlink" title="创建实例(表)"></a>创建实例(表)</h4><p>最后一步创建实例（表），为当前绑定的 <code>UObject</code> 创建一个 table，来驱动游戏逻辑。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Env-&gt;<span class="built_in">GetObjectRegistry</span>()-&gt;<span class="built_in">Bind</span>(Class);</span><br><span class="line">Env-&gt;<span class="built_in">GetObjectRegistry</span>()-&gt;<span class="built_in">Bind</span>(Object);</span><br></pre></td></tr></table></figure><p>内部创建实例表，代码几乎都是 Lua C API，就不贴出来了，我给出翻译成 Lua 的伪代码：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> INSTANCE = &#123;&#125;</span><br></pre></td></tr></table></figure><p><code>INSTANCE</code> 我们新创建的实例表，一开始是空的，随后放入 <code>Object</code> 字段。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> RAW_UOBJECT = <span class="comment">-- From C++</span></span><br><span class="line">INSTANCE.Object = RAW_UOBJECT</span><br></pre></td></tr></table></figure><p>设置 Metatable，别怕我会解释的。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> REQUIRED_MODULE = REGISTRY_BY_REF[ClassBoundRef]</span><br><span class="line"><span class="keyword">local</span> METATABLE_UOBJECT = <span class="built_in">getmetatable</span>(RAW_UOBJECT)</span><br><span class="line"><span class="built_in">setmetatable</span>(REQUIRED_MODULE, METATABLE_UOBJECT)</span><br><span class="line">INSTANCE.Overridden = METATABLE_UOBJECT</span><br><span class="line"><span class="built_in">setmetatable</span>(INSTANCE, REQUIRED_MODULE)</span><br></pre></td></tr></table></figure><p><code>REQUIRED_MODULE</code> 就是开发者自己写的那份 Lua 代码，里面有函数原型信息，比如以下代码：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> M = UnLua.Class()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M:ReceiveBeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> M</span><br></pre></td></tr></table></figure><p><code>INSTANCE</code> 你可以理解为几乎是一张空表，里面没有函数，那自然找不到 <code>ReceiveBeginPlay</code> 的函数定义，所以需要 <code>setmetatable(INSTANCE, REQUIRED_MODULE)</code> ，让其能找到函数信息。<br>能找到用户自己实现的函数信息还不够，我们希望能通过 <code>INSTANCE</code> 访问到 <code>UObject</code> 的 <code>Property</code> 和 <code>Function</code>，<code>METATABLE_UOBJECT</code> 就是 “导出类描述“ 这一小节中导出的内容，里面只是简单的定义了一些 Metamethod 比如 <code>Class_Index</code> 从而能正确的找到属性、函数，因此还需要 <code>setmetatable(REQUIRED_MODULE, METATABLE_UOBJECT)</code> ，这就能串起一条调用链。<br><code>INSTANCE.Overridden = METATABLE_UOBJECT</code> 至于这句，就是为了能访问到被 Lua 覆写前的函数。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M:SayHi</span><span class="params">(name)</span></span></span><br><span class="line">    <span class="built_in">self</span>.Overridden.SayHi(<span class="built_in">self</span>, name)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><img data-src="/images/UE5_UnLua_%E8%84%9A%E6%9C%AC%E6%96%B9%E6%A1%88%E5%8E%9F%E7%90%86-1760930848012.png"><br>我个人觉得，只需要创建出 <code>Object</code> 的实例表就够了，但这确实是创建多了一个 <code>Class</code> 实例表，简单删了这句，好像也没有问题，如果有熟悉这块的可以给我解答一下。</p><h2 id="属性、函数查找"><a href="#属性、函数查找" class="headerlink" title="属性、函数查找"></a>属性、函数查找</h2><p>前面已经熟悉了 UE5 怎么把对象和 Lua 脚本绑定关联起来，但从始至终我们都没有导出过任何一个属性、函数到 Lua，只导出了一些元方法出去，因为 UnLua 是动态导出的，只有访问到的东西才会导出，并添加缓存。<br>现在就要关注如何通过 <code>INSTANCE</code> 实例表，查找出属性、函数这些内容。<br>假设现在要查找 <code>INSTANCE.name</code> 这一字符串内容，首先会在 <code>INSTANCE</code> 表里查找，显然找不到，此时会访问它的 Metatable 也就是 <code>REQUIRED_MODULE</code>。<br><code>REQUIRED_MODULE</code> 里自然也找不到，于是触发了它的 <code>__index</code> 元方法。<br>这一切都是这么的自然，以至于会下意识认为这个 <code>__index</code> 是 <code>Class_Index</code> 这个元方法，实际上并不是，允许我在这展开一下，在创建 Lua 虚拟机时，会执行以下逻辑：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">LegacySupport</span><span class="params">(lua_State* L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* Chunk = <span class="string">R&quot;(</span></span><br><span class="line"><span class="string">    local rawget = _G.rawget</span></span><br><span class="line"><span class="string">    local rawset = _G.rawset</span></span><br><span class="line"><span class="string">    local rawequal = _G.rawequal</span></span><br><span class="line"><span class="string">    local type = _G.type</span></span><br><span class="line"><span class="string">    local getmetatable = _G.getmetatable</span></span><br><span class="line"><span class="string">    local require = _G.require</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    local GetUProperty = GetUProperty</span></span><br><span class="line"><span class="string">    local SetUProperty = SetUProperty</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    local NotExist = &#123;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    local function Index(t, k)</span></span><br><span class="line"><span class="string">        local mt = getmetatable(t)</span></span><br><span class="line"><span class="string">        local super = mt</span></span><br><span class="line"><span class="string">        while super do</span></span><br><span class="line"><span class="string">            local v = rawget(super, k)</span></span><br><span class="line"><span class="string">            if v ~= nil and not rawequal(v, NotExist) then</span></span><br><span class="line"><span class="string">                rawset(t, k, v)</span></span><br><span class="line"><span class="string">                return v</span></span><br><span class="line"><span class="string">            end</span></span><br><span class="line"><span class="string">            super = rawget(super, &quot;Super&quot;)</span></span><br><span class="line"><span class="string">        end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        local p = mt[k]</span></span><br><span class="line"><span class="string">        if p ~= nil then</span></span><br><span class="line"><span class="string">            if type(p) == &quot;userdata&quot; then</span></span><br><span class="line"><span class="string">                return GetUProperty(t, p)</span></span><br><span class="line"><span class="string">            elseif type(p) == &quot;function&quot; then</span></span><br><span class="line"><span class="string">                rawset(t, k, p)</span></span><br><span class="line"><span class="string">            elseif rawequal(p, NotExist) then</span></span><br><span class="line"><span class="string">                return nil</span></span><br><span class="line"><span class="string">            end</span></span><br><span class="line"><span class="string">        else</span></span><br><span class="line"><span class="string">            rawset(mt, k, NotExist)</span></span><br><span class="line"><span class="string">        end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        return p</span></span><br><span class="line"><span class="string">    end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    local function NewIndex(t, k, v)</span></span><br><span class="line"><span class="string">        local mt = getmetatable(t)</span></span><br><span class="line"><span class="string">        local p = mt[k]</span></span><br><span class="line"><span class="string">        if type(p) == &quot;userdata&quot; then</span></span><br><span class="line"><span class="string">            return SetUProperty(t, p, v)</span></span><br><span class="line"><span class="string">        end</span></span><br><span class="line"><span class="string">        rawset(t, k, v)</span></span><br><span class="line"><span class="string">    end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    local function Class(super_name)</span></span><br><span class="line"><span class="string">        local super_class = nil</span></span><br><span class="line"><span class="string">        if super_name ~= nil then</span></span><br><span class="line"><span class="string">            super_class = require(super_name)</span></span><br><span class="line"><span class="string">        end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        local new_class = &#123;&#125;</span></span><br><span class="line"><span class="string">        new_class.__index = Index</span></span><br><span class="line"><span class="string">        new_class.__newindex = NewIndex</span></span><br><span class="line"><span class="string">        new_class.Super = super_class</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        return new_class</span></span><br><span class="line"><span class="string">    end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    _G.Class = Class</span></span><br><span class="line"><span class="string">    _G.GetUProperty = GetUProperty</span></span><br><span class="line"><span class="string">    _G.SetUProperty = SetUProperty</span></span><br><span class="line"><span class="string">    )&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lua_register</span>(L, <span class="string">&quot;UEPrint&quot;</span>, LogInfo);</span><br><span class="line">    <span class="built_in">luaL_loadstring</span>(L, Chunk);</span><br><span class="line">    <span class="built_in">lua_newtable</span>(L);</span><br><span class="line">    <span class="built_in">lua_getglobal</span>(L, LUA_GNAME);</span><br><span class="line">    <span class="built_in">lua_setfield</span>(L, <span class="number">-2</span>, LUA_GNAME);</span><br><span class="line">    <span class="built_in">luaL_setfuncs</span>(L, UnLua_LegacyFunctions, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">lua_setupvalue</span>(L, <span class="number">-2</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">lua_pcall</span>(L, <span class="number">0</span>, LUA_MULTRET, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">lua_getglobal</span>(L, <span class="string">&quot;Class&quot;</span>);</span><br><span class="line">    <span class="built_in">lua_setfield</span>(L, <span class="number">-2</span>, <span class="string">&quot;Class&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码比较长，简单来看就是提供了一个默认的 Lua Class 封装，它重写了 <code>__newIndex</code> 和 <code>__index</code> ，使得属性访问能够更简单，这就是为什么我们总是需要在 Lua 中写出：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> M = UnLua.Class()</span><br><span class="line"><span class="keyword">return</span> M</span><br></pre></td></tr></table></figure><p>这样的代码，这里的 <code>M</code> 就是 <code>REQUIRED_MODULE</code> ，那么 <code>REQUIRED_MODULE</code> 的 <code>__index</code> 就是这里的 <code>local function Index(t, k)</code> ，这就清晰了，它首先会在 Lua 侧的父类进行查找，若找不到则<br>查找到 <code>METATABLE_UOBJECT</code> ，此时这里面肯定也是找不到的，就会触发到它的元方法，也就是 <code>Class_Index</code> 。<br>直接通过字段名进行查找：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FProperty* Property = Struct-&gt;<span class="built_in">FindPropertyByName</span>(FieldName);  </span><br><span class="line">UFunction* Function = (!Property &amp;&amp; bIsClass) ? <span class="built_in">AsClass</span>()-&gt;<span class="built_in">FindFunctionByName</span>(FieldName) : <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>如果找不到，有可能是因为蓝图里的 <code>Struct</code> 的字段名会被加上一串 <code>GUID</code>，需要手动做删除对比。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> bValid = Property || Function;  </span><br><span class="line"><span class="keyword">if</span> (!bValid &amp;&amp; bIsScriptStruct &amp;&amp; !Struct-&gt;<span class="built_in">IsNative</span>())  </span><br><span class="line">&#123;  </span><br><span class="line">    FString FieldNameStr = FieldName.<span class="built_in">ToString</span>();  </span><br><span class="line">    <span class="type">const</span> int32 GuidStrLen = <span class="number">32</span>;  </span><br><span class="line">    <span class="type">const</span> int32 MinimalPostfixlen = GuidStrLen + <span class="number">3</span>;  </span><br><span class="line">    <span class="keyword">for</span> (TFieldIterator&lt;FProperty&gt; <span class="built_in">PropertyIt</span>(Struct.<span class="built_in">Get</span>(), EFieldIteratorFlags::ExcludeSuper, EFieldIteratorFlags::ExcludeDeprecated); PropertyIt; ++PropertyIt)  </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>还找不到，就尝试去 <code>UClass</code> 中查找了。<br><img data-src="/images/UE5_UnLua_%E8%84%9A%E6%9C%AC%E6%96%B9%E6%A1%88%E5%8E%9F%E7%90%86-1760941234186.png"></p><h4 id="找到属性（Property）"><a href="#找到属性（Property）" class="headerlink" title="找到属性（Property）"></a>找到属性（Property）</h4><p>假设已经找到了一个 <code>Property</code>，此时 Lua 栈顶上会存放一个 <code>userdata</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TSharedPtr&lt;FPropertyDesc&gt; Property = Field-&gt;<span class="built_in">AsProperty</span>();  </span><br><span class="line">Env.<span class="built_in">GetObjectRegistry</span>()-&gt;<span class="built_in">Push</span>(L, Property); <span class="comment">// 等同于 new(Userdata) TSharedPtr&lt;FPropertyDesc&gt;(Property);</span></span><br></pre></td></tr></table></figure><p><code>FPropertyDesc</code> 是对 <code>FProperty</code> 的一层包装，内部封装了 Lua 栈操作的 API，方便将属性值推向Lua 栈，或是从 Lua 栈中读出到 <code>FProperty</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FPropertyDesc</span> : <span class="keyword">public</span> UnLua::ITypeInterface</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> FPropertyDesc* <span class="title">Create</span><span class="params">(FProperty *InProperty)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ReadValue_InContainer</span><span class="params">(lua_State *L, <span class="type">const</span> <span class="type">void</span> *ContainerPtr, <span class="type">bool</span> bCreateCopy)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ReadValue</span><span class="params">(lua_State *L, <span class="type">const</span> <span class="type">void</span> *ValuePtr, <span class="type">bool</span> bCreateCopy)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">WriteValue_InContainer</span><span class="params">(lua_State *L, <span class="type">void</span> *ContainerPtr, int32 IndexInStack, <span class="type">bool</span> bCreateCopy)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">WriteValue</span><span class="params">(lua_State *L, <span class="type">void</span> *ValuePtr, int32 IndexInStack, <span class="type">bool</span> bCreateCopy)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        FProperty *Property;</span><br><span class="line">        FNumericProperty *NumericProperty;</span><br><span class="line">        FEnumProperty *EnumProperty;</span><br><span class="line">        FBoolProperty *BoolProperty;</span><br><span class="line">        FObjectPropertyBase *ObjectBaseProperty;</span><br><span class="line">        FSoftObjectProperty *SoftObjectProperty;</span><br><span class="line">        FInterfaceProperty *InterfaceProperty;</span><br><span class="line">        FNameProperty *NameProperty;</span><br><span class="line">        FStrProperty *StringProperty;</span><br><span class="line">        FTextProperty *TextProperty;</span><br><span class="line">        FArrayProperty *ArrayProperty;</span><br><span class="line">        FMapProperty *MapProperty;</span><br><span class="line">        FSetProperty *SetProperty;</span><br><span class="line">        FStructProperty *StructProperty;</span><br><span class="line">        FDelegateProperty *DelegateProperty;</span><br><span class="line">        FMulticastDelegateProperty *MulticastDelegateProperty;</span><br><span class="line">    &#125;;</span><br><span class="line">    TWeakFieldPtr&lt;FProperty&gt; PropertyPtr;</span><br><span class="line">    int8 PropertyType;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于里面都是 Lua 栈操作，繁琐又枯燥，并不是很难，就跳过吧。值得一提的是，这个 <code>union</code> 是 C语言模拟多态的做法，Lua 源码中很常见这种写法。<br>现在我们 Lua 栈顶上是 <code>TSharedPtr&lt;FPropertyDesc&gt;(Ptr)</code> 显然是不够方便读写的，因此 <code>LegacySupport</code> 很贴心的为其包装了 <code>SetUProperty</code> 和 <code>GetUProperty</code> 确保用户拿到的就是 Lua 对象，而不是 <code>TSharedPtr&lt;FPropertyDesc&gt;(Ptr)</code> 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">int32 <span class="title">GetUProperty</span><span class="params">(lua_State* L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> Ptr = <span class="built_in">lua_touserdata</span>(L, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">auto</span> Property = <span class="keyword">static_cast</span>&lt;TSharedPtr&lt;UnLua::ITypeOps&gt;*&gt;(Ptr);</span><br><span class="line">    (*Property)-&gt;<span class="built_in">ReadValue_InContainer</span>(L, Self, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="找到函数（Function）"><a href="#找到函数（Function）" class="headerlink" title="找到函数（Function）"></a>找到函数（Function）</h4><p>将 <code>TSharedPtr&lt;FFunctionDesc&gt;</code> 作为 upvalue 藏在辅助函数 closure 中，当从 Lua 调用 UE 函数时，本质上调用的是 closure <code>Class_CallUFunction</code> 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TSharedPtr&lt;FFunctionDesc&gt; Function = Field-&gt;<span class="built_in">AsFunction</span>();</span><br><span class="line">Env.<span class="built_in">GetObjectRegistry</span>()-&gt;<span class="built_in">Push</span>(L, Function);</span><br><span class="line"><span class="keyword">if</span> (Function-&gt;<span class="built_in">IsLatentFunction</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">lua_pushcclosure</span>(L, Class_CallLatentFunction, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">lua_pushcclosure</span>(L, Class_CallUFunction, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>FFunctionDesc</code> 的 <code>CallUE</code> 方法执行到真正的 UE 函数。这里我们还是先跳过 <code>Latent</code> 函数的处理方法，以及跳过 <code>CallUE</code> 函数的细节，至少到这里，我们已经理解了如何在 Lua 代码中找到 UE函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">int32 <span class="title">Class_CallUFunction</span><span class="params">(lua_State *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; Env = UnLua::FLuaEnv::<span class="built_in">FindEnvChecked</span>(L);</span><br><span class="line">    <span class="keyword">auto</span> Function = Env.<span class="built_in">GetObjectRegistry</span>()-&gt;<span class="built_in">Get</span>&lt;FFunctionDesc&gt;(L, <span class="built_in">lua_upvalueindex</span>(<span class="number">1</span>));</span><br><span class="line">    int32 NumParams = <span class="built_in">lua_gettop</span>(L);</span><br><span class="line">    int32 NumResults = Function-&gt;<span class="built_in">CallUE</span>(L, NumParams);</span><br><span class="line">    <span class="keyword">return</span> NumResults;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调用-UFunction"><a href="#调用-UFunction" class="headerlink" title="调用 UFunction"></a>调用 UFunction</h2><p>根据参数个数和是否静态函数找出第一个参数索引。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">int32 <span class="title">FFunctionDesc::CallUE</span><span class="params">(lua_State *L, int32 NumParams, <span class="type">void</span> *Userdata)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UObject* Object;</span><br><span class="line">    int32 FirstParamIndex;</span><br><span class="line">    <span class="keyword">if</span> (bStaticFunc)</span><br><span class="line">    &#123;</span><br><span class="line">        Object = Function-&gt;<span class="built_in">GetOuterUClass</span>()-&gt;<span class="built_in">GetDefaultObject</span>();</span><br><span class="line">        FirstParamIndex = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (NumParams &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Object = UnLua::<span class="built_in">GetUObject</span>(L, <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">        FirstParamIndex = <span class="number">2</span>;</span><br><span class="line">        --NumParams;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Object = <span class="literal">nullptr</span>;</span><br><span class="line">        FirstParamIndex = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>根据 <code>Callspace</code> 决定是直接分发，还是走 RPC 调用。<code>Func_NetMuticast</code> 则先本地调用再远端调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    int32 Callspace = Object-&gt;<span class="built_in">GetFunctionCallspace</span>(Function.<span class="built_in">Get</span>(), <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">bool</span> bRemote = Callspace &amp; FunctionCallspace::Remote;</span><br><span class="line">    <span class="type">bool</span> bLocal = Callspace &amp; FunctionCallspace::Local;</span><br><span class="line"></span><br><span class="line">    FFlagArray CleanupFlags;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> Params = Buffer-&gt;<span class="built_in">Get</span>(); </span><br><span class="line">    <span class="built_in">PreCall</span>(L, NumParams, FirstParamIndex, CleanupFlags, Params, Userdata);</span><br><span class="line">    <span class="keyword">auto</span> FinalFunction = bInterfaceFunc</span><br><span class="line">                             ? Object-&gt;<span class="built_in">GetClass</span>()-&gt;<span class="built_in">FindFunctionByName</span>(Function-&gt;<span class="built_in">GetFName</span>())</span><br><span class="line">                             : Function.<span class="built_in">Get</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!Function-&gt;<span class="built_in">HasAnyFunctionFlags</span>(FUNC_Net))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> LuaFunction = ULuaFunction::<span class="built_in">Get</span>(Function.<span class="built_in">Get</span>());</span><br><span class="line">        <span class="keyword">if</span> (LuaFunction &amp;&amp; LuaFunction-&gt;<span class="built_in">GetOverridden</span>())</span><br><span class="line">            FinalFunction = LuaFunction-&gt;<span class="built_in">GetOverridden</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bLocal)</span><br><span class="line">    &#123;   </span><br><span class="line">        Object-&gt;UObject::<span class="built_in">ProcessEvent</span>(FinalFunction, Params);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bRemote &amp;&amp; !bLocal)</span><br><span class="line">    &#123;</span><br><span class="line">        Object-&gt;<span class="built_in">CallRemoteFunction</span>(FinalFunction, Params, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int32 NumReturnValues = <span class="built_in">PostCall</span>(L, NumParams, FirstParamIndex, Params, CleanupFlags);</span><br><span class="line">    Buffer-&gt;<span class="built_in">Pop</span>(Params);</span><br><span class="line">    <span class="keyword">return</span> NumReturnValues;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PreCall</code> 和 <code>PostCall</code> 只是参数和返回值读入写出操作，如果 Lua 传递的参数不足，则考虑用函数声明的默认值去填充，若连函数声明的默认值也没有，就用初始化值。<br><img data-src="/images/UE5_UnLua_%E8%84%9A%E6%9C%AC%E6%96%B9%E6%A1%88%E5%8E%9F%E7%90%86-1760959091705.png"></p><h2 id="Latent-函数"><a href="#Latent-函数" class="headerlink" title="Latent 函数"></a>Latent 函数</h2><p>是一种 <strong>可以在蓝图或 C++ 中异步执行的函数</strong>，可以简单理解为开了个协程。<br>以下为 <code>UKismetSystemLibrary</code> 的 <code>Delay</code> 函数声明。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, Category=<span class="string">&quot;Utilities|FlowControl&quot;</span>, meta=(Latent, WorldContext=<span class="string">&quot;WorldContextObject&quot;</span>, LatentInfo=<span class="string">&quot;LatentInfo&quot;</span>, Duration=<span class="string">&quot;0.2&quot;</span>, Keywords=<span class="string">&quot;sleep&quot;</span>))  </span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Delay</span><span class="params">(<span class="type">const</span> UObject* WorldContextObject, <span class="type">float</span> Duration, <span class="keyword">struct</span> FLatentActionInfo LatentInfo )</span></span>;</span><br></pre></td></tr></table></figure><p>声明一个 Latent 函数，需要在元标签处写出 <code>meta = (Latent, LatentInfo = &quot;LatentInfo&quot;)</code>。<br>其实也没有什么特别的，就是 Lua 执行 Latent 函数之后，应该让出时间片，然后等执行完后被唤醒就行，这些功能 Lua 本身就有。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">int32 <span class="title">Class_CallLatentFunction</span><span class="params">(lua_State *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; Env = UnLua::FLuaEnv::<span class="built_in">FindEnvChecked</span>(L);</span><br><span class="line">    <span class="keyword">auto</span> Function = Env.<span class="built_in">GetObjectRegistry</span>()-&gt;<span class="built_in">Get</span>&lt;FFunctionDesc&gt;(L, <span class="built_in">lua_upvalueindex</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ThreadRef = Env.<span class="built_in">FindOrAddThread</span>(L); <span class="comment">// lua_pushthread</span></span><br><span class="line"></span><br><span class="line">    int32 NumParams = <span class="built_in">lua_gettop</span>(L);</span><br><span class="line">    int32 NumResults = Function-&gt;<span class="built_in">CallUE</span>(L, NumParams, &amp;ThreadRef);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lua_yield</span>(L, NumResults);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lua 调用 Latent 的时候，UnLua 会帮它填充 <code>FLatentActionInfo</code> ，使其执行完后回调回来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FLatentActionInfo <span class="title">LatentActionInfo</span><span class="params">(ThreadRef, GetTypeHash(FGuid::NewGuid()), TEXT(<span class="string">&quot;OnLatentActionCompleted&quot;</span>), (Env.GetManager()))</span></span>;</span><br></pre></td></tr></table></figure><p><code>OnLatentActionCompleted</code> 函数内部负责唤醒该 Lua 协程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> NResults = <span class="number">0</span>;  </span><br><span class="line">int32 Status = <span class="built_in">lua_resume</span>(Thread, L, <span class="number">0</span>, &amp;NResults);</span><br></pre></td></tr></table></figure><h2 id="Delegate"><a href="#Delegate" class="headerlink" title="Delegate"></a>Delegate</h2><p><code>Delegate</code> 的本质是记录对象地址和需要触发的函数名：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TScriptDelegate</span>() </span><br><span class="line">    : <span class="built_in">Object</span>( <span class="literal">nullptr</span> ),</span><br><span class="line">      <span class="built_in">FunctionName</span>( NAME_None ) &#123; &#125;</span><br></pre></td></tr></table></figure><p>因此只要正确填充这里面的内容就可以被执行到，现在唯一的问题是，Lua 函数填充不了。因此 UnLua 创建了 <code>ULuaDelegateHandler</code> 这个类作为代理中转。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UNLUA_API</span> ULuaDelegateHandler : <span class="keyword">public</span> UObject</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UFUNCTION</span>()</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Dummy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ProcessEvent</span><span class="params">(UFunction* Function, <span class="type">void</span>* Parms)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TWeakObjectPtr&lt;UObject&gt; SelfObject;</span><br><span class="line">    UnLua::FDelegateRegistry* Registry;</span><br><span class="line">    int32 LuaRef;</span><br><span class="line">    <span class="type">void</span>* Delegate;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个 <code>FScriptDelegate</code> 都为其创建一个 <code>ULuaDelegateHandler</code> ，并绑定到 <code>Dummy</code> 函数内。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InDelegate-&gt;<span class="built_in">BindUFunction</span>(<span class="keyword">this</span>, NAME_Dummy);</span><br></pre></td></tr></table></figure><p>同时重写了 <code>ProcessEvent</code> 当代理触发时，转发给 Lua 函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ULuaDelegateHandler::ProcessEvent</span><span class="params">(UFunction* Function, <span class="type">void</span>* Parms)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Registry)</span><br><span class="line">        Registry-&gt;<span class="built_in">Execute</span>(<span class="keyword">this</span>, Parms); <span class="comment">// SignatureDesc-&gt;CallLua(L, Handler-&gt;LuaRef, Params, Handler-&gt;SelfObject.Get());</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="覆写函数流程"><a href="#覆写函数流程" class="headerlink" title="覆写函数流程"></a>覆写函数流程</h2><p>前面讲解对象绑定到 Lua Module 时，为了思路连贯，跳过了覆写函数的具体实现，现在再回过头来看。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">UUnLuaManager::BindClass</span><span class="params">(UClass* Class, <span class="type">const</span> FString&amp; InModuleName, FString&amp; Error)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    UnLua::LowLevel::<span class="built_in">GetFunctionNames</span>(Env-&gt;<span class="built_in">GetMainState</span>(), Ref, BindInfo.LuaFunctions);</span><br></pre></td></tr></table></figure><p><code>GetFunctionNames</code> 遍历 Lua Module Table，找出所有函数，会遍历父类。<br>找出所有可以被重写的 UE 函数，包括 <code>RepNotify</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ULuaFunction::<span class="built_in">GetOverridableFunctions</span>(Class, BindInfo.UEFunctions);</span><br></pre></td></tr></table></figure><p><img data-src="/images/UE5_UnLua_%E8%84%9A%E6%9C%AC%E6%96%B9%E6%A1%88%E5%8E%9F%E7%90%86-1761016392303.png"><br>判定规则为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ULuaFunction::IsOverridable</span><span class="params">(<span class="type">const</span> UFunction* Function)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> uint32 FlagMask = FUNC_Native | FUNC_Event | FUNC_Net;  </span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> uint32 FlagResult = FUNC_Native | FUNC_Event;  </span><br><span class="line">    <span class="keyword">return</span> Function-&gt;<span class="built_in">HasAnyFunctionFlags</span>(FUNC_BlueprintEvent) || (Function-&gt;FunctionFlags &amp; FlagMask) == FlagResult;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BlueprintEvent</code> 对应的 UE 声明方式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintImplementableEvent)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoSomething</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintNativeEvent)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoSomething</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>Blueprint Event 系列函数本身就是可被蓝图重写的函数，所以这类自然被认为“可 Lua override”。<br><code>FUNC_Native | FUNC_Event</code> 对应 UE 声明方式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnAction</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>不可覆写的类型<ul><li>含 <code>FUNC_Net</code> 标志：<code>UFUNCTION(Server)</code> &#x2F; <code>UFUNCTION(Client)</code> &#x2F; <code>UFUNCTION(NetMulticast)</code></li><li>没有 <code>FUNC_Event</code> 标志：<code>UFUNCTION()</code> 普通函数（非虚）</li></ul></li></ul><p>遍历所有 Lua Module 函数，检查是否有相同名字的 UE 函数，此时进行覆写。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; LuaFuncName : BindInfo.LuaFunctions)</span><br><span class="line">&#123;</span><br><span class="line">    UFunction** Func = BindInfo.UEFunctions.<span class="built_in">Find</span>(LuaFuncName);</span><br><span class="line">    <span class="keyword">if</span> (Func)</span><br><span class="line">    &#123;</span><br><span class="line">        UFunction* Function = *Func;</span><br><span class="line">        ULuaFunction::<span class="built_in">Override</span>(Function, Class, LuaFuncName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要覆写 <code>UFunction</code> ，自然的想法是改写 <code>UFunction</code> 的字节码，但这只适用于覆写蓝图实现的函数，不适用于 <code>FUNC_Native | FUNC_Event</code> 的函数。<br>那就只剩下一条路，创建一个山寨的 <code>UFunction</code> 事实上 UnLua 就是这样做的，它创建了个 <code>ULuaFunction</code> 并继承自原始的 <code>UFunction</code> 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UNLUA_API</span> ULuaFunction : <span class="keyword">public</span> UFunction</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TWeakObjectPtr&lt;UFunction&gt; From;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UPROPERTY</span>()</span><br><span class="line">    UFunction* Overridden;</span><br><span class="line"></span><br><span class="line">    uint8 bAdded : <span class="number">1</span>;</span><br><span class="line">    uint8 bActivated : <span class="number">1</span>;</span><br><span class="line">    TSharedPtr&lt;FFunctionDesc&gt; Desc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但创建出来的 <code>ULuaFunction</code> 挂在哪里？一种简单的想法是挂在 <code>INSTANCE</code> 的 <code>StaticClass</code> 中，UnLua 估计认为这样做不好管理（考虑如果要还原的情况），于是又引出了另一个概念 <code>ULuaOverridesClass</code> 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>(Transient)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UNLUA_API</span> ULuaOverridesClass : <span class="keyword">public</span> UClass</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> ULuaOverridesClass* <span class="title">Create</span><span class="params">(UClass* Class)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个需要覆写的 <code>UClass</code> 都会创建一个 <code>ULuaOverridesClass</code>，将所有 <code>ULuaFunction</code> 挂接在里面，这样可以很方便的激活、还原覆写。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ULuaOverridesClass::SetActive</span><span class="params">(<span class="type">const</span> <span class="type">bool</span> bActive)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TFieldIterator&lt;ULuaFunction&gt; <span class="built_in">It</span>(<span class="keyword">this</span>, EFieldIteratorFlags::ExcludeSuper); It; ++It)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> LuaFunction = *It;</span><br><span class="line">        LuaFunction-&gt;<span class="built_in">SetActive</span>(bActive);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <code>ULuaOverridesClass</code> 自身会作为一个字段，存储在我们覆写过的 <code>UClass</code> 下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ULuaOverridesClass::AddToOwner</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> Field = &amp;(Class-&gt;Children);</span><br><span class="line">    <span class="keyword">while</span> (*Field)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*Field == <span class="keyword">this</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Field = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Field = &amp;(*Field)-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Field)</span><br><span class="line">        *Field = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理清了设计思路，现在的问题是怎么用创建的 <code>ULuaFunction</code> 去替代 <code>UFunction</code> 使得逻辑走到我们想要的地方去。<br>覆写函数有两种情况：</p><ol><li>该函数本身就在当前类中，此时覆写为非新增函数。</li><li>该函数不在当前类中，是从父类继承下来的，此时覆写为新增函数。</li></ol><p>以下的 <code>bAddNew</code> 就表明是否是新增函数，同时从 <code>UFunction</code> 中拷贝一份作为 <code>ULuaFunction</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FLuaOverrides::Override</span><span class="params">(UFunction* Function, UClass* Class, FName NewName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> OverridesClass = <span class="built_in">GetOrAddOverridesClass</span>(Class);</span><br><span class="line"></span><br><span class="line">    ULuaFunction* LuaFunction;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> bAddNew = Function-&gt;<span class="built_in">GetOuter</span>() != Class;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> OriginalFunctionFlags = Function-&gt;FunctionFlags;</span><br><span class="line">    Function-&gt;FunctionFlags &amp;= (~EFunctionFlags::FUNC_Native);</span><br><span class="line"></span><br><span class="line">    <span class="function">FObjectDuplicationParameters <span class="title">DuplicationParams</span><span class="params">(Function, OverridesClass)</span></span>;</span><br><span class="line">    DuplicationParams.InternalFlagMask &amp;= ~EInternalObjectFlags::Native;</span><br><span class="line">    DuplicationParams.DestName = NewName;</span><br><span class="line">    DuplicationParams.DestClass = ULuaFunction::<span class="built_in">StaticClass</span>();</span><br><span class="line">    LuaFunction = <span class="built_in">static_cast</span>&lt;ULuaFunction*&gt;(<span class="built_in">StaticDuplicateObjectEx</span>(DuplicationParams));</span><br><span class="line"></span><br><span class="line">    Function-&gt;FunctionFlags = OriginalFunctionFlags;</span><br><span class="line">    LuaFunction-&gt;FunctionFlags = OriginalFunctionFlags;</span><br><span class="line"></span><br><span class="line">    LuaFunction-&gt;Next = OverridesClass-&gt;Children;</span><br><span class="line">    OverridesClass-&gt;Children = LuaFunction;</span><br><span class="line"></span><br><span class="line">    LuaFunction-&gt;<span class="built_in">StaticLink</span>(<span class="literal">true</span>);</span><br><span class="line">    LuaFunction-&gt;<span class="built_in">Initialize</span>();</span><br><span class="line">    LuaFunction-&gt;<span class="built_in">Override</span>(Function, Class, bAddNew);</span><br><span class="line">    LuaFunction-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了实现还原的功能，在 <code>ULuaFunction</code> 内还复制了一份 <code>UFunction</code> 到 <code>Overridden</code> 中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ULuaFunction::Override</span><span class="params">(UFunction* Function, UClass* Class, <span class="type">bool</span> bAddNew)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Function-&gt;<span class="built_in">GetNativeFunc</span>() == execScriptCallLua)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> DestName = FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;%s__Overridden&quot;</span>), *Function-&gt;<span class="built_in">GetName</span>());</span><br><span class="line">        <span class="keyword">if</span> (Function-&gt;<span class="built_in">HasAnyFunctionFlags</span>(FUNC_Native))</span><br><span class="line">            <span class="built_in">GetOuterUClass</span>()-&gt;<span class="built_in">AddNativeFunction</span>(*DestName, *Function-&gt;<span class="built_in">GetNativeFunc</span>());</span><br><span class="line">        Overridden = <span class="built_in">static_cast</span>&lt;UFunction*&gt;(<span class="built_in">StaticDuplicateObject</span>(Function, <span class="built_in">GetOuter</span>(), *DestName));</span><br><span class="line">        Overridden-&gt;<span class="built_in">ClearInternalFlags</span>(EInternalObjectFlags::Native);</span><br><span class="line">        Overridden-&gt;<span class="built_in">StaticLink</span>(<span class="literal">true</span>);</span><br><span class="line">        Overridden-&gt;<span class="built_in">SetNativeFunc</span>(Function-&gt;<span class="built_in">GetNativeFunc</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SetActive</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在什么都不缺了：<br><img data-src="/images/UE5_UnLua_%E8%84%9A%E6%9C%AC%E6%96%B9%E6%A1%88%E5%8E%9F%E7%90%86-1761028762295.jpg"><br>可以开始劫持执行流了，<code>SetActive</code> 就是做这个的。<br>现在只考虑新增函数，也就是前面提到过的这个函数来自于父类，劫持方法是直接将该 <code>ULuaFunction</code> 改为 <code>FUNC_Native</code> 函数，使得调用时必须走到 <code>execCallLua</code> ，并将自身函数添加到 <code>UClass</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ULuaFunction::SetActive</span><span class="params">(<span class="type">const</span> <span class="type">bool</span> bActive)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> Class = <span class="built_in">Cast</span>&lt;ULuaOverridesClass&gt;(<span class="built_in">GetOuter</span>())-&gt;<span class="built_in">GetOwner</span>();</span><br><span class="line">    <span class="keyword">if</span> (bAdded)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">SetSuperStruct</span>(Function);</span><br><span class="line">        FunctionFlags |= FUNC_Native;</span><br><span class="line">        <span class="built_in">ClearInternalFlags</span>(EInternalObjectFlags::Native);</span><br><span class="line">        <span class="built_in">SetNativeFunc</span>(execCallLua);</span><br><span class="line"></span><br><span class="line">        Class-&gt;<span class="built_in">AddFunctionToFunctionMap</span>(<span class="keyword">this</span>, *<span class="built_in">GetName</span>());</span><br><span class="line">        <span class="keyword">if</span> (Function-&gt;<span class="built_in">HasAnyFunctionFlags</span>(FUNC_Native))</span><br><span class="line">            Class-&gt;<span class="built_in">AddNativeFunction</span>(*<span class="built_in">GetName</span>(), &amp;ULuaFunction::execCallLua);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>execCallLua</code> 实质上是个 <code>Thunk</code> 函数，可以简单理解为一个跳板函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DECLARE_FUNCTION</span>(execCallLua);</span><br><span class="line"><span class="built_in">DEFINE_FUNCTION</span>(ULuaFunction::execCallLua)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> LuaFunction = <span class="built_in">Cast</span>&lt;ULuaFunction&gt;(Stack.CurrentNativeFunction);</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> Env = IUnLuaModule::<span class="built_in">Get</span>().<span class="built_in">GetEnv</span>(Context);</span><br><span class="line">    <span class="keyword">if</span> (!Env)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Env-&gt;<span class="built_in">GetFunctionRegistry</span>()-&gt;<span class="built_in">Invoke</span>(LuaFunction, Context, Stack, RESULT_PARAM);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Invoke</code> 内部会处理好入参，然后调用 Lua 函数，并处理返回值。<br><code>SetActive</code> 还有种情况，函数本身就存在于 <code>UClass</code>，此时不能简单的将自身添加进去，只能在 <code>UFunction</code> 自身做文章，在这里则是强行加上一段字节码，里面是真正的 <code>ULuaFunction</code> 的指针地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">SetSuperStruct</span>(Function-&gt;<span class="built_in">GetSuperStruct</span>());</span><br><span class="line">    Script = Function-&gt;Script;</span><br><span class="line">    Children = Function-&gt;Children;</span><br><span class="line">    ChildProperties = Function-&gt;ChildProperties;</span><br><span class="line">    PropertyLink = Function-&gt;PropertyLink;</span><br><span class="line"></span><br><span class="line">    Function-&gt;FunctionFlags |= FUNC_Native;</span><br><span class="line">    Function-&gt;<span class="built_in">SetNativeFunc</span>(&amp;execScriptCallLua);</span><br><span class="line">    Function-&gt;<span class="built_in">GetOuterUClass</span>()-&gt;<span class="built_in">AddNativeFunction</span>(*Function-&gt;<span class="built_in">GetName</span>(), &amp;execScriptCallLua);</span><br><span class="line">    Function-&gt;Script.<span class="built_in">Empty</span>();</span><br><span class="line">    Function-&gt;Script.<span class="built_in">AddUninitialized</span>(ScriptMagicHeaderSize + <span class="built_in">sizeof</span>(ULuaFunction*));</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> Data = Function-&gt;Script.<span class="built_in">GetData</span>();</span><br><span class="line">    FPlatformMemory::<span class="built_in">Memcpy</span>(Data, ScriptMagicHeader, ScriptMagicHeaderSize);</span><br><span class="line">    FPlatformMemory::<span class="built_in">WriteUnaligned</span>&lt;ULuaFunction*&gt;(Data + ScriptMagicHeaderSize, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从字节码中找出真正的 <code>ULuaFunction</code> 地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DECLARE_FUNCTION</span>(execScriptCallLua);</span><br><span class="line"><span class="built_in">DEFINE_FUNCTION</span>(ULuaFunction::execScriptCallLua)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> Data = Function-&gt;Script.<span class="built_in">GetData</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> LuaFunction = FPlatformMemory::<span class="built_in">ReadUnaligned</span>&lt;ULuaFunction*&gt;(Data + ScriptMagicHeaderSize);</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>几乎可以说所有的 UnLua 创建的 Lua 对象，都会放在 Lua 注册表内保持强引用（如果是不需要绑定的 <code>UObject</code> 被 Push 进 Lua，则不会强引用），因此不会触发垃圾回收。只有 UE侧释放了这个 <code>UObject</code> 时，才会反注册，同时对 <code>userdata</code> 指针设置为已释放标识，避免后续 Lua 访问导致崩溃。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*((<span class="type">void</span>**)Userdata) = (<span class="type">void</span>*)LowLevel::ReleasedPtr;</span><br></pre></td></tr></table></figure><p>Push 进 Lua 的 <code>UObject</code> 都是二级指针的形式。<br><code>ULuaDelegateHandler</code> 是个特例，在创建之后会放入 <code>FObjectReferencer AutoObjectReference;</code> 保持 UE的强引用，<code>__gc</code> 的时候会触发一下删除。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>UnLua 还有容器的导出、静态类导出，自动绑定输入这些功能，难度不大就留给读者自己去探索了。</p></div><footer class="post-footer"><div class="post-tags"><a href="/tags/UE5/" rel="tag"># UE5</a> <a href="/tags/UnLua/" rel="tag"># UnLua</a></div><div class="post-nav"><div class="post-nav-item"><a href="/UE5%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3/" rel="prev" title="UE5 智能指针详解"><i class="fa fa-angle-left"></i> UE5 智能指针详解</a></div><div class="post-nav-item"><a href="/UE5%20%E5%A2%9E%E9%87%8F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/" rel="next" title="UE5 增量垃圾回收深度解析">UE5 增量垃圾回收深度解析 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Yuerer</span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://unpkg.com/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://unpkg.com/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/comments.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/utils.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/motion.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/sidebar.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/next-boot.min.js"></script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://yuerer-comment-xufei-0bea01e6f05-1307930306.ap-shanghai.app.tcloudbase.com","cssUrl":"https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.css","commentCount":true,"pageview":true,"libUrl":"https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.js","locale":{"placeholder":"有何高见？"},"emoji":["https://unpkg.com/@waline/emojis@1.0.1/qq"],"meta":["nick","mail"],"requiredMeta":[["nick","mail"]],"wordLimit":0,"login":"disable","pageSize":10,"el":"#waline","comment":true,"path":"/UE5%20UnLua%20%E8%84%9A%E6%9C%AC%E6%96%B9%E6%A1%88%E5%8E%9F%E7%90%86/"}</script><link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.css"><script>document.addEventListener("page:loaded",()=>{NexT.utils.loadComments(CONFIG.waline.el).then(()=>NexT.utils.getScript(CONFIG.waline.libUrl,{condition:window.Waline})).then(()=>Waline.init(Object.assign({},CONFIG.waline,{el:document.querySelector(CONFIG.waline.el)})))})</script></body></html>