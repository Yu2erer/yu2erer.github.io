<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.jpeg"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.ico"><link rel="mask-icon" href="/images/avatar.jpeg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous"><link rel="stylesheet" href="https://unpkg.com/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"yuerer.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"hide","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":true,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/config.min.js"></script><meta name="description" content="其实在此之前已经写了一个 Lua 5.3 源码剖析系列，还有好几篇存档没有发。为什么突然又不发了呢？（甚至还删了），是因为我感觉之前那样学习的方式过于难受，折磨心智（人这一生最不该做的就是折磨自己），没有抓清主次，同时和网络上的博文同质化严重。因此就决定，再读一次 Lua 的源码，这次读的是 Lua 5.3.6 是 Lua 5.3 系列的最后一个版本。 本系列，不会谈论 Lua 语法，也默认读者已"><meta property="og:type" content="article"><meta property="og:title" content="Lua 5.3 设计实现(一) Lua是怎么跑起来的?"><meta property="og:url" content="https://yuerer.com/Lua5.3-%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0(%E4%B8%80)-Lua%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/index.html"><meta property="og:site_name" content="Yuerer&#39;s Blog"><meta property="og:description" content="其实在此之前已经写了一个 Lua 5.3 源码剖析系列，还有好几篇存档没有发。为什么突然又不发了呢？（甚至还删了），是因为我感觉之前那样学习的方式过于难受，折磨心智（人这一生最不该做的就是折磨自己），没有抓清主次，同时和网络上的博文同质化严重。因此就决定，再读一次 Lua 的源码，这次读的是 Lua 5.3.6 是 Lua 5.3 系列的最后一个版本。 本系列，不会谈论 Lua 语法，也默认读者已"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2020-10-25T05:12:20.000Z"><meta property="article:modified_time" content="2025-10-21T13:50:52.254Z"><meta property="article:author" content="Yuerer"><meta property="article:tag" content="Lua"><meta property="article:tag" content="Lua虚拟机"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://yuerer.com/Lua5.3-%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0(%E4%B8%80)-Lua%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://yuerer.com/Lua5.3-%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0(%E4%B8%80)-Lua%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/","path":"Lua5.3-设计实现(一)-Lua是怎么跑起来的/","title":"Lua 5.3 设计实现(一) Lua是怎么跑起来的?"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Lua 5.3 设计实现(一) Lua是怎么跑起来的? | Yuerer's Blog</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-129491388-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-129491388-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/third-party/analytics/google-analytics.min.js"></script><link rel="dns-prefetch" href="https://yuerer-comment-xufei-0bea01e6f05-1307930306.ap-shanghai.app.tcloudbase.com"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Yuerer's Blog</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">钰儿的Blog</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Lua-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B"><span class="nav-text">Lua 编译过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD-Chunk"><span class="nav-text">加载 Chunk</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lua-State"><span class="nav-text">lua_State</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#lua-newstate"><span class="nav-text">lua_newstate</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E8%AF%AD"><span class="nav-text">结语</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Yuerer" src="/images/avatar.jpeg"><p class="site-author-name" itemprop="name">Yuerer</p><div class="site-description" itemprop="description">钰儿的Blog</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">65</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">16</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">90</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/Yu2erer" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Yu2erer" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:yu2erer#gmail.com" title="E-Mail → mailto:yu2erer#gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://yuerer.com/Lua5.3-%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0(%E4%B8%80)-Lua%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpeg"><meta itemprop="name" content="Yuerer"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Yuerer's Blog"><meta itemprop="description" content="钰儿的Blog"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Lua 5.3 设计实现(一) Lua是怎么跑起来的? | Yuerer's Blog"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Lua 5.3 设计实现(一) Lua是怎么跑起来的?</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-10-25 13:12:20" itemprop="dateCreated datePublished" datetime="2020-10-25T13:12:20+08:00">2020-10-25</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Lua/" itemprop="url" rel="index"><span itemprop="name">Lua</span></a> </span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Waline：</span> <a title="waline" href="/Lua5.3-%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0(%E4%B8%80)-Lua%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/Lua5.3-%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0(%E4%B8%80)-Lua%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/" itemprop="commentCount"></span> </a></span><span class="post-meta-item" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="waline-pageview-count" data-path="/Lua5.3-%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0(%E4%B8%80)-Lua%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/"></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>其实在此之前已经写了一个 Lua 5.3 源码剖析系列，还有好几篇存档没有发。为什么突然又不发了呢？（甚至还删了），是因为我感觉之前那样学习的方式过于难受，折磨心智（人这一生最不该做的就是折磨自己），没有抓清主次，同时和网络上的博文同质化严重。因此就决定，再读一次 Lua 的源码，这次读的是 Lua 5.3.6 是 Lua 5.3 系列的最后一个版本。</p><p>本系列，不会谈论 Lua 语法，也默认读者已经有 Lua使用经验，我们将绕过 Lua 的编译器（大部分都是词法语法分析），直接进入到 Lua解释器中，来学习我们写好的 Lua 源码是怎么跑起来的。为了理解的方便，代码会有大量删减，只抽取其核心。</p><h2 id="Lua-编译过程"><a href="#Lua-编译过程" class="headerlink" title="Lua 编译过程"></a>Lua 编译过程</h2><p>虽然，我们在一开始就说好，不谈论 Lua 编译器，但是还是要先理解 Lua 的运行机制。这里简单提一下，你写好的 <code>xxx.lua</code> 文件 会经过 luac 工具将 Lua源代码编译成 二进制文件，Lua 作者在代码中称其为 Chunk，接着 Lua解释器会加载它并执行，所以 Lua执行起来，看起来是边执行边编译，但实际上是先编译成 Chunk，再加载 Chunk去执行。</p><h2 id="加载-Chunk"><a href="#加载-Chunk" class="headerlink" title="加载 Chunk"></a>加载 Chunk</h2><p>假设我们现在有一段 lua代码，且已经过了 luac工具 编译出了 Chunk，那么 Lua解释器是怎么将其加载的呢？</p><p>我们可以大胆猜测，Lua会有个load函数，去load我们的 Chunk。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LUA_API <span class="type">int</span> <span class="title function_">lua_load</span> <span class="params">(lua_State *L, lua_Reader reader, <span class="type">void</span> *data,</span></span><br><span class="line"><span class="params">                      <span class="type">const</span> <span class="type">char</span> *chunkname, <span class="type">const</span> <span class="type">char</span> *mode)</span> &#123;</span><br><span class="line">  ....</span><br><span class="line">  status = luaD_protectedparser(L, &amp;z, chunkname, mode);</span><br><span class="line">  <span class="keyword">if</span> (status == LUA_OK) &#123;  <span class="comment">/* no errors? */</span></span><br><span class="line">    LClosure *f = clLvalue(L-&gt;top - <span class="number">1</span>);  <span class="comment">/* get newly created function */</span></span><br><span class="line">		....</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><p>确实拥有这个函数，其本质会调用 <code>luaD_protectedparser</code>，其内部又调用了 <code>f_parser</code> ，不用害怕 <code>luaD_pcall</code> 这个函数，其内部就是调用了传进去的函数指针，这里指 <code>f_parser</code> 。函数名p 指 Protect 安全的调用，其实就是有捕获异常的功能的调用函数，由于C语言没有异常机制，因此它内部用的 <code>setjmp</code> 来实现函数间跳转，模拟异常机制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">luaD_protectedparser</span> <span class="params">(lua_State *L, ZIO *z, <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">                                        <span class="type">const</span> <span class="type">char</span> *mode)</span> &#123;</span><br><span class="line">	....</span><br><span class="line">  status = luaD_pcall(L, f_parser, &amp;p, savestack(L, L-&gt;top), L-&gt;errfunc);</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>f_parser</code> 会根据实际情况，选择从二进制或者文本中解析 Chunk，为了简单起见，我们只关注从二进制中解析的方法 即 <code>luaU_undump</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">f_parser</span> <span class="params">(lua_State *L, <span class="type">void</span> *ud)</span> &#123;</span><br><span class="line">  LClosure *cl;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">SParser</span> *<span class="title">p</span> =</span> cast(<span class="keyword">struct</span> SParser *, ud);</span><br><span class="line">  <span class="type">int</span> c = zgetc(p-&gt;z);  <span class="comment">/* read first character */</span></span><br><span class="line">  <span class="keyword">if</span> (c == LUA_SIGNATURE[<span class="number">0</span>]) &#123;</span><br><span class="line">    checkmode(L, p-&gt;mode, <span class="string">&quot;binary&quot;</span>);</span><br><span class="line">    cl = luaU_undump(L, p-&gt;z, p-&gt;name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    checkmode(L, p-&gt;mode, <span class="string">&quot;text&quot;</span>);</span><br><span class="line">    cl = luaY_parser(L, p-&gt;z, &amp;p-&gt;buff, &amp;p-&gt;dyd, p-&gt;name, c);</span><br><span class="line">  &#125;</span><br><span class="line">  luaF_initupvals(L, cl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>luaU_undump</code> 会先检查 Header，然后创建一个 closure，可以理解为是一个函数，里面会有其各种试行信息，然后将其放在虚拟机的栈顶，最后返回回去。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LClosure *<span class="title function_">luaU_undump</span><span class="params">(lua_State *L, ZIO *Z, <span class="type">const</span> <span class="type">char</span> *name)</span> &#123;</span><br><span class="line">  LoadState S;</span><br><span class="line">  LClosure *cl;</span><br><span class="line">	....</span><br><span class="line">  checkHeader(&amp;S);</span><br><span class="line">  cl = luaF_newLclosure(L, LoadByte(&amp;S));</span><br><span class="line">  setclLvalue(L, L-&gt;top, cl);</span><br><span class="line">  luaD_inctop(L);</span><br><span class="line">  cl-&gt;p = luaF_newproto(L);</span><br><span class="line">  LoadFunction(&amp;S, cl-&gt;p, <span class="literal">NULL</span>);</span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">return</span> cl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>checkHeader</code> 主要是检查 Chunk 的Lua版本，大端小端字节序，浮点数是怎么存储的等信息，可以看出 Lua的设计理念是，不同版本我就直接不让你运行，非常霸道。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">checkHeader</span> <span class="params">(LoadState *S)</span> &#123;</span><br><span class="line">  checkliteral(S, LUA_SIGNATURE + <span class="number">1</span>, <span class="string">&quot;not a&quot;</span>);  <span class="comment">/* 1st char already checked */</span></span><br><span class="line">  <span class="keyword">if</span> (LoadByte(S) != LUAC_VERSION)</span><br><span class="line">    error(S, <span class="string">&quot;version mismatch in&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (LoadByte(S) != LUAC_FORMAT)</span><br><span class="line">    error(S, <span class="string">&quot;format mismatch in&quot;</span>);</span><br><span class="line">  checkliteral(S, LUAC_DATA, <span class="string">&quot;corrupted&quot;</span>);</span><br><span class="line">  checksize(S, <span class="type">int</span>);</span><br><span class="line">  checksize(S, <span class="type">size_t</span>);</span><br><span class="line">  checksize(S, Instruction);</span><br><span class="line">  checksize(S, lua_Integer);</span><br><span class="line">  checksize(S, lua_Number);</span><br><span class="line">  <span class="keyword">if</span> (LoadInteger(S) != LUAC_INT)</span><br><span class="line">    error(S, <span class="string">&quot;endianness mismatch in&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (LoadNumber(S) != LUAC_NUM)</span><br><span class="line">    error(S, <span class="string">&quot;float format mismatch in&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在回过头来看 <code>closure</code> 的结构定义。我们可以确定 cl 中的 Proto 才是函数原型，同时 cl 分为 Lua函数和 C函数。 <code>upvals</code> 根据字面意思可以翻译为 上值，属于 Lua 特有，因为 Lua 支持嵌套函数，函数是一等公民，采用了 静态作用域，将外界的变量绑定进来，可以暂时理解为将全局变量绑定进来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Proto</span> &#123;</span></span><br><span class="line">  CommonHeader;</span><br><span class="line">  lu_byte numparams;  <span class="comment">// 固定函数个数</span></span><br><span class="line">  lu_byte is_vararg;  <span class="comment">// 是否是可变长参数</span></span><br><span class="line">  lu_byte maxstacksize;  <span class="comment">// 寄存器数量，用栈模拟</span></span><br><span class="line">  <span class="type">int</span> sizeupvalues;  <span class="comment">// Upvalues 个数</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> sizek;  <span class="comment">/* size of &#x27;k&#x27; */</span></span><br><span class="line">  <span class="type">int</span> sizecode;</span><br><span class="line">  <span class="type">int</span> sizelineinfo;</span><br><span class="line">  <span class="type">int</span> sizep;  <span class="comment">/* size of &#x27;p&#x27; */</span></span><br><span class="line">  <span class="type">int</span> sizelocvars;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> linedefined;  <span class="comment">// 开始行号</span></span><br><span class="line">  <span class="type">int</span> lastlinedefined;  <span class="comment">// 结束行号</span></span><br><span class="line">  TString  *source; <span class="comment">// 源文件名</span></span><br><span class="line"></span><br><span class="line">  TValue *k;  <span class="comment">// 常量表</span></span><br><span class="line">  Instruction *code;  <span class="comment">// 指令表</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Proto</span> **<span class="title">p</span>;</span>  <span class="comment">// 子函数原型表</span></span><br><span class="line">  <span class="type">int</span> *lineinfo;  <span class="comment">// 行号表 行号与指令对应</span></span><br><span class="line">  LocVar *locvars;  <span class="comment">// 局部变量表</span></span><br><span class="line">  Upvaldesc *upvalues;  <span class="comment">// Upvalue 表</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LClosure</span> *<span class="title">cache</span>;</span>  <span class="comment">/* last-created closure with this prototype */</span></span><br><span class="line">&#125; Proto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LClosure</span> &#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> nupvalues;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Proto</span> *<span class="title">p</span>;</span></span><br><span class="line">  UpVal *upvals[<span class="number">1</span>];  <span class="comment">/* list of upvalues */</span></span><br><span class="line">&#125; LClosure;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CClosure</span> &#123;</span></span><br><span class="line">  ClosureHeader;</span><br><span class="line">  lua_CFunction f;</span><br><span class="line">  TValue upvalue[<span class="number">1</span>];  <span class="comment">/* list of upvalues */</span></span><br><span class="line">&#125; CClosure;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">Closure</span> &#123;</span></span><br><span class="line">  CClosure c;</span><br><span class="line">  LClosure l;</span><br><span class="line">&#125; Closure;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>LoadFunction</code> 将填充 <code>Proto</code> ，要注意 Proto 是嵌套的，如果有多个函数的情况下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">LoadFunction</span> <span class="params">(LoadState *S, Proto *f, TString *psource)</span> &#123;</span><br><span class="line">  f-&gt;source = LoadString(S, f);</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;source == <span class="literal">NULL</span>)  <span class="comment">/* no source in dump? */</span></span><br><span class="line">    f-&gt;source = psource;  <span class="comment">/* reuse parent&#x27;s source */</span></span><br><span class="line">  f-&gt;linedefined = LoadInt(S);</span><br><span class="line">  f-&gt;lastlinedefined = LoadInt(S);</span><br><span class="line">  f-&gt;numparams = LoadByte(S);</span><br><span class="line">  f-&gt;is_vararg = LoadByte(S);</span><br><span class="line">  f-&gt;maxstacksize = LoadByte(S);</span><br><span class="line">  LoadCode(S, f);</span><br><span class="line">  LoadConstants(S, f);</span><br><span class="line">  LoadUpvalues(S, f);</span><br><span class="line">  LoadProtos(S, f);</span><br><span class="line">  LoadDebug(S, f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加载完了 <code>Chunk</code> ，目光回到 <code>f_parser</code> 其最后会调用 <code>luaF_initupvals</code> 初始化 upVals 就是置nil。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">luaF_initupvals</span> <span class="params">(lua_State *L, LClosure *cl)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cl-&gt;nupvalues; i++) &#123;</span><br><span class="line">    UpVal *uv = luaM_new(L, UpVal);</span><br><span class="line">    uv-&gt;refcount = <span class="number">1</span>;</span><br><span class="line">    uv-&gt;v = &amp;uv-&gt;u.value;  <span class="comment">/* make it closed */</span></span><br><span class="line">    setnilvalue(uv-&gt;v);</span><br><span class="line">    cl-&gt;upvals[i] = uv;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>Load 完之后，我们也能猜测到应当还有个 Call 方法，才能将加载进来的内容 跑起来。将 func读入到 CallInfo（可以理解为Lua解释器中的执行栈），会设置一下是不是可变参，有几个返回值等行为，最后调用 <code>luaV_execute</code> 去执行指令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">luaD_precall</span> <span class="params">(lua_State *L, StkId func, <span class="type">int</span> nresults)</span> &#123;</span><br><span class="line">  CallInfo *ci;</span><br><span class="line">  <span class="keyword">switch</span> (ttype(func)) &#123;</span><br><span class="line">		....</span><br><span class="line">    <span class="keyword">case</span> LUA_TLCL: &#123;  <span class="comment">/* Lua function: prepare its call */</span></span><br><span class="line">      StkId base;</span><br><span class="line">      Proto *p = clLvalue(func)-&gt;p;</span><br><span class="line">      <span class="type">int</span> n = cast_int(L-&gt;top - func) - <span class="number">1</span>;  <span class="comment">/* number of real arguments */</span></span><br><span class="line">      <span class="type">int</span> fsize = p-&gt;maxstacksize;  <span class="comment">/* frame size */</span></span><br><span class="line">      checkstackp(L, fsize, func);</span><br><span class="line">      <span class="keyword">if</span> (p-&gt;is_vararg)</span><br><span class="line">        base = adjust_varargs(L, p, n);</span><br><span class="line">      <span class="keyword">else</span> &#123;  <span class="comment">/* non vararg function */</span></span><br><span class="line">        <span class="keyword">for</span> (; n &lt; p-&gt;numparams; n++)</span><br><span class="line">          setnilvalue(L-&gt;top++);  <span class="comment">/* complete missing arguments */</span></span><br><span class="line">        base = func + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ci = next_ci(L);  <span class="comment">/* now &#x27;enter&#x27; new function */</span></span><br><span class="line">      ci-&gt;nresults = nresults;</span><br><span class="line">      ci-&gt;func = func;</span><br><span class="line">      ci-&gt;u.l.base = base;</span><br><span class="line">      L-&gt;top = ci-&gt;top = base + fsize;</span><br><span class="line">      ci-&gt;u.l.savedpc = p-&gt;code;  <span class="comment">/* starting point */</span></span><br><span class="line">      ci-&gt;callstatus = CIST_LUA;</span><br><span class="line">      <span class="keyword">if</span> (L-&gt;hookmask &amp; LUA_MASKCALL)</span><br><span class="line">        callhook(L, ci);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">luaD_call</span> <span class="params">(lua_State *L, StkId func, <span class="type">int</span> nResults)</span> &#123;</span><br><span class="line">	....</span><br><span class="line">  <span class="keyword">if</span> (!luaD_precall(L, func, nResults))  <span class="comment">/* is a Lua function? */</span></span><br><span class="line">    luaV_execute(L);  <span class="comment">/* call it */</span></span><br><span class="line">	....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>luaV_execute</code> 会将指令读入，然后去执行，Lua 的指令长度为32位，其中6位为指令，剩余位数为操作数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">luaV_execute</span> <span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">  CallInfo *ci = L-&gt;ci;</span><br><span class="line">  LClosure *cl;</span><br><span class="line">  TValue *k;</span><br><span class="line">  StkId base;</span><br><span class="line">  ci-&gt;callstatus |= CIST_FRESH;  <span class="comment">/* fresh invocation of &#x27;luaV_execute&quot; */</span></span><br><span class="line"> newframe:  <span class="comment">/* reentry point when frame changes (call/return) */</span></span><br><span class="line">  lua_assert(ci == L-&gt;ci);</span><br><span class="line">  cl = clLvalue(ci-&gt;func);  <span class="comment">/* local reference to function&#x27;s closure */</span></span><br><span class="line">  k = cl-&gt;p-&gt;k;  <span class="comment">/* local reference to function&#x27;s constant table */</span></span><br><span class="line">  base = ci-&gt;u.l.base;  <span class="comment">/* local copy of function&#x27;s base */</span></span><br><span class="line">  <span class="comment">/* main loop of interpreter */</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    Instruction i;</span><br><span class="line">    StkId ra;</span><br><span class="line">    vmfetch();</span><br><span class="line">    vmdispatch (GET_OPCODE(i)) &#123;</span><br><span class="line">			...</span><br><span class="line">      vmcase(OP_LOADNIL) &#123;</span><br><span class="line">        <span class="type">int</span> b = GETARG_B(i);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">          setnilvalue(ra++);</span><br><span class="line">        &#125; <span class="keyword">while</span> (b--);</span><br><span class="line">        vmbreak;</span><br><span class="line">      &#125;</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p><code>luaD_precall</code> 会将要执行的函数或称为闭包存放到 <code>CallInfo</code>，接着 <code>luaV_execute</code> 会调用 <code>vmfetch</code> 获取指令，savedpc 就是我们当前执行到的指令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> vmfetch()	&#123; \</span></span><br><span class="line"><span class="meta">  i = *(ci-&gt;u.l.savedpc++); \</span></span><br><span class="line"><span class="meta">	.... \</span></span><br><span class="line"><span class="meta">  ra = RA(i); <span class="comment">/* WARNING: any stack reallocation invalidates &#x27;ra&#x27; */</span> \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><p>在这里，有必要看看 <code>CallInfo</code> 的结构，因为执行的函数有可能是C函数和Lua函数，故源码用 union将其包起来，我们目前只在意 Lua 的部分，可以看到 savedpc 存的就是每一条指令，它的实际类型就是 <code>uint32</code> ，采用了定长指令，前六位为指令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CallInfo</span> &#123;</span></span><br><span class="line">  StkId func;  <span class="comment">/* function index in the stack */</span></span><br><span class="line">  StkId	top;  <span class="comment">/* top for this function */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">CallInfo</span> *<span class="title">previous</span>, *<span class="title">next</span>;</span>  <span class="comment">/* dynamic call link */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span>  <span class="comment">/* only for Lua functions */</span></span><br><span class="line">      StkId base;  <span class="comment">/* base for this function */</span></span><br><span class="line">      <span class="type">const</span> Instruction *savedpc;</span><br><span class="line">    &#125; l;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span>  <span class="comment">/* only for C functions */</span></span><br><span class="line">      lua_KFunction k;  <span class="comment">/* continuation in case of yields */</span></span><br><span class="line">      <span class="type">ptrdiff_t</span> old_errfunc;</span><br><span class="line">      lua_KContext ctx;  <span class="comment">/* context info. in case of yields */</span></span><br><span class="line">    &#125; c;</span><br><span class="line">  &#125; u;</span><br><span class="line">  <span class="type">ptrdiff_t</span> extra;</span><br><span class="line">  <span class="type">short</span> nresults;  <span class="comment">/* expected number of results from this function */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> callstatus;</span><br><span class="line">&#125; CallInfo;</span><br></pre></td></tr></table></figure><p>就这样，Lua解释器从加载 Chunk 到执行 Chunk 的流程走完了。</p><p>但仅如此还不够，我们可以看到以上大部分函数，都以 <code>lua_state</code> 作为参数，因此我们还需要先实例化 <code>lua_state</code> ，不过在此之前，我们要先简单认识一下 <code>lua_state</code> 的结构定义。</p><h2 id="lua-State"><a href="#lua-State" class="headerlink" title="lua_State"></a>lua_State</h2><p>去除掉大量的无关信息，一个 Lua 解释器，仅需要以下几项即可运作。分别是栈的信息（如果你有Lua经验，想必早已知道Lua是通过栈模拟寄存器），调用栈信息即 <code>CallInfo</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lua_State</span> &#123;</span></span><br><span class="line">	....</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> nci;  <span class="comment">/* number of items in &#x27;ci&#x27; list */</span></span><br><span class="line">  StkId top;  <span class="comment">/* first free slot in the stack */</span></span><br><span class="line">	....</span><br><span class="line">  CallInfo *ci;  <span class="comment">/* call info for current function */</span></span><br><span class="line">  StkId stack_last;  <span class="comment">/* last free slot in the stack */</span></span><br><span class="line">  StkId <span class="built_in">stack</span>;  <span class="comment">/* stack base */</span></span><br><span class="line">	....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="lua-newstate"><a href="#lua-newstate" class="headerlink" title="lua_newstate"></a>lua_newstate</h3><p>简单地初始化 lua_State，在这里我将无关的内容给删除了，可以看到初始化后会调用 <code>f_luaopen</code> 函数去打开Lua基础库。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LUA_API lua_State *<span class="title function_">lua_newstate</span> <span class="params">(lua_Alloc f, <span class="type">void</span> *ud)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  lua_State *L;</span><br><span class="line">  LG *l = cast(LG *, (*f)(ud, <span class="literal">NULL</span>, LUA_TTHREAD, <span class="keyword">sizeof</span>(LG)));</span><br><span class="line">  <span class="keyword">if</span> (l == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  L = &amp;l-&gt;l.l;</span><br><span class="line">	....</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; LUA_NUMTAGS; i++) g-&gt;mt[i] = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">if</span> (luaD_rawrunprotected(L, f_luaopen, <span class="literal">NULL</span>) != LUA_OK) &#123;</span><br><span class="line">    <span class="comment">/* memory allocation error: free partial state */</span></span><br><span class="line">    close_state(L);</span><br><span class="line">    L = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>stack_init</code> 初始化栈和初始化调用栈即 <code>CallInfo</code>， <code>init_registry</code> 初始化注册表，往后的全局对象，还有一些C函数都会注册到这里面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">f_luaopen</span> <span class="params">(lua_State *L, <span class="type">void</span> *ud)</span> &#123;</span><br><span class="line">  stack_init(L, L);  <span class="comment">/* init stack */</span></span><br><span class="line">  init_registry(L, g);</span><br><span class="line">  luaS_init(L); <span class="comment">// 初始化用于复用的字符串，当字符串相等的时候能复用就复用</span></span><br><span class="line">	....</span><br><span class="line">  luaX_init(L); <span class="comment">// 关键字 字符串提前注册并设置不能GC</span></span><br><span class="line">	....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>经过以上的洗礼，可以看到 Lua 在加载 Chunk的时候，要先创建好Lua解释器，然后通过指定格式Load进内存，再调用 precall 预处理，最后将一条条的指令执行。</p><p>其实之前看Lua源码的时候感觉很复杂，特别难看懂，特别是C语言的通病各种宏，看一下后面的，过一阵又忘了宏里面写的是什么。这次则采用一种新的方式来阅读，即先想想如果是你来做这个功能，你会怎么做？想到的方法不会相差太多，这个时候顺着自己的思路来寻觅作者的思路，会简单的多。</p></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Lua/" rel="tag"># Lua</a> <a href="/tags/Lua%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="tag"># Lua虚拟机</a></div><div class="post-nav"><div class="post-nav-item"><a href="/SkipList-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%9C%A8%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/" rel="prev" title="SkipList 原理及在游戏排行榜中的应用"><i class="fa fa-angle-left"></i> SkipList 原理及在游戏排行榜中的应用</a></div><div class="post-nav-item"><a href="/Lua5.3-%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0(%E4%BA%8C)-Table%E4%B8%8EMetatable/" rel="next" title="Lua 5.3 设计实现(二) Table与Metatable">Lua 5.3 设计实现(二) Table与Metatable <i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Yuerer</span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://unpkg.com/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://unpkg.com/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/comments.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/utils.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/motion.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/sidebar.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/next-boot.min.js"></script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://yuerer-comment-xufei-0bea01e6f05-1307930306.ap-shanghai.app.tcloudbase.com","cssUrl":"https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.css","commentCount":true,"pageview":true,"libUrl":"https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.js","locale":{"placeholder":"有何高见？"},"emoji":["https://unpkg.com/@waline/emojis@1.0.1/qq"],"meta":["nick","mail"],"requiredMeta":[["nick","mail"]],"wordLimit":0,"login":"disable","pageSize":10,"el":"#waline","comment":true,"path":"/Lua5.3-%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0(%E4%B8%80)-Lua%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/"}</script><link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.css"><script>document.addEventListener("page:loaded",()=>{NexT.utils.loadComments(CONFIG.waline.el).then(()=>NexT.utils.getScript(CONFIG.waline.libUrl,{condition:window.Waline})).then(()=>Waline.init(Object.assign({},CONFIG.waline,{el:document.querySelector(CONFIG.waline.el)})))})</script></body></html>