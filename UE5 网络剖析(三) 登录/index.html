<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.jpeg"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.ico"><link rel="mask-icon" href="/images/avatar.jpeg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous"><link rel="stylesheet" href="https://unpkg.com/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"yuerer.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"hide","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":true,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/config.min.js"></script><meta name="description" content="本文剖析 UE5 客户端与DS建立连接后的登录流程，以及 Bunch 的发送接收，这样之后看属性同步时，能轻松一些。 登录流程书接上回，握手之后会执行 UPendingNetGame::SendInitialJoin 。 1234567891011121314void UPendingNetGame::BeginHandshake()&#123;    &#x2F;&#x2F; Kick off the connec"><meta property="og:type" content="article"><meta property="og:title" content="UE5 网络剖析(三) 登录"><meta property="og:url" content="https://yuerer.com/UE5%20%E7%BD%91%E7%BB%9C%E5%89%96%E6%9E%90(%E4%B8%89)%20%E7%99%BB%E5%BD%95/index.html"><meta property="og:site_name" content="Yuerer&#39;s Blog"><meta property="og:description" content="本文剖析 UE5 客户端与DS建立连接后的登录流程，以及 Bunch 的发送接收，这样之后看属性同步时，能轻松一些。 登录流程书接上回，握手之后会执行 UPendingNetGame::SendInitialJoin 。 1234567891011121314void UPendingNetGame::BeginHandshake()&#123;    &#x2F;&#x2F; Kick off the connec"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2024-11-30T02:19:20.000Z"><meta property="article:modified_time" content="2025-10-21T13:50:52.263Z"><meta property="article:author" content="Yuerer"><meta property="article:tag" content="UE5"><meta property="article:tag" content="网络"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://yuerer.com/UE5%20%E7%BD%91%E7%BB%9C%E5%89%96%E6%9E%90(%E4%B8%89)%20%E7%99%BB%E5%BD%95/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://yuerer.com/UE5%20%E7%BD%91%E7%BB%9C%E5%89%96%E6%9E%90(%E4%B8%89)%20%E7%99%BB%E5%BD%95/","path":"UE5 网络剖析(三) 登录/","title":"UE5 网络剖析(三) 登录"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>UE5 网络剖析(三) 登录 | Yuerer's Blog</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-129491388-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-129491388-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/third-party/analytics/google-analytics.min.js"></script><link rel="dns-prefetch" href="https://yuerer-comment-xufei-0bea01e6f05-1307930306.ap-shanghai.app.tcloudbase.com"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Yuerer's Blog</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">钰儿的Blog</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B"><span class="nav-text">登录流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#NMT-Hello"><span class="nav-text">NMT_Hello</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NMT-Challenge"><span class="nav-text">NMT_Challenge</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NMT-Login"><span class="nav-text">NMT_Login</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NMT-Welcome"><span class="nav-text">NMT_Welcome</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NMT-Netspeed"><span class="nav-text">NMT_Netspeed</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NMT-Join"><span class="nav-text">NMT_Join</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%99%BB%E5%BD%95%E6%80%BB%E7%BB%93"><span class="nav-text">登录总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bunch"><span class="nav-text">Bunch</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Channel"><span class="nav-text">Channel</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Channel-SendBunch"><span class="nav-text">Channel::SendBunch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ReceivedBunch"><span class="nav-text">ReceivedBunch</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Yuerer" src="/images/avatar.jpeg"><p class="site-author-name" itemprop="name">Yuerer</p><div class="site-description" itemprop="description">钰儿的Blog</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">65</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">16</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">90</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/Yu2erer" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Yu2erer" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:yu2erer#gmail.com" title="E-Mail → mailto:yu2erer#gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://yuerer.com/UE5%20%E7%BD%91%E7%BB%9C%E5%89%96%E6%9E%90(%E4%B8%89)%20%E7%99%BB%E5%BD%95/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpeg"><meta itemprop="name" content="Yuerer"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Yuerer's Blog"><meta itemprop="description" content="钰儿的Blog"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="UE5 网络剖析(三) 登录 | Yuerer's Blog"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">UE5 网络剖析(三) 登录</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2024-11-30 10:19:20" itemprop="dateCreated datePublished" datetime="2024-11-30T10:19:20+08:00">2024-11-30</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UE/" itemprop="url" rel="index"><span itemprop="name">UE</span></a> </span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Waline：</span> <a title="waline" href="/UE5%20%E7%BD%91%E7%BB%9C%E5%89%96%E6%9E%90(%E4%B8%89)%20%E7%99%BB%E5%BD%95/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/UE5%20%E7%BD%91%E7%BB%9C%E5%89%96%E6%9E%90(%E4%B8%89)%20%E7%99%BB%E5%BD%95/" itemprop="commentCount"></span> </a></span><span class="post-meta-item" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="waline-pageview-count" data-path="/UE5%20%E7%BD%91%E7%BB%9C%E5%89%96%E6%9E%90(%E4%B8%89)%20%E7%99%BB%E5%BD%95/"></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>本文剖析 UE5 客户端与DS建立连接后的登录流程，以及 <code>Bunch</code> 的发送接收，这样之后看属性同步时，能轻松一些。</p><h2 id="登录流程"><a href="#登录流程" class="headerlink" title="登录流程"></a>登录流程</h2><p>书接上回，握手之后会执行 <code>UPendingNetGame::SendInitialJoin</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UPendingNetGame::BeginHandshake</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Kick off the connection handshake</span></span><br><span class="line">    UNetConnection* ServerConn = NetDriver-&gt;ServerConnection;</span><br><span class="line">    <span class="keyword">if</span> (ServerConn-&gt;Handler.<span class="built_in">IsValid</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        ServerConn-&gt;Handler-&gt;<span class="built_in">BeginHandshaking</span>(</span><br><span class="line">            FPacketHandlerHandshakeComplete::<span class="built_in">CreateUObject</span>(<span class="keyword">this</span>, &amp;UPendingNetGame::SendInitialJoin));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">SendInitialJoin</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在继续分析之前，先来看官方的注释，描述了登录的流程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Most of the work <span class="keyword">for</span> handling these control messages are done either in UWorld::NotifyControlMessage,</span><br><span class="line"><span class="keyword">and</span> UPendingNetGame::NotifyControlMessage. Briefly, the flow looks like <span class="keyword">this</span>:</span><br><span class="line"></span><br><span class="line">Client<span class="string">&#x27;s UPendingNetGame::SendInitialJoin sends NMT_Hello.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Server&#x27;</span>s UWorld::NotifyControlMessage receives NMT_Hello, sends NMT_Challenge.</span><br><span class="line"></span><br><span class="line">Client<span class="string">&#x27;s UPendingNetGame::NotifyControlMessage receives NMT_Challenge, and sends back data in NMT_Login.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Server&#x27;</span>s UWorld::NotifyControlMessage receives NMT_Login, verifies challenge data, <span class="keyword">and</span> then calls AGameModeBase::PreLogin.</span><br><span class="line">If PreLogin doesn<span class="string">&#x27;t report any errors, Server calls UWorld::WelcomePlayer, which call AGameModeBase::GameWelcomePlayer,</span></span><br><span class="line"><span class="string">and send NMT_Welcome with map information.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Client&#x27;</span>s UPendingNetGame::NotifyControlMessage receives NMT_Welcome, <span class="function">reads the map <span class="title">info</span> <span class="params">(so it can start loading later)</span>,</span></span><br><span class="line"><span class="function"><span class="keyword">and</span> sends an NMT_NetSpeed message with the configured Net Speed of the client.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Server&#x27;s UWorld::NotifyControlMessage receives NMT_NetSpeed, <span class="keyword">and</span> adjusts the connections Net Speed appropriately.</span></span><br></pre></td></tr></table></figure><span id="more"></span><p>简单来说就是服务端接收到 ControlMessage 是在 <code>UWorld::NotifyControlMessage</code> 而客户端接收则在 <code>UPendingNetGame::NotifyControlMessage</code> 二者都是在 <code>UNetDriver::InitBase(bool bInitAsClient, FNetworkNotify* InNotify, const FURL&amp; URL, bool bReuseAddressAndPort, FString&amp; Error)</code> 中被设置的。当客户端登录成功后，就会将 <code>UPendingNetGame</code> 的功能转移回 <code>UWorld</code> 中。</p><p>最简登录只需要 <code>NMT_Hello</code> <code>NMT_Challenge</code> <code>NMT_Login</code> <code>NMT_Welcome</code> <code>NMT_NetSpeed</code> 这几条命令。</p><p>Control 命令定义在 <code>DataChannel.h</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// message type definitions</span></span><br><span class="line"><span class="built_in">DEFINE_CONTROL_CHANNEL_MESSAGE</span>(Hello, <span class="number">0</span>, uint8, uint32, FString, uint16); <span class="comment">// initial client connection message</span></span><br><span class="line"><span class="built_in">DEFINE_CONTROL_CHANNEL_MESSAGE</span>(Welcome, <span class="number">1</span>, FString, FString, FString); <span class="comment">// server tells client they&#x27;re ok&#x27;ed to load the server&#x27;s level</span></span><br><span class="line"><span class="built_in">DEFINE_CONTROL_CHANNEL_MESSAGE</span>(Upgrade, <span class="number">2</span>, uint32, uint16); <span class="comment">// server tells client their version is incompatible</span></span><br><span class="line"><span class="built_in">DEFINE_CONTROL_CHANNEL_MESSAGE</span>(Challenge, <span class="number">3</span>, FString); <span class="comment">// server sends client challenge string to verify integrity</span></span><br><span class="line"><span class="built_in">DEFINE_CONTROL_CHANNEL_MESSAGE</span>(Netspeed, <span class="number">4</span>, int32); <span class="comment">// client sends requested transfer rate</span></span><br><span class="line"><span class="built_in">DEFINE_CONTROL_CHANNEL_MESSAGE</span>(Login, <span class="number">5</span>, FString, FString, FUniqueNetIdRepl, FString); <span class="comment">// client requests to be admitted to the game</span></span><br><span class="line"><span class="built_in">DEFINE_CONTROL_CHANNEL_MESSAGE</span>(Failure, <span class="number">6</span>, FString); <span class="comment">// indicates connection failure</span></span><br><span class="line"><span class="built_in">DEFINE_CONTROL_CHANNEL_MESSAGE</span>(Join, <span class="number">9</span>); <span class="comment">// final join request (spawns PlayerController)</span></span><br><span class="line"><span class="built_in">DEFINE_CONTROL_CHANNEL_MESSAGE</span>(JoinSplit, <span class="number">10</span>, FString, FUniqueNetIdRepl); <span class="comment">// child player (splitscreen) join request</span></span><br><span class="line"><span class="built_in">DEFINE_CONTROL_CHANNEL_MESSAGE</span>(Skip, <span class="number">12</span>, FGuid); <span class="comment">// client request to skip an optional package</span></span><br><span class="line"><span class="built_in">DEFINE_CONTROL_CHANNEL_MESSAGE</span>(Abort, <span class="number">13</span>, FGuid); <span class="comment">// client informs server that it aborted a not-yet-verified package due to an UNLOAD request</span></span><br><span class="line"><span class="built_in">DEFINE_CONTROL_CHANNEL_MESSAGE</span>(PCSwap, <span class="number">15</span>, int32); <span class="comment">// client tells server it has completed a swap of its Connection-&gt;Actor</span></span><br><span class="line"><span class="built_in">DEFINE_CONTROL_CHANNEL_MESSAGE</span>(ActorChannelFailure, <span class="number">16</span>, int32); <span class="comment">// client tells server that it failed to open an Actor channel sent by the server (e.g. couldn&#x27;t serialize Actor archetype)</span></span><br><span class="line"><span class="built_in">DEFINE_CONTROL_CHANNEL_MESSAGE</span>(DebugText, <span class="number">17</span>, FString); <span class="comment">// debug text sent to all clients or to server</span></span><br><span class="line"><span class="built_in">DEFINE_CONTROL_CHANNEL_MESSAGE</span>(NetGUIDAssign, <span class="number">18</span>, FNetworkGUID, FString); <span class="comment">// Explicit NetworkGUID assignment. This is rare and only happens if a netguid is only serialized client-&gt;server (this msg goes server-&gt;client to tell client what ID to use in that case)</span></span><br><span class="line"><span class="built_in">DEFINE_CONTROL_CHANNEL_MESSAGE</span>(SecurityViolation, <span class="number">19</span>, FString); <span class="comment">// server tells client that it has violated security and has been disconnected</span></span><br><span class="line"><span class="built_in">DEFINE_CONTROL_CHANNEL_MESSAGE</span>(GameSpecific, <span class="number">20</span>, uint8, FString); <span class="comment">// custom game-specific message routed to UGameInstance for processing</span></span><br><span class="line"><span class="built_in">DEFINE_CONTROL_CHANNEL_MESSAGE</span>(EncryptionAck, <span class="number">21</span>);</span><br><span class="line"><span class="built_in">DEFINE_CONTROL_CHANNEL_MESSAGE</span>(DestructionInfo, <span class="number">22</span>);</span><br><span class="line"><span class="built_in">DEFINE_CONTROL_CHANNEL_MESSAGE</span>(CloseReason, <span class="number">23</span>, FString); <span class="comment">// Reason for client NetConnection Close, for analytics/logging</span></span><br><span class="line"><span class="built_in">DEFINE_CONTROL_CHANNEL_MESSAGE</span>(NetPing, <span class="number">24</span>, ENetPingControlMessage <span class="comment">/* MessageType */</span>, FString <span class="comment">/* MessageStr */</span>);</span><br></pre></td></tr></table></figure><p>将宏展开可得，其实发送就是创建一个 <code>Bunch</code> 然后通过 Channel[0] 也就是 ControlChannel 将数据发送出去，这个 Channel 的创建可以从网络剖析第二篇文章中找到，关于 Bunch 的组织结构以及如何发送出去，会在下面分析，这里先跳过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123; NMT_Hello = <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FNetControlMessage</span>&lt;<span class="number">0</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> uint8 <span class="title">Initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        FNetControlMessageInfo::<span class="built_in">SetName</span>(<span class="number">0</span>, <span class="string">L&quot;Hello&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... ParamTypes&gt;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Send</span><span class="params">(UNetConnection* Conn, ParamTypes&amp;... Params)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">static_assert</span>(<span class="number">0</span> &lt; FNetControlMessageInfo::MaxNames, <span class="string">&quot;Control channel message must be a byte.&quot;</span>);</span><br><span class="line">        &#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> (Conn-&gt;Channels[<span class="number">0</span>] != <span class="number">0</span> &amp;&amp; !Conn-&gt;Channels[<span class="number">0</span>]-&gt;Closing)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">FControlChannelOutBunch <span class="title">Bunch</span><span class="params">(Conn-&gt;Channels[<span class="number">0</span>], <span class="literal">false</span>)</span></span>;</span><br><span class="line">            uint8 MessageType = <span class="number">0</span>;</span><br><span class="line">            Bunch &lt;&lt; MessageType;</span><br><span class="line">            FNetControlMessageInfo::<span class="built_in">SendParams</span>(Bunch, Params...);</span><br><span class="line">            Conn-&gt;Channels[<span class="number">0</span>]-&gt;<span class="built_in">SendBunch</span>(&amp;Bunch, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... ParamTypes&gt;</span><br><span class="line">    [[nodiscard]] <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">Receive</span><span class="params">(FInBunch&amp; Bunch, ParamTypes&amp;... Params)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        FNetControlMessageInfo::<span class="built_in">ReceiveParams</span>(Bunch, Params...);</span><br><span class="line">        <span class="keyword">return</span> !Bunch.<span class="built_in">IsError</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Discard</span><span class="params">(FInBunch&amp; Bunch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TTuple&lt;uint8, uint32, FString, uint16&gt; Params;</span><br><span class="line">        <span class="built_in">VisitTupleElements</span>([&amp;Bunch](<span class="keyword">auto</span>&amp; Param) &#123; Bunch &lt;&lt; Param; &#125;, Params);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>FControlChannelOutBunch</code> 默认为 Reliable，若丢包会自动重传，这点在网络剖析第一篇讲过了，可不可靠是跟随 <code>Bunch</code> 的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FControlChannelOutBunch::<span class="built_in">FControlChannelOutBunch</span>(UChannel* InChannel, <span class="type">bool</span> bClose)</span><br><span class="line">	: <span class="built_in">FOutBunch</span>(InChannel, bClose)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">checkSlow</span>(<span class="built_in">Cast</span>&lt;UControlChannel&gt;(InChannel) != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// control channel bunches contain critical handshaking/synchronization and should always be reliable</span></span><br><span class="line">    bReliable = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>DataChannel.h</code> 下方，还有 <code>Beacon</code> 的命令，这是一个插件，用于客户端还未正式建立连接时，能够执行 <code>RPC</code> ，本质原理是为客户端先创建一个同步的 <code>Actor</code> ，方便客户端在还未正式连入时，通过 <code>RPC</code> 处理一些业务逻辑，比如预排队，但这里不是重点，跳过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DEFINE_CONTROL_CHANNEL_MESSAGE</span>(BeaconWelcome, <span class="number">25</span>); <span class="comment">// server tells client they&#x27;re ok to attempt to join (client sends netspeed/beacontype)</span></span><br><span class="line">....</span><br></pre></td></tr></table></figure><h3 id="NMT-Hello"><a href="#NMT-Hello" class="headerlink" title="NMT_Hello"></a>NMT_Hello</h3><p>告知DS，客户端是否为小端架构、本地网络版本和验证 <code>Token</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UPendingNetGame::SendInitialJoin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FNetControlMessage&lt;NMT_Hello&gt;::<span class="built_in">Send</span>(ServerConn, IsLittleEndian, LocalNetworkVersion, EncryptionToken, LocalNetworkFeatures);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NMT-Challenge"><a href="#NMT-Challenge" class="headerlink" title="NMT_Challenge"></a>NMT_Challenge</h3><p>服务端收到之后，会尝试对 Token 进行校验， <code>OnReceivedNetworkEncryptionToken</code> Delegate 默认在 GameInstance 中绑定，因此若需要自定义 Token 校验逻辑，可继承 <code>GameInstance::ReceivedNetworkEncryptionToken</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UWorld::NotifyControlMessage</span><span class="params">(UNetConnection* Connection, uint8 MessageType, <span class="keyword">class</span> FInBunch&amp; Bunch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">case</span> NMT_Hello:</span><br><span class="line">    &#123;</span><br><span class="line">        uint8 IsLittleEndian = <span class="number">0</span>;</span><br><span class="line">        uint32 RemoteNetworkVersion = <span class="number">0</span>;</span><br><span class="line">        uint32 LocalNetworkVersion = FNetworkVersion::<span class="built_in">GetLocalNetworkVersion</span>();</span><br><span class="line">        FString EncryptionToken;</span><br><span class="line"></span><br><span class="line">        EEngineNetworkRuntimeFeatures LocalNetworkFeatures = NetDriver-&gt;<span class="built_in">GetNetworkRuntimeFeatures</span>();</span><br><span class="line">        EEngineNetworkRuntimeFeatures RemoteNetworkFeatures = EEngineNetworkRuntimeFeatures::None;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FNetControlMessage&lt;NMT_Hello&gt;::<span class="built_in">Receive</span>(Bunch, IsLittleEndian, RemoteNetworkVersion, EncryptionToken, RemoteNetworkFeatures))</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (FNetDelegates::OnReceivedNetworkEncryptionToken.<span class="built_in">IsBound</span>())</span><br><span class="line">                    &#123;</span><br><span class="line">                        FNetDelegates::OnReceivedNetworkEncryptionToken.<span class="built_in">Execute</span>(EncryptionToken,</span><br><span class="line">                            FOnEncryptionKeyResponse::<span class="built_in">CreateUObject</span>(Connection, &amp;UNetConnection::SendChallengeControlMessage));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端收到 NMT_Challenge 后，拼凑 URL 告知服务端自己的别名，以及ID。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UPendingNetGame::NotifyControlMessage</span><span class="params">(UNetConnection* Connection, uint8 MessageType, <span class="keyword">class</span> FInBunch&amp; Bunch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">case</span> NMT_Challenge:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Challenged by server.</span></span><br><span class="line">        <span class="keyword">if</span> (FNetControlMessage&lt;NMT_Challenge&gt;::<span class="built_in">Receive</span>(Bunch, Connection-&gt;Challenge))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">FURL <span class="title">PartialURL</span><span class="params">(URL)</span></span>;</span><br><span class="line">            PartialURL.Host = <span class="built_in">TEXT</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            PartialURL.Port = PartialURL.UrlConfig.DefaultPort; <span class="comment">// <span class="doctag">HACK:</span> Need to fix URL parsing </span></span><br><span class="line">            PartialURL.Map = <span class="built_in">TEXT</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (int32 i = URL.Op.<span class="built_in">Num</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (URL.Op[i].<span class="built_in">Left</span>(<span class="number">5</span>) == <span class="built_in">TEXT</span>(<span class="string">&quot;game=&quot;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    URL.Op.<span class="built_in">RemoveAt</span>(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ULocalPlayer* LocalPlayer = GEngine-&gt;<span class="built_in">GetFirstGamePlayer</span>(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (LocalPlayer)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Send the player nickname if available</span></span><br><span class="line">                FString OverrideName = LocalPlayer-&gt;<span class="built_in">GetNickname</span>();</span><br><span class="line">                <span class="keyword">if</span> (OverrideName.<span class="built_in">Len</span>() &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    PartialURL.<span class="built_in">AddOption</span>(*FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Name=%s&quot;</span>), *OverrideName));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Send any game-specific url options for this player</span></span><br><span class="line">                FString GameUrlOptions = LocalPlayer-&gt;<span class="built_in">GetGameLoginOptions</span>();</span><br><span class="line">                <span class="keyword">if</span> (GameUrlOptions.<span class="built_in">Len</span>() &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    PartialURL.<span class="built_in">AddOption</span>(*FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;%s&quot;</span>), *GameUrlOptions));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Send the player unique Id at login</span></span><br><span class="line">                Connection-&gt;PlayerId = LocalPlayer-&gt;<span class="built_in">GetPreferredUniqueNetId</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Send the player&#x27;s online platform name</span></span><br><span class="line">            FName OnlinePlatformName = NAME_None;</span><br><span class="line">            <span class="keyword">if</span> (<span class="type">const</span> FWorldContext* <span class="type">const</span> WorldContext = GEngine-&gt;<span class="built_in">GetWorldContextFromPendingNetGame</span>(<span class="keyword">this</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (WorldContext-&gt;OwningGameInstance)</span><br><span class="line">                &#123;</span><br><span class="line">                    OnlinePlatformName = WorldContext-&gt;OwningGameInstance-&gt;<span class="built_in">GetOnlinePlatformName</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Connection-&gt;ClientResponse = <span class="built_in">TEXT</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            <span class="function">FString <span class="title">URLString</span><span class="params">(PartialURL.ToString())</span></span>;</span><br><span class="line">            FString OnlinePlatformNameString = OnlinePlatformName.<span class="built_in">ToString</span>();</span><br><span class="line"></span><br><span class="line">            FNetControlMessage&lt;NMT_Login&gt;::<span class="built_in">Send</span>(Connection, Connection-&gt;ClientResponse, URLString, Connection-&gt;PlayerId, OnlinePlatformNameString);</span><br><span class="line">            NetDriver-&gt;ServerConnection-&gt;<span class="built_in">FlushNet</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NMT-Login"><a href="#NMT-Login" class="headerlink" title="NMT_Login"></a>NMT_Login</h3><p>服务端收到客户端的 <code>NMT_Login</code> 后就拥有玩家的ID，此时进入 <code>void AGameModeBase::PreLogin</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UWorld::NotifyControlMessage</span><span class="params">(UNetConnection* Connection, uint8 MessageType, <span class="keyword">class</span> FInBunch&amp; Bunch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">case</span> NMT_Login:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Admit or deny the player here.</span></span><br><span class="line">        FUniqueNetIdRepl UniqueIdRepl;</span><br><span class="line">        FString OnlinePlatformName;</span><br><span class="line">        FString&amp; RequestURL = Connection-&gt;RequestURL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Expand the maximum string serialization size, to accommodate extremely large Fortnite join URL&#x27;s.</span></span><br><span class="line">        Bunch.ArMaxSerializeSize += (<span class="number">16</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> bReceived = FNetControlMessage&lt;NMT_Login&gt;::<span class="built_in">Receive</span>(Bunch, Connection-&gt;ClientResponse, RequestURL, UniqueIdRepl,</span><br><span class="line">                                                                OnlinePlatformName);</span><br><span class="line"></span><br><span class="line">        Bunch.ArMaxSerializeSize -= (<span class="number">16</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bReceived)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Only the options/portal for the URL should be used during join</span></span><br><span class="line">            <span class="type">const</span> TCHAR* NewRequestURL = *RequestURL;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (; *NewRequestURL != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; *NewRequestURL != <span class="string">&#x27;?&#x27;</span> &amp;&amp; *NewRequestURL != <span class="string">&#x27;#&#x27;</span>; NewRequestURL++)&#123;&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Compromise for passing splitscreen playercount through to gameplay login code,</span></span><br><span class="line">            <span class="comment">// without adding a lot of extra unnecessary complexity throughout the login code.</span></span><br><span class="line">            <span class="comment">// <span class="doctag">NOTE:</span> This code differs from NMT_JoinSplit, by counting + 1 for SplitscreenCount</span></span><br><span class="line">            <span class="comment">//			(since this is the primary connection, not counted in Children)</span></span><br><span class="line">            <span class="function">FURL <span class="title">InURL</span><span class="params">( <span class="literal">NULL</span>, NewRequestURL, TRAVEL_Absolute )</span></span>;</span><br><span class="line"></span><br><span class="line">            RequestURL = InURL.<span class="built_in">ToString</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// skip to the first option in the URL</span></span><br><span class="line">            <span class="type">const</span> TCHAR* Tmp = *RequestURL;</span><br><span class="line">            <span class="keyword">for</span> (; *Tmp &amp;&amp; *Tmp != <span class="string">&#x27;?&#x27;</span>; Tmp++);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// keep track of net id for player associated with remote connection</span></span><br><span class="line">            Connection-&gt;PlayerId = UniqueIdRepl;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// keep track of the online platform the player associated with this connection is using.</span></span><br><span class="line">            Connection-&gt;<span class="built_in">SetPlayerOnlinePlatformName</span>(<span class="built_in">FName</span>(*OnlinePlatformName));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ask the game code if this player can join</span></span><br><span class="line">            AGameModeBase* GameMode = <span class="built_in">GetAuthGameMode</span>();</span><br><span class="line">            AGameModeBase::FOnPreLoginCompleteDelegate OnComplete = AGameModeBase::FOnPreLoginCompleteDelegate::<span class="built_in">CreateUObject</span>(</span><br><span class="line">                <span class="keyword">this</span>, &amp;UWorld::PreLoginComplete, <span class="built_in">TWeakObjectPtr</span>&lt;UNetConnection&gt;(Connection));</span><br><span class="line">            <span class="keyword">if</span> (GameMode)</span><br><span class="line">            &#123;</span><br><span class="line">                GameMode-&gt;<span class="built_in">PreLoginAsync</span>(Tmp, Connection-&gt;<span class="built_in">LowLevelGetRemoteAddress</span>(), Connection-&gt;PlayerId, OnComplete);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                OnComplete.<span class="built_in">ExecuteIfBound</span>(<span class="built_in">FString</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AGameModeBase::PreLogin</span><span class="params">(<span class="type">const</span> FString&amp; Options, <span class="type">const</span> FString&amp; Address, <span class="type">const</span> FUniqueNetIdRepl&amp; UniqueId, FString&amp; ErrorMessage)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Login unique id must match server expected unique id type OR No unique id could mean game doesn&#x27;t use them</span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> bUniqueIdCheckOk = (!UniqueId.<span class="built_in">IsValid</span>() || UOnlineEngineInterface::<span class="built_in">Get</span>()-&gt;<span class="built_in">IsCompatibleUniqueNetId</span>(UniqueId));</span><br><span class="line">    <span class="keyword">if</span> (bUniqueIdCheckOk)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrorMessage = GameSession-&gt;<span class="built_in">ApproveLogin</span>(Options);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ErrorMessage = <span class="built_in">TEXT</span>(<span class="string">&quot;incompatible_unique_net_id&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FGameModeEvents::GameModePreLoginEvent.<span class="built_in">Broadcast</span>(<span class="keyword">this</span>, UniqueId, ErrorMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GameSession-&gt;ApproveLogin</code> 中会校验是否用满员，有需要的话，可以重写 <code>bool AGameSession::AtCapacity(bool bSpectator)</code> 自定义是否满员逻辑，默认最多16人，不算观战者。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FString <span class="title">AGameSession::ApproveLogin</span><span class="params">(<span class="type">const</span> FString&amp; Options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UWorld* <span class="type">const</span> World = <span class="built_in">GetWorld</span>();</span><br><span class="line">    AGameModeBase* <span class="type">const</span> GameMode = World-&gt;<span class="built_in">GetAuthGameMode</span>();</span><br><span class="line"></span><br><span class="line">    int32 SpectatorOnly = <span class="number">0</span>;</span><br><span class="line">    SpectatorOnly = UGameplayStatics::<span class="built_in">GetIntOption</span>(Options, <span class="built_in">TEXT</span>(<span class="string">&quot;SpectatorOnly&quot;</span>), SpectatorOnly);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">AtCapacity</span>(SpectatorOnly == <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">TEXT</span>( <span class="string">&quot;Server full.&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int32 SplitscreenCount = <span class="number">0</span>;</span><br><span class="line">    SplitscreenCount = UGameplayStatics::<span class="built_in">GetIntOption</span>(Options, <span class="built_in">TEXT</span>(<span class="string">&quot;SplitscreenCount&quot;</span>), SplitscreenCount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SplitscreenCount &gt; MaxSplitscreensPerConnection)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">UE_LOG</span>(LogGameSession, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;ApproveLogin: A maximum of %i splitscreen players are allowed&quot;</span>), MaxSplitscreensPerConnection);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">TEXT</span>(<span class="string">&quot;Maximum splitscreen players&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">TEXT</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>失败则发送 <code>NMT_Failure</code> ，否则 <code>WelcomePlayer()</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UWorld::PreLoginComplete</span><span class="params">(<span class="type">const</span> FString&amp; ErrorMsg, TWeakObjectPtr&lt;UNetConnection&gt; WeakConnection)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UNetConnection* Connection = WeakConnection.<span class="built_in">Get</span>();</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">PreLoginCheckError</span>(Connection, ErrorMsg))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">WelcomePlayer</span>(Connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端有机会通过 <code>GameInstance::ModifyClientTravelLevelURL</code> 来修改 LevelName，这里默认是空的，需要的话也是重写。最后发送地图名和GameMode路径给客户端。</p><p><code>GameModeBase::GameWelcomePlayer</code> 默认也是空的，官方说是可以利用它发送 <code>NMT_GameSpecific</code> 来通知客户端需要 <code>DLC</code> 才可进入。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UWorld::WelcomePlayer</span><span class="params">(UNetConnection* Connection)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FString LevelName;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> FSeamlessTravelHandler&amp; SeamlessTravelHandler = GEngine-&gt;<span class="built_in">SeamlessTravelHandlerForWorld</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (SeamlessTravelHandler.<span class="built_in">IsInTransition</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Tell the client to go to the destination map</span></span><br><span class="line">        LevelName = SeamlessTravelHandler.<span class="built_in">GetDestinationMapName</span>();</span><br><span class="line">        Connection-&gt;<span class="built_in">SetClientWorldPackageName</span>(NAME_None);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        LevelName = CurrentLevel-&gt;<span class="built_in">GetOutermost</span>()-&gt;<span class="built_in">GetName</span>();</span><br><span class="line">        Connection-&gt;<span class="built_in">SetClientWorldPackageName</span>(CurrentLevel-&gt;<span class="built_in">GetOutermost</span>()-&gt;<span class="built_in">GetFName</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (UGameInstance* GameInst = <span class="built_in">GetGameInstance</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        GameInst-&gt;<span class="built_in">ModifyClientTravelLevelURL</span>(LevelName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FString GameName;</span><br><span class="line">    FString RedirectURL;</span><br><span class="line">    <span class="keyword">if</span> (AuthorityGameMode != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        GameName = AuthorityGameMode-&gt;<span class="built_in">GetClass</span>()-&gt;<span class="built_in">GetPathName</span>();</span><br><span class="line">        AuthorityGameMode-&gt;<span class="built_in">GameWelcomePlayer</span>(Connection, RedirectURL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FNetControlMessage&lt;NMT_Welcome&gt;::<span class="built_in">Send</span>(Connection, LevelName, GameName, RedirectURL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NMT-Welcome"><a href="#NMT-Welcome" class="headerlink" title="NMT_Welcome"></a>NMT_Welcome</h3><p>客户端收到要进入的地图后，设置一下变量，后续 <code>UEngine::TickWorldTravel</code> 会进行真正加载地图。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UPendingNetGame::NotifyControlMessage</span><span class="params">(UNetConnection* Connection, uint8 MessageType, <span class="keyword">class</span> FInBunch&amp; Bunch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">case</span> NMT_Welcome:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Server accepted connection.</span></span><br><span class="line">        FString GameName;</span><br><span class="line">        FString RedirectURL;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FNetControlMessage&lt;NMT_Welcome&gt;::<span class="built_in">Receive</span>(Bunch, URL.Map, GameName, RedirectURL))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// extract map name and options</span></span><br><span class="line">            &#123;</span><br><span class="line">                FURL DefaultURL;</span><br><span class="line">                <span class="function">FURL <span class="title">TempURL</span><span class="params">(&amp;DefaultURL, *URL.Map, TRAVEL_Partial)</span></span>;</span><br><span class="line">                URL.Map = TempURL.Map;</span><br><span class="line">                URL.RedirectURL = RedirectURL;</span><br><span class="line">                URL.Op.<span class="built_in">Append</span>(TempURL.Op);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (GameName.<span class="built_in">Len</span>() &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                URL.<span class="built_in">AddOption</span>(*FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;game=%s&quot;</span>), *GameName));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Send out netspeed now that we&#x27;re connected</span></span><br><span class="line">            FNetControlMessage&lt;NMT_Netspeed&gt;::<span class="built_in">Send</span>(Connection, Connection-&gt;CurrentNetSpeed);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We have successfully connected</span></span><br><span class="line">            <span class="comment">// TickWorldTravel will load the map and call LoadMapCompleted which eventually calls SendJoin</span></span><br><span class="line">            bSuccessfullyConnected = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            URL.Map.<span class="built_in">Empty</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NMT-Netspeed"><a href="#NMT-Netspeed" class="headerlink" title="NMT_Netspeed"></a>NMT_Netspeed</h3><p>这个就是双方对网速，用于之后限流。但默认不开。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TAutoConsoleVariable&lt;int32&gt; <span class="title">CVarNetEnableCongestionControl</span><span class="params">(TEXT(<span class="string">&quot;net.EnableCongestionControl&quot;</span>), <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">	TEXT(<span class="string">&quot;Enables congestion control module.&quot;</span>))</span></span>;</span><br><span class="line"><span class="keyword">if</span> (FNetControlMessage&lt;NMT_Netspeed&gt;::<span class="built_in">Receive</span>(Bunch, Rate))</span><br><span class="line">&#123;</span><br><span class="line">    Connection-&gt;CurrentNetSpeed = FMath::<span class="built_in">Clamp</span>(Rate, <span class="number">1800</span>, NetDriver-&gt;MaxClientRate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NMT-Join"><a href="#NMT-Join" class="headerlink" title="NMT_Join"></a>NMT_Join</h3><p>客户端加载地图后，会将 PendingNetGame 中的 NetDriver 转移给 UWorld，同时还会将之后的 Control Message 回调转移到 UWorld 中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UEngine::MovePendingLevel</span><span class="params">(FWorldContext &amp;Context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Context.<span class="built_in">World</span>()-&gt;<span class="built_in">SetNetDriver</span>(Context.PendingNetGame-&gt;NetDriver);</span><br><span class="line"></span><br><span class="line">    UNetDriver* NetDriver = Context.PendingNetGame-&gt;NetDriver;</span><br><span class="line">    <span class="keyword">if</span> (NetDriver)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// The pending net driver is renamed to the current &quot;game net driver&quot;</span></span><br><span class="line">        NetDriver-&gt;<span class="built_in">SetNetDriverName</span>(NAME_GameNetDriver);</span><br><span class="line">        NetDriver-&gt;<span class="built_in">SetWorld</span>(Context.<span class="built_in">World</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用完 PendingNetGame 发完 NMT_Join，就不需要它了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UPendingNetGame::TravelCompleted</span><span class="params">(UEngine* Engine, FWorldContext&amp; Context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Show connecting message, cause precaching to occur.</span></span><br><span class="line">    Engine-&gt;TransitionType = ETransitionType::Connecting;</span><br><span class="line"></span><br><span class="line">    Engine-&gt;<span class="built_in">RedrawViewports</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Send join.</span></span><br><span class="line">    Context.PendingNetGame-&gt;<span class="built_in">SendJoin</span>();</span><br><span class="line">    Context.PendingNetGame-&gt;NetDriver = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端收到 NMT_Join ，则是要为客户端创建 PlayerController，之后通过 PlayerController::ClientTravelInternal RPC 通知到客户端。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UWorld::NotifyControlMessage</span><span class="params">(UNetConnection* Connection, uint8 MessageType, <span class="keyword">class</span> FInBunch&amp; Bunch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">case</span> NMT_Join:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Connection-&gt;PlayerController == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Spawn the player-actor for this network player.</span></span><br><span class="line">            FString ErrorMsg;</span><br><span class="line"></span><br><span class="line">            <span class="function">FURL <span class="title">InURL</span><span class="params">( <span class="literal">NULL</span>, *Connection-&gt;RequestURL, TRAVEL_Absolute )</span></span>;</span><br><span class="line"></span><br><span class="line">            Connection-&gt;PlayerController = <span class="built_in">SpawnPlayActor</span>( Connection, ROLE_AutonomousProxy, InURL, Connection-&gt;PlayerId, ErrorMsg );</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Successfully in game.</span></span><br><span class="line">            <span class="built_in">UE_LOG</span>(LogNet, Log, <span class="built_in">TEXT</span>(<span class="string">&quot;Join succeeded: %s&quot;</span>), *Connection-&gt;PlayerController-&gt;PlayerState-&gt;<span class="built_in">GetPlayerName</span>());</span><br><span class="line">            <span class="built_in">NETWORK_PROFILER</span>(GNetworkProfiler.<span class="built_in">TrackEvent</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;JOIN&quot;</span>), *Connection-&gt;PlayerController-&gt;PlayerState-&gt;<span class="built_in">GetPlayerName</span>(), Connection));</span><br><span class="line"></span><br><span class="line">            Connection-&gt;<span class="built_in">SetClientLoginState</span>(EClientLoginState::ReceivedJoin);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// if we&#x27;re in the middle of a transition or the client is in the wrong world, tell it to travel</span></span><br><span class="line">            FString LevelName;</span><br><span class="line">            FSeamlessTravelHandler &amp;SeamlessTravelHandler = GEngine-&gt;<span class="built_in">SeamlessTravelHandlerForWorld</span>( <span class="keyword">this</span> );</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (SeamlessTravelHandler.<span class="built_in">IsInTransition</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// tell the client to go to the destination map</span></span><br><span class="line">                LevelName = SeamlessTravelHandler.<span class="built_in">GetDestinationMapName</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!Connection-&gt;PlayerController-&gt;<span class="built_in">HasClientLoadedCurrentWorld</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// tell the client to go to our current map</span></span><br><span class="line">                FString NewLevelName = <span class="built_in">GetOutermost</span>()-&gt;<span class="built_in">GetName</span>();</span><br><span class="line">                <span class="built_in">UE_LOG</span>(LogNet, Log, <span class="built_in">TEXT</span>(<span class="string">&quot;Client joined but was sent to another level. Asking client to travel to: &#x27;%s&#x27;&quot;</span>), *NewLevelName);</span><br><span class="line">                LevelName = NewLevelName;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (LevelName != <span class="built_in">TEXT</span>(<span class="string">&quot;&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                Connection-&gt;PlayerController-&gt;<span class="built_in">ClientTravel</span>(LevelName, TRAVEL_Relative, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// @TODO FIXME - TEMP HACK? - clear queue on join</span></span><br><span class="line">            Connection-&gt;QueuedBits = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SpawnPlayActor</code> 就是创建 PlayerController 的地方，使用 GameMode::Login，创建 PlayerController，并设置相应的同步参数即可，最终将该玩家的PlayerController注册到 GameSession中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">APlayerController* <span class="title">UWorld::SpawnPlayActor</span><span class="params">(UPlayer* NewPlayer, ENetRole RemoteRole, <span class="type">const</span> FURL&amp; InURL, <span class="type">const</span> FUniqueNetIdRepl&amp; UniqueId, FString&amp; Error, uint8 InNetPlayerIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (AGameModeBase* <span class="type">const</span> GameMode = <span class="built_in">GetAuthGameMode</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Give the GameMode a chance to accept the login</span></span><br><span class="line">        APlayerController* <span class="type">const</span> NewPlayerController = GameMode-&gt;<span class="built_in">Login</span>(NewPlayer, RemoteRole, *InURL.Portal, Options, UniqueId, Error);</span><br><span class="line">        <span class="keyword">if</span> (NewPlayerController == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">UE_LOG</span>(LogSpawn, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;Login failed: %s&quot;</span>), *Error);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">UE_LOG</span>(LogSpawn, Log, <span class="built_in">TEXT</span>(<span class="string">&quot;%s got player %s [%s]&quot;</span>), *NewPlayerController-&gt;<span class="built_in">GetName</span>(), *NewPlayer-&gt;<span class="built_in">GetName</span>(), UniqueId.<span class="built_in">IsValid</span>() ? *UniqueId-&gt;<span class="built_in">ToString</span>() : <span class="built_in">TEXT</span>(<span class="string">&quot;Invalid&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Possess the newly-spawned player.</span></span><br><span class="line">        NewPlayerController-&gt;NetPlayerIndex = InNetPlayerIndex;</span><br><span class="line">        NewPlayerController-&gt;<span class="built_in">SetRole</span>(ROLE_Authority);</span><br><span class="line">        NewPlayerController-&gt;<span class="built_in">SetReplicates</span>(RemoteRole != ROLE_None);</span><br><span class="line">        <span class="keyword">if</span> (RemoteRole == ROLE_AutonomousProxy)</span><br><span class="line">        &#123;</span><br><span class="line">            NewPlayerController-&gt;<span class="built_in">SetAutonomousProxy</span>(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        NewPlayerController-&gt;<span class="built_in">SetPlayer</span>(NewPlayer);</span><br><span class="line">        GameMode-&gt;<span class="built_in">PostLogin</span>(NewPlayerController);</span><br><span class="line">        <span class="keyword">return</span> NewPlayerController;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PostLogin 则是使用RPC创建HUD之类的东西，至此整个登录流程就已经走完了。</p><h3 id="登录总结"><a href="#登录总结" class="headerlink" title="登录总结"></a>登录总结</h3><ol><li>NMT_Hello<ul><li>Client：通知大小端、网络版本号、Token</li><li>Server：校验版本号、Token</li></ul></li><li>NMT_Challenge<ul><li>Server：发送校验信息给客户端(但好像没用上)</li><li>Client：收到校验信息</li></ul></li><li>NMT_Login<ul><li>Client：通过拼接URL 告知服务端自己的别名和 ID</li><li>Server：检查是否满员，<code>GameMode::PreLogin</code></li></ul></li><li>NMT_Welcome<ul><li>Server：通知客户端当前的地图名和 GameMode 路径</li><li>Client：记录收到的地图名，等下一轮 Tick 进行加载</li></ul></li><li>NMT_Join<ul><li>Client：地图加载完成后，发送 NMT_Join</li><li>Server：<code>GameMode::Login</code> 创建 PlayerController，设置好同步属性，<code>GameMode::PostLogin</code> 通过 PlayerController RPC 通知客户端创建 HUD，并换地图 <code>ClientTravel</code>(之前已经加载过一次地图了，这里还要再加载这个地图，是防止客户端在连接过程中换图？)</li></ul></li></ol><h2 id="Bunch"><a href="#Bunch" class="headerlink" title="Bunch"></a>Bunch</h2><p>以上登录的消息全是基于 Bunch 的，包括后续的属性同步也是。因此有必要在这认识一下 Bunch。</p><p>Bunch 分为两种，OutBunch 和 InBunch ，分别对应发送和接收。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FOutBunch</span> : <span class="keyword">public</span> FNetBitWriter</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FOutBunch *             Next;</span><br><span class="line">    UChannel *              Channel;</span><br><span class="line">    <span class="type">double</span>                  Time;</span><br><span class="line">    int32                   ChIndex;</span><br><span class="line">    FName                   ChName;</span><br><span class="line">    int32                   ChSequence;</span><br><span class="line">    int32                   PacketId;</span><br><span class="line">    uint8                   ReceivedAck:<span class="number">1</span>;</span><br><span class="line">    uint8                   bOpen:<span class="number">1</span>;</span><br><span class="line">    uint8                   bClose:<span class="number">1</span>;</span><br><span class="line">    uint8                   bReliable:<span class="number">1</span>;</span><br><span class="line">    uint8                   bPartial:<span class="number">1</span>;             <span class="comment">// Not a complete bunch</span></span><br><span class="line">    uint8                   bPartialInitial:<span class="number">1</span>;      <span class="comment">// The first bunch of a partial bunch</span></span><br><span class="line">    uint8                   bPartialFinal:<span class="number">1</span>;        <span class="comment">// The final bunch of a partial bunch</span></span><br><span class="line">    uint8                   bHasPackageMapExports:<span class="number">1</span>;    <span class="comment">// This bunch has networkGUID name/id pairs</span></span><br><span class="line">    uint8                   bHasMustBeMappedGUIDs:<span class="number">1</span>;    <span class="comment">// This bunch has guids that must be mapped before we can process this bunch</span></span><br><span class="line"></span><br><span class="line">    EChannelCloseReason     CloseReason;</span><br><span class="line"></span><br><span class="line">    TArray&lt; FNetworkGUID &gt;  ExportNetGUIDs;         <span class="comment">// List of GUIDs that went out on this bunch</span></span><br><span class="line">    TArray&lt; uint64 &gt;        NetFieldExports;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其实就是带一些所属 Channel 信息，是否为开启 Channel 或 关闭 Channel，Packet 信息(因为依赖于 Packet发送)需要处理丢包的情况，和分包信息，因为 UDP 超过一定大小会直接丢包，需要分包处理。至于 <code>ExportNetGUIDs</code> 和 <code>NetFieldExports</code> 可以先不管，这是属性同步时，同步 Actor 用的，现在这还处于登录状态，根本没有 Actor 需要同步。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FInBunch</span> : <span class="keyword">public</span> FNetBitReader</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    int32               PacketId;   <span class="comment">// Note this must stay as first member variable in FInBunch for FInBunch(FInBunch, bool) to work</span></span><br><span class="line">    FInBunch *          Next;</span><br><span class="line">    UNetConnection *    Connection;</span><br><span class="line">    int32               ChIndex;</span><br><span class="line">    FName               ChName;</span><br><span class="line">    int32               ChSequence;</span><br><span class="line">    uint8               bOpen:<span class="number">1</span>;</span><br><span class="line">    uint8               bClose:<span class="number">1</span>;</span><br><span class="line">    uint8               bReliable:<span class="number">1</span>;</span><br><span class="line">    uint8               bPartial:<span class="number">1</span>;                 <span class="comment">// Not a complete bunch</span></span><br><span class="line">    uint8               bPartialInitial:<span class="number">1</span>;          <span class="comment">// The first bunch of a partial bunch</span></span><br><span class="line">    uint8               bPartialFinal:<span class="number">1</span>;            <span class="comment">// The final bunch of a partial bunch</span></span><br><span class="line">    uint8               bHasPackageMapExports:<span class="number">1</span>;    <span class="comment">// This bunch has networkGUID name/id pairs</span></span><br><span class="line">    uint8               bHasMustBeMappedGUIDs:<span class="number">1</span>;    <span class="comment">// This bunch has guids that must be mapped before we can process this bunch</span></span><br><span class="line">    uint8               bIgnoreRPCs:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    EChannelCloseReason     CloseReason;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>初步了解了 <code>Bunch</code> 后，还需要了解 <code>Channel</code> 毕竟是通过 Channel 的接口发出 Bunch。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UChannel</span> : <span class="keyword">public</span> UObject</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	uint32              OpenAcked:<span class="number">1</span>;        <span class="comment">// If OpenedLocally is true, this means we have acknowledged the packet we sent the bOpen bunch on. Otherwise, it means we have received the bOpen bunch from the server.</span></span><br><span class="line">	uint32              Closing:<span class="number">1</span>;          <span class="comment">// State of the channel.</span></span><br><span class="line">	uint32              Dormant:<span class="number">1</span>;          <span class="comment">// Channel is going dormant (it will close but the client will not destroy</span></span><br><span class="line">	uint32              OpenTemporary:<span class="number">1</span>;    <span class="comment">// Opened temporarily.</span></span><br><span class="line">	uint32              Broken:<span class="number">1</span>;           <span class="comment">// Has encountered errors and is ignoring subsequent packets.</span></span><br><span class="line">	uint32              bTornOff:<span class="number">1</span>;         <span class="comment">// Actor associated with this channel was torn off</span></span><br><span class="line">	uint32              bPendingDormancy:<span class="number">1</span>;	<span class="comment">// Channel wants to go dormant (it will check during tick if it can go dormant)</span></span><br><span class="line">	uint32              bIsInDormancyHysteresis:<span class="number">1</span>; <span class="comment">// Channel wants to go dormant, and is otherwise ready to become dormant, but is waiting for a timeout before doing so.</span></span><br><span class="line">	uint32              bPausedUntilReliableACK:<span class="number">1</span>; <span class="comment">// Unreliable property replication is paused until all reliables are ack&#x27;d.</span></span><br><span class="line">	uint32              SentClosingBunch:<span class="number">1</span>;	<span class="comment">// Set when sending closing bunch to avoid recursion in send-failure-close case.</span></span><br><span class="line">	uint32              bPooled:<span class="number">1</span>;          <span class="comment">// Set when placed in the actor channel pool</span></span><br><span class="line">	uint32              OpenedLocally:<span class="number">1</span>;    <span class="comment">// Whether channel was opened locally or by remote.</span></span><br><span class="line">	uint32              bOpenedForCheckpoint:<span class="number">1</span>;	<span class="comment">// Whether channel was opened by replay checkpoint recording</span></span><br><span class="line">	int32               ChIndex;            <span class="comment">// Index of this channel.</span></span><br><span class="line">	FPacketIdRange      OpenPacketId;       <span class="comment">// If OpenedLocally is true, this is the packet we sent the bOpen bunch on. Otherwise, it&#x27;s the packet we received the bOpen bunch on.</span></span><br><span class="line">	FName               ChName;             <span class="comment">// Name of the type of this channel.</span></span><br><span class="line">	int32               NumInRec;           <span class="comment">// Number of packets in InRec.</span></span><br><span class="line">	int32               NumOutRec;          <span class="comment">// Number of packets in OutRec.</span></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">FInBunch</span>*     InRec;              <span class="comment">// Incoming data with queued dependencies.</span></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">FOutBunch</span>*    OutRec;             <span class="comment">// Outgoing reliable unacked data.</span></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">FInBunch</span>*     InPartialBunch;     <span class="comment">// Partial bunch we are receiving (incoming partial bunches are appended to this)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在以 NMT_Hello 为例子，学习如何发送 Bunch。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Conn-&gt;Channels[<span class="number">0</span>]-&gt;<span class="built_in">SendBunch</span>(&amp;Bunch, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h2 id="Channel-SendBunch"><a href="#Channel-SendBunch" class="headerlink" title="Channel::SendBunch"></a>Channel::SendBunch</h2><p><code>NumOutRec</code> 表示发出的需要可靠传输且还未确认对方收到的 Bunch 数量，此处认为若有太多数据对端还未确认则先暂存消息，否则调用父类进行发送。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FPacketIdRange <span class="title">UControlChannel::SendBunch</span><span class="params">(FOutBunch* Bunch, <span class="type">bool</span> Merge)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// if we already have queued messages, we need to queue subsequent ones to guarantee proper ordering</span></span><br><span class="line">    <span class="keyword">if</span> (QueuedMessages.<span class="built_in">Num</span>() &gt; <span class="number">0</span> || NumOutRec &gt;= RELIABLE_BUFFER - <span class="number">1</span> + Bunch-&gt;bClose)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">QueueMessage</span>(Bunch);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">FPacketIdRange</span>(INDEX_NONE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Bunch-&gt;<span class="built_in">IsError</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> Super::<span class="built_in">SendBunch</span>(Bunch, Merge);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查对端是否需要打开一个新 Channel，Bunch 中的 <code>bOpen</code> 就是这个功能，通知对端创建一个 Channel， <code>OpenedLocally</code> 表示这个 Channel 是本地创建的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FPacketIdRange <span class="title">UChannel::SendBunch</span><span class="params">( FOutBunch* Bunch, <span class="type">bool</span> Merge )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (OpenedLocally &amp;&amp; ((OpenPacketId.First == INDEX_NONE) || ((Connection-&gt;ResendAllDataState != EResendAllDataState::None) &amp;&amp; !bDormancyClose)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> bOpenBunch = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Connection-&gt;ResendAllDataState == EResendAllDataState::SinceCheckpoint)</span><br><span class="line">        &#123;</span><br><span class="line">            bOpenBunch = !bOpenedForCheckpoint;</span><br><span class="line">            bOpenedForCheckpoint = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bOpenBunch)</span><br><span class="line">        &#123;</span><br><span class="line">            Bunch-&gt;bOpen = <span class="number">1</span>;</span><br><span class="line">            OpenTemporary = !Bunch-&gt;bReliable;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AppendExportBunches</code> 使用 <code>UPackageMapClient</code> 将首次加入网络同步的 Actor 进行序列化，此处还处于登录环节，因此是空的，另外 <code>IsInternalAck</code> 为 true时 通常表示是回放的时候。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TArray&lt;FOutBunch*&gt;&amp; OutgoingBunches = Connection-&gt;<span class="built_in">GetOutgoingBunches</span>();</span><br><span class="line">OutgoingBunches.<span class="built_in">Reset</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add any export bunches</span></span><br><span class="line"><span class="comment">// Replay connections will manage export bunches separately.</span></span><br><span class="line"><span class="keyword">if</span> (!Connection-&gt;<span class="built_in">IsInternalAck</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">AppendExportBunches</span>( OutgoingBunches );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 Bunch 的基础属性相同，且发送缓冲区还未发送出去，且没超过最大 Bunch 大小，则考虑合包，当然若前面触发了 Actor 序列化，则不会进行合包。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span></span><br><span class="line">(	Merge</span><br><span class="line">&amp;&amp;	Connection-&gt;LastOut.ChIndex == Bunch-&gt;ChIndex</span><br><span class="line">&amp;&amp;	Connection-&gt;LastOut.bReliable == Bunch-&gt;bReliable	<span class="comment">// Don&#x27;t merge bunches of different reliability, since for example a reliable RPC can cause a bunch with properties to become reliable, introducing unnecessary latency for the properties.</span></span><br><span class="line">&amp;&amp;	Connection-&gt;AllowMerge</span><br><span class="line">&amp;&amp;	Connection-&gt;LastEnd.<span class="built_in">GetNumBits</span>()</span><br><span class="line">&amp;&amp;	Connection-&gt;LastEnd.<span class="built_in">GetNumBits</span>()==Connection-&gt;SendBuffer.<span class="built_in">GetNumBits</span>()</span><br><span class="line">&amp;&amp;	Connection-&gt;LastOut.<span class="built_in">GetNumBits</span>() + Bunch-&gt;<span class="built_in">GetNumBits</span>() &lt;= MAX_SINGLE_BUNCH_SIZE_BITS )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Merge.</span></span><br><span class="line">    PreExistingBits = Connection-&gt;LastOut.<span class="built_in">GetNumBits</span>();</span><br><span class="line">    Connection-&gt;LastOut.<span class="built_in">SerializeBits</span>( Bunch-&gt;<span class="built_in">GetData</span>(), Bunch-&gt;<span class="built_in">GetNumBits</span>() );</span><br><span class="line">    Connection-&gt;LastOut.bOpen     |= Bunch-&gt;bOpen;</span><br><span class="line">    Connection-&gt;LastOut.bClose    |= Bunch-&gt;bClose;</span><br><span class="line"></span><br><span class="line">    OutBunch                       = Connection-&gt;LastOutBunch;</span><br><span class="line">    Bunch                          = &amp;Connection-&gt;LastOut;</span><br><span class="line">    Connection-&gt;<span class="built_in">PopLastStart</span>();</span><br><span class="line">    Connection-&gt;Driver-&gt;OutBunches--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若单个 Bunch 过大，又会进行拆包。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( Bunch-&gt;<span class="built_in">GetNumBits</span>() &gt; MAX_SINGLE_BUNCH_SIZE_BITS )</span><br><span class="line">&#123;</span><br><span class="line">    uint8 *data = Bunch-&gt;<span class="built_in">GetData</span>();</span><br><span class="line">    int64 bitsLeft = Bunch-&gt;<span class="built_in">GetNumBits</span>();</span><br><span class="line">    Merge = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(bitsLeft &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        FOutBunch * PartialBunch = <span class="keyword">new</span> <span class="built_in">FOutBunch</span>(<span class="keyword">this</span>, <span class="literal">false</span>);</span><br><span class="line">        int64 bitsThisBunch = FMath::<span class="built_in">Min</span>&lt;int64&gt;(bitsLeft, MAX_PARTIAL_BUNCH_SIZE_BITS);</span><br><span class="line">        PartialBunch-&gt;<span class="built_in">SerializeBits</span>(data, bitsThisBunch);</span><br><span class="line"></span><br><span class="line">        OutgoingBunches.<span class="built_in">Add</span>(PartialBunch);</span><br><span class="line"></span><br><span class="line">        bitsLeft -= bitsThisBunch;</span><br><span class="line">        data += (bitsThisBunch &gt;&gt; <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    OutgoingBunches.<span class="built_in">Add</span>(Bunch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拆分包后，若拆分的包少于某个阈值，哪怕它原始 Bunch 不是可靠传输的，也会修改为可靠传输。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int32 GCVarNetPartialBunchReliableThreshold = <span class="number">8</span>;</span><br><span class="line"><span class="function">FAutoConsoleVariableRef <span class="title">CVarNetPartialBunchReliableThreshold</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	TEXT(<span class="string">&quot;net.PartialBunchReliableThreshold&quot;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">	GCVarNetPartialBunchReliableThreshold,</span></span></span><br><span class="line"><span class="params"><span class="function">	TEXT(<span class="string">&quot;If a bunch is broken up into this many partial bunches are more, we will send it reliable even if the original bunch was not reliable. Partial bunches are atonmic and must all make it over to be used&quot;</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">bool</span> bOverflowsReliable = (NumOutRec + OutgoingBunches.<span class="built_in">Num</span>() &gt;= RELIABLE_BUFFER + Bunch-&gt;bClose);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((GCVarNetPartialBunchReliableThreshold &gt; <span class="number">0</span>) &amp;&amp; (OutgoingBunches.<span class="built_in">Num</span>() &gt;= GCVarNetPartialBunchReliableThreshold) &amp;&amp; !Connection-&gt;<span class="built_in">IsInternalAck</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!bOverflowsReliable)</span><br><span class="line">    &#123;</span><br><span class="line">        Bunch-&gt;bReliable = <span class="literal">true</span>;</span><br><span class="line">        bPausedUntilReliableACK = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若太多的可靠传输包，超出了阈值，就会断开连接，因为可靠传输是用的一条链表存放的还未确认的 Bunch 包，不能无限存放。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Bunch-&gt;bReliable &amp;&amp; bOverflowsReliable)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">PRAGMA_DISABLE_DEPRECATION_WARNINGS</span></span><br><span class="line"><span class="function">    <span class="title">PrintReliableBunchBuffer</span><span class="params">()</span></span>;</span><br><span class="line">    PRAGMA_ENABLE_DEPRECATION_WARNINGS</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bail out, we can&#x27;t recover from this (without increasing RELIABLE_BUFFER)</span></span><br><span class="line">    FString ErrorMsg = <span class="built_in">NSLOCTEXT</span>(<span class="string">&quot;NetworkErrors&quot;</span>, <span class="string">&quot;ClientReliableBufferOverflow&quot;</span>, <span class="string">&quot;Outgoing reliable buffer overflow&quot;</span>).<span class="built_in">ToString</span>();</span><br><span class="line"></span><br><span class="line">    Connection-&gt;<span class="built_in">SendCloseReason</span>(ENetCloseResult::ReliableBufferOverflow);</span><br><span class="line">    FNetControlMessage&lt;NMT_Failure&gt;::<span class="built_in">Send</span>(Connection, ErrorMsg);</span><br><span class="line">    Connection-&gt;<span class="built_in">FlushNet</span>(<span class="literal">true</span>);</span><br><span class="line">    Connection-&gt;<span class="built_in">Close</span>(ENetCloseResult::ReliableBufferOverflow);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> PacketIdRange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还需要对拆分的 Bunch 做属性的调整。 <code>OutgoingBunches</code> 的数量通常只有一个，若大于 1 则要么是拆分包，要么是有导出的 Actor 同步包，它们都没有设置过 Bunch 的属性，需要在此处进行调整。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( int32 PartialNum = <span class="number">0</span>; PartialNum &lt; OutgoingBunches.<span class="built_in">Num</span>(); ++PartialNum)</span><br><span class="line">&#123;</span><br><span class="line">    FOutBunch * NextBunch = OutgoingBunches[PartialNum];</span><br><span class="line"></span><br><span class="line">    NextBunch-&gt;bReliable = Bunch-&gt;bReliable;</span><br><span class="line">    NextBunch-&gt;bOpen = Bunch-&gt;bOpen;</span><br><span class="line">    NextBunch-&gt;bClose = Bunch-&gt;bClose;</span><br><span class="line">    NextBunch-&gt;CloseReason = Bunch-&gt;CloseReason;</span><br><span class="line">    NextBunch-&gt;ChIndex = Bunch-&gt;ChIndex;</span><br><span class="line">    NextBunch-&gt;ChName = Bunch-&gt;ChName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( !NextBunch-&gt;bHasPackageMapExports )</span><br><span class="line">    &#123;</span><br><span class="line">        NextBunch-&gt;bHasMustBeMappedGUIDs |= Bunch-&gt;bHasMustBeMappedGUIDs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (OutgoingBunches.<span class="built_in">Num</span>() &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        NextBunch-&gt;bPartial = <span class="number">1</span>;</span><br><span class="line">        NextBunch-&gt;bPartialInitial = (PartialNum == <span class="number">0</span> ? <span class="number">1</span>: <span class="number">0</span>);</span><br><span class="line">        NextBunch-&gt;bPartialFinal = (PartialNum == OutgoingBunches.<span class="built_in">Num</span>() - <span class="number">1</span> ? <span class="number">1</span>: <span class="number">0</span>);</span><br><span class="line">        NextBunch-&gt;bOpen &amp;= (PartialNum == <span class="number">0</span>);                                          <span class="comment">// Only the first bunch should have the bOpen bit set</span></span><br><span class="line">        NextBunch-&gt;bClose = (Bunch-&gt;bClose &amp;&amp; (OutgoingBunches.<span class="built_in">Num</span>()<span class="number">-1</span> == PartialNum)); <span class="comment">// Only last bunch should have bClose bit set</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FOutBunch *ThisOutBunch = <span class="built_in">PrepBunch</span>(NextBunch, OutBunch, Merge); <span class="comment">// This handles queuing reliable bunches into the ack list</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update Packet Range</span></span><br><span class="line">    int32 PacketId = <span class="built_in">SendRawBunch</span>(ThisOutBunch, Merge, <span class="built_in">GetTraceCollector</span>(*NextBunch));</span><br><span class="line">    <span class="keyword">if</span> (PartialNum == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PacketIdRange = <span class="built_in">FPacketIdRange</span>(PacketId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PacketIdRange.Last = PacketId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update channel sequence count.</span></span><br><span class="line">    Connection-&gt;LastOut = *ThisOutBunch;</span><br><span class="line">    Connection-&gt;LastEnd	= <span class="built_in">FBitWriterMark</span>( Connection-&gt;SendBuffer );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PrepBunch</code> 是处理可靠 Bunch 的函数，若该 Bunch 为 <code>bReliable</code> 则将其放入 <code>OutBunch</code> 链表存起来，若发生丢包，则会取出该 Bunch，重新分配一个 Packet 将其传输过去。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FOutBunch* <span class="title">UChannel::PrepBunch</span><span class="params">(FOutBunch* Bunch, FOutBunch* OutBunch, <span class="type">bool</span> Merge)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( Connection-&gt;ResendAllDataState != EResendAllDataState::None )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Bunch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find outgoing bunch index.</span></span><br><span class="line">    <span class="keyword">if</span>( Bunch-&gt;bReliable )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Find spot, which was guaranteed available by FOutBunch constructor.</span></span><br><span class="line">        <span class="keyword">if</span>( OutBunch==<span class="literal">NULL</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            Bunch-&gt;Next	= <span class="literal">NULL</span>;</span><br><span class="line">            Bunch-&gt;ChSequence = ++Connection-&gt;OutReliable[ChIndex];</span><br><span class="line">            NumOutRec++;</span><br><span class="line">            Connection-&gt;<span class="built_in">GetDriver</span>()-&gt;<span class="built_in">GetMetrics</span>()-&gt;<span class="built_in">SetMaxInt</span>(UE::Net::Metric::OutgoingReliableMessageQueueMaxSize, NumOutRec);</span><br><span class="line">            OutBunch = <span class="keyword">new</span> <span class="built_in">FOutBunch</span>(*Bunch);</span><br><span class="line">            FOutBunch** OutLink = &amp;OutRec;</span><br><span class="line">            <span class="keyword">while</span>(*OutLink) <span class="comment">// This was rewritten from a single-line for loop due to compiler complaining about empty body for loops (-Wempty-body)</span></span><br><span class="line">            &#123;</span><br><span class="line">                OutLink=&amp;(*OutLink)-&gt;Next;</span><br><span class="line">            &#125;</span><br><span class="line">            *OutLink = OutBunch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Bunch-&gt;Next = OutBunch-&gt;Next;</span><br><span class="line">            *OutBunch = *Bunch;</span><br><span class="line">        &#125;</span><br><span class="line">        Connection-&gt;LastOutBunch = OutBunch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        OutBunch = Bunch;</span><br><span class="line">        Connection-&gt;LastOutBunch = <span class="literal">NULL</span>;<span class="comment">//warning: Complex code, don&#x27;t mess with this!</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OutBunch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bunch 丢失后的重传：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UChannel::ReceivedNak</span><span class="params">( int32 NakPacketId )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( FOutBunch* Out=OutRec; Out; Out=Out-&gt;Next )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Retransmit reliable bunches in the lost packet.</span></span><br><span class="line">        <span class="keyword">if</span>( Out-&gt;PacketId==NakPacketId &amp;&amp; !Out-&gt;ReceivedAck )</span><br><span class="line">        &#123;</span><br><span class="line">                Connection-&gt;<span class="built_in">SendRawBunch</span>( *Out, <span class="number">0</span> );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然若对端连打开 ControlChannel 的 Bunch 都没有收到，会在 ControlChannel::Tick 中进行重发， <code>OpenAcked</code> 指的是打开 Channel 的 Bunch 是否收到 Ack。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UControlChannel::Tick</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">Tick</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( !OpenAcked )</span><br><span class="line">    &#123;</span><br><span class="line">        int32 Count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (FOutBunch* Out = OutRec; Out; Out = Out-&gt;Next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!Out-&gt;ReceivedAck)</span><br><span class="line">            &#123;</span><br><span class="line">                Count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Count &gt; <span class="number">8</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Resend any pending packets if we didn&#x27;t get the appropriate acks.</span></span><br><span class="line">        <span class="keyword">for</span>( FOutBunch* Out=OutRec; Out; Out=Out-&gt;Next )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( !Out-&gt;ReceivedAck )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">double</span> Wait = Connection-&gt;Driver-&gt;<span class="built_in">GetElapsedTime</span>() - Out-&gt;Time;</span><br><span class="line">                <span class="keyword">if</span> (Wait &gt; <span class="number">1.0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Connection-&gt;<span class="built_in">SendRawBunch</span>( *Out, <span class="number">0</span> );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ReceivedBunch"><a href="#ReceivedBunch" class="headerlink" title="ReceivedBunch"></a>ReceivedBunch</h2><p>Bunch 的接收的调用栈如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UNetConnection::ReceivedRawPacket</span><br><span class="line">    UNetConnection::ReceivedPacket</span><br><span class="line">        UNetConnection::DispatchPacket</span><br></pre></td></tr></table></figure><p>将 Packet 解包，让 Channel 来处理 Bunch。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UNetConnection::ReceivedPacket</span><span class="params">( FBitReader&amp; Reader, <span class="type">bool</span> bIsReinjectedPacket, <span class="type">bool</span> bDispatchPacket )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UChannel* Channel = Channels[Bunch.ChIndex];</span><br><span class="line">    <span class="keyword">if</span> (Channel == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Channel = <span class="built_in">CreateChannelByName</span>( Bunch.ChName, EChannelCreateFlags::None, Bunch.ChIndex );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Channel != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Warning: May destroy channel</span></span><br><span class="line">        Channel-&gt;<span class="built_in">ReceivedRawBunch</span>(Bunch, bLocalSkipAck);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后将 Bunch 交给 <code>void UControlChannel::ReceivedBunch( FInBunch&amp; Bunch )</code></p><p>分发到 Notify 中，客户端对应 PendingNetGame 服务端对应 World</p><p><code>Connection-&gt;Driver-&gt;Notify-&gt;NotifyControlMessage(Connection, MessageType, Bunch);</code></p></div><footer class="post-footer"><div class="post-tags"><a href="/tags/UE5/" rel="tag"># UE5</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag"># 网络</a></div><div class="post-nav"><div class="post-nav-item"><a href="/UE5%20%E7%BD%91%E7%BB%9C%E5%89%96%E6%9E%90(%E4%BA%8C)%20%E6%97%A0%E7%8A%B6%E6%80%81%E8%BF%9E%E6%8E%A5/" rel="prev" title="UE5 网络剖析(二) 无状态连接"><i class="fa fa-angle-left"></i> UE5 网络剖析(二) 无状态连接</a></div><div class="post-nav-item"><a href="/UE5%20%E7%BD%91%E7%BB%9C%E5%89%96%E6%9E%90(%E5%9B%9B)%20%E5%B1%9E%E6%80%A7%E5%90%8C%E6%AD%A5%E4%B8%8ERPC/" rel="next" title="UE5 网络剖析(四) 属性同步与RPC">UE5 网络剖析(四) 属性同步与RPC <i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Yuerer</span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://unpkg.com/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://unpkg.com/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/comments.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/utils.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/motion.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/sidebar.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/next-boot.min.js"></script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://yuerer-comment-xufei-0bea01e6f05-1307930306.ap-shanghai.app.tcloudbase.com","cssUrl":"https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.css","commentCount":true,"pageview":true,"libUrl":"https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.js","locale":{"placeholder":"有何高见？"},"emoji":["https://unpkg.com/@waline/emojis@1.0.1/qq"],"meta":["nick","mail"],"requiredMeta":[["nick","mail"]],"wordLimit":0,"login":"disable","pageSize":10,"el":"#waline","comment":true,"path":"/UE5%20%E7%BD%91%E7%BB%9C%E5%89%96%E6%9E%90(%E4%B8%89)%20%E7%99%BB%E5%BD%95/"}</script><link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.css"><script>document.addEventListener("page:loaded",()=>{NexT.utils.loadComments(CONFIG.waline.el).then(()=>NexT.utils.getScript(CONFIG.waline.libUrl,{condition:window.Waline})).then(()=>Waline.init(Object.assign({},CONFIG.waline,{el:document.querySelector(CONFIG.waline.el)})))})</script></body></html>