<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.jpeg"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.ico"><link rel="mask-icon" href="/images/avatar.jpeg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous"><link rel="stylesheet" href="https://unpkg.com/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"yuerer.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"hide","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":true,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/config.min.js"></script><meta name="description" content="练习1：理解通过make生成执行文件的过程 操作系统镜像文件ucore.img是如何一步一步生成的？  123456$(UCOREIMG): $(kernel) $(bootblock)	$(V)dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;$@ count&#x3D;10000	$(V)dd if&#x3D;$(bootblock) of&#x3D;$@ conv&#x3D;notrunc	$(V)dd if&#x3D;$(kernel) of&#x3D;$@"><meta property="og:type" content="article"><meta property="og:title" content="操作系统 uCore Lab 1 含 Challenge"><meta property="og:url" content="https://yuerer.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-uCore-Lab-1/index.html"><meta property="og:site_name" content="Yuerer&#39;s Blog"><meta property="og:description" content="练习1：理解通过make生成执行文件的过程 操作系统镜像文件ucore.img是如何一步一步生成的？  123456$(UCOREIMG): $(kernel) $(bootblock)	$(V)dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;$@ count&#x3D;10000	$(V)dd if&#x3D;$(bootblock) of&#x3D;$@ conv&#x3D;notrunc	$(V)dd if&#x3D;$(kernel) of&#x3D;$@"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://yuerer.com/images/lab1_gcc.png"><meta property="og:image" content="https://yuerer.com/images/lab1_ld_bootblock.png"><meta property="og:image" content="https://yuerer.com/images/lab1_ld_kernel.png"><meta property="og:image" content="https://yuerer.com/images/stack.png"><meta property="og:image" content="https://yuerer.com/images/trapgate.png"><meta property="og:image" content="https://yuerer.com/images/lab1.png"><meta property="og:image" content="https://yuerer.com/images/pcb.png"><meta property="article:published_time" content="2018-11-04T14:12:20.000Z"><meta property="article:modified_time" content="2025-10-21T13:50:52.268Z"><meta property="article:author" content="Yuerer"><meta property="article:tag" content="操作系统"><meta property="article:tag" content="uCore"><meta property="article:tag" content="Lab"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://yuerer.com/images/lab1_gcc.png"><link rel="canonical" href="https://yuerer.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-uCore-Lab-1/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://yuerer.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-uCore-Lab-1/","path":"操作系统-uCore-Lab-1/","title":"操作系统 uCore Lab 1 含 Challenge"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>操作系统 uCore Lab 1 含 Challenge | Yuerer's Blog</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-129491388-1"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-129491388-1","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/third-party/analytics/google-analytics.min.js"></script><link rel="dns-prefetch" href="https://yuerer-comment-xufei-0bea01e6f05-1307930306.ap-shanghai.app.tcloudbase.com"><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Yuerer's Blog</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">钰儿的Blog</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%83%E4%B9%A01%EF%BC%9A%E7%90%86%E8%A7%A3%E9%80%9A%E8%BF%87make%E7%94%9F%E6%88%90%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-text">练习1：理解通过make生成执行文件的过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%83%E4%B9%A02%EF%BC%9A%E4%BD%BF%E7%94%A8qemu%E6%89%A7%E8%A1%8C%E5%B9%B6%E8%B0%83%E8%AF%95lab1%E4%B8%AD%E7%9A%84%E8%BD%AF%E4%BB%B6"><span class="nav-text">练习2：使用qemu执行并调试lab1中的软件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%83%E4%B9%A03%EF%BC%9A%E5%88%86%E6%9E%90bootloader%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-text">练习3：分析bootloader进入保护模式的过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%83%E4%B9%A04%EF%BC%9A%E5%88%86%E6%9E%90bootloader%E5%8A%A0%E8%BD%BDELF%E6%A0%BC%E5%BC%8F%E7%9A%84OS%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-text">练习4：分析bootloader加载ELF格式的OS的过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%83%E4%B9%A05%EF%BC%9A%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E8%B7%9F%E8%B8%AA%E5%87%BD%E6%95%B0"><span class="nav-text">练习5：实现函数调用堆栈跟踪函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%83%E4%B9%A06%EF%BC%9A%E5%AE%8C%E5%96%84%E4%B8%AD%E6%96%AD%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%A4%84%E7%90%86"><span class="nav-text">练习6：完善中断初始化和处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E7%BB%83%E4%B9%A0"><span class="nav-text">扩展练习</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E7%BB%83%E4%B9%A0-Challenge-1"><span class="nav-text">扩展练习 Challenge 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E7%BB%83%E4%B9%A0-Challenge-2"><span class="nav-text">扩展练习 Challenge 2</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Yuerer" src="/images/avatar.jpeg"><p class="site-author-name" itemprop="name">Yuerer</p><div class="site-description" itemprop="description">钰儿的Blog</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">65</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">16</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">90</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/Yu2erer" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Yu2erer" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:yu2erer#gmail.com" title="E-Mail → mailto:yu2erer#gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://yuerer.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-uCore-Lab-1/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpeg"><meta itemprop="name" content="Yuerer"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Yuerer's Blog"><meta itemprop="description" content="钰儿的Blog"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="操作系统 uCore Lab 1 含 Challenge | Yuerer's Blog"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">操作系统 uCore Lab 1 含 Challenge</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-11-04 22:12:20" itemprop="dateCreated datePublished" datetime="2018-11-04T22:12:20+08:00">2018-11-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a> </span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Waline：</span> <a title="waline" href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-uCore-Lab-1/#waline" itemprop="discussionUrl"><span class="post-comments-count waline-comment-count" data-path="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-uCore-Lab-1/" itemprop="commentCount"></span> </a></span><span class="post-meta-item" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="waline-pageview-count" data-path="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-uCore-Lab-1/"></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h3 id="练习1：理解通过make生成执行文件的过程"><a href="#练习1：理解通过make生成执行文件的过程" class="headerlink" title="练习1：理解通过make生成执行文件的过程"></a>练习1：理解通过make生成执行文件的过程</h3><ol><li>操作系统镜像文件ucore.img是如何一步一步生成的？</li></ol><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(UCOREIMG)</span>: <span class="variable">$(kernel)</span> <span class="variable">$(bootblock)</span></span><br><span class="line">	<span class="variable">$(V)</span>dd if=/dev/zero of=<span class="variable">$@</span> count=10000</span><br><span class="line">	<span class="variable">$(V)</span>dd if=<span class="variable">$(bootblock)</span> of=<span class="variable">$@</span> conv=notrunc</span><br><span class="line">	<span class="variable">$(V)</span>dd if=<span class="variable">$(kernel)</span> of=<span class="variable">$@</span> seek=1 conv=notrunc</span><br><span class="line">从 MakeFile 里面 可以看出 生成 ucore.img 首先需要生成 大小为 10000字节 的空间</span><br><span class="line">然后 将 bootblock 和 kernel 依次写入到 那块空间之中</span><br></pre></td></tr></table></figure><span id="more"></span><p>生成 Bootblock</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bootfiles = <span class="variable">$(<span class="built_in">call</span> listf_cc,boot)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">foreach</span> f,<span class="variable">$(bootfiles)</span>,$(<span class="built_in">call</span> cc_compile,<span class="variable">$(f)</span>,<span class="variable">$(CC)</span>,<span class="variable">$(CFLAGS)</span> -Os -nostdinc)</span>)</span><br><span class="line">这里遍历 boot 目录下的所有文件 asm.h bootasm.S bootmain.c</span><br><span class="line">bootblock = <span class="variable">$(<span class="built_in">call</span> totarget,bootblock)</span></span><br><span class="line">生成目标文件 asm.o bootasm.o bootmain.o sign.o</span><br><span class="line"><span class="variable">$(bootblock)</span>: <span class="variable">$(<span class="built_in">call</span> toobj,<span class="variable">$(bootfiles)</span>)</span> | <span class="variable">$(<span class="built_in">call</span> totarget,sign)</span></span><br><span class="line">	@echo + ld <span class="variable">$@</span></span><br><span class="line">	<span class="variable">$(V)</span><span class="variable">$(LD)</span> <span class="variable">$(LDFLAGS)</span> -N -e start -Ttext 0x7C00 <span class="variable">$^</span> -o <span class="variable">$(<span class="built_in">call</span> toobj,bootblock)</span></span><br><span class="line">	@<span class="variable">$(OBJDUMP)</span> -S <span class="variable">$(<span class="built_in">call</span> objfile,bootblock)</span> &gt; <span class="variable">$(<span class="built_in">call</span> asmfile,bootblock)</span></span><br><span class="line">	@<span class="variable">$(OBJDUMP)</span> -t <span class="variable">$(<span class="built_in">call</span> objfile,bootblock)</span> | <span class="variable">$(SED)</span> &#x27;1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d&#x27; &gt; <span class="variable">$(<span class="built_in">call</span> symfile,bootblock)</span></span><br><span class="line">	@<span class="variable">$(OBJCOPY)</span> -S -O binary <span class="variable">$(<span class="built_in">call</span> objfile,bootblock)</span> <span class="variable">$(<span class="built_in">call</span> outfile,bootblock)</span></span><br><span class="line">	@<span class="variable">$(<span class="built_in">call</span> totarget,sign)</span> <span class="variable">$(<span class="built_in">call</span> outfile,bootblock)</span> <span class="variable">$(bootblock)</span></span><br><span class="line">将目标文件 链接起来 同时指定代码段开始地址 为 0x7c00</span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> create_target,bootblock)</span></span><br></pre></td></tr></table></figure><p><img data-src="/images/lab1_gcc.png"></p><p><img data-src="/images/lab1_ld_bootblock.png"></p><p>生成 Kernel</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">KOBJS	= <span class="variable">$(<span class="built_in">call</span> read_packet,kernel libs)</span></span><br><span class="line"></span><br><span class="line">kernel = <span class="variable">$(<span class="built_in">call</span> totarget,kernel)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(kernel)</span>: tools/kernel.ld</span><br><span class="line"></span><br><span class="line"><span class="variable">$(kernel)</span>: <span class="variable">$(KOBJS)</span></span><br><span class="line">	@echo + ld <span class="variable">$@</span></span><br><span class="line">	<span class="variable">$(V)</span><span class="variable">$(LD)</span> <span class="variable">$(LDFLAGS)</span> -T tools/kernel.ld -o <span class="variable">$@</span> <span class="variable">$(KOBJS)</span></span><br><span class="line">	@<span class="variable">$(OBJDUMP)</span> -S <span class="variable">$@</span> &gt; <span class="variable">$(<span class="built_in">call</span> asmfile,kernel)</span></span><br><span class="line">	@<span class="variable">$(OBJDUMP)</span> -t <span class="variable">$@</span> | <span class="variable">$(SED)</span> &#x27;1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d&#x27; &gt; <span class="variable">$(<span class="built_in">call</span> symfile,kernel)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> create_target,kernel)</span></span><br><span class="line">将 kern 下面的所有文件 编译 生成 目标文件 再进行链接</span><br></pre></td></tr></table></figure><p><img data-src="/images/lab1_ld_kernel.png"></p><ul><li>-ggdb 生成可供gdb使用的调试信息</li><li>-m32 生成适用于32位环境的代码</li><li>-gstabs 生成stabs格式的调试信息</li><li>-nostdinc 不使用标准库</li><li>-fno-stack-protector 不生成用于检测缓冲区溢出的代码</li><li>-Os 为减小代码大小而进行优化</li><li>-I添加搜索头文件的路径</li><li>-fno-builtin 不进行builtin函数的优化</li><li>-m 模拟为i386上的连接器</li><li>-N 设置代码段和数据段均可读写</li><li>-e 指定入口</li><li>-Ttext 指定代码段开始位置</li></ul><ol start="2"><li>一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在 tools/sign.c 里面  有以下两句 说明 符合规范的硬盘主引导扇区特征是 最后两个字节 为 <span class="number">0x55</span> <span class="number">0xAA</span> 同时 主引导扇区的大小应为 <span class="number">512</span> 字节</span><br><span class="line">    buf[<span class="number">510</span>] = <span class="number">0x55</span>;</span><br><span class="line">    buf[<span class="number">511</span>] = <span class="number">0xAA</span>;</span><br></pre></td></tr></table></figure><h3 id="练习2：使用qemu执行并调试lab1中的软件"><a href="#练习2：使用qemu执行并调试lab1中的软件" class="headerlink" title="练习2：使用qemu执行并调试lab1中的软件"></a>练习2：使用qemu执行并调试lab1中的软件</h3><ol><li>从CPU加电后执行的第一条指令开始，单步跟踪BIOS的执行。</li><li>在初始化位置0x7c00设置实地址断点,测试断点正常。</li><li>从0x7c00开始跟踪代码运行,将单步跟踪反汇编得到的代码与bootasm.S和 bootblock.asm进行比较。</li><li>自己找一个bootloader或内核中的代码位置，设置断点并进行测试。</li></ol><p>在一个终端中先执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-i386 -S -s -d in_asm -D bin/q.log -monitor stdio -hda bin/ucore.img</span><br></pre></td></tr></table></figure><p>后在另一个终端执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">i386-elf-gdb</span><br><span class="line">file bin/kernel</span><br><span class="line">target remote :1234</span><br><span class="line">查看 CS:EIP 由于此时在实际模式下 CPU 在加电后执行的第一条指令的地址 为 0xf000:0xfff0 =&gt; 0xffff0</span><br><span class="line">(gdb) x/i $cs</span><br><span class="line">   0xf000:	add    %al,(%eax)</span><br><span class="line">(gdb) x/i $eip</span><br><span class="line">=&gt; 0xfff0:	add    %al,(%eax)</span><br><span class="line">再来看看这个地址的指令是什么</span><br><span class="line">(gdb) x/2i 0xffff0</span><br><span class="line">   0xffff0:	ljmp   $0x3630,$0xf000e05b</span><br><span class="line">可以看到 第一条指令执行完以后 会跳转到 0xf000e05b 也就是说 BIOS 开始的地址是 0xfe05b</span><br><span class="line"></span><br><span class="line">打上断点</span><br><span class="line">b *0x7c00</span><br><span class="line">(gdb) b *0x7c00</span><br><span class="line">Breakpoint 1 at 0x7c00</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x00007c00 in ?? ()</span><br></pre></td></tr></table></figure><h3 id="练习3：分析bootloader进入保护模式的过程"><a href="#练习3：分析bootloader进入保护模式的过程" class="headerlink" title="练习3：分析bootloader进入保护模式的过程"></a>练习3：分析bootloader进入保护模式的过程</h3><p>BIOS将通过读取硬盘主引导扇区到内存，并转跳到对应内存中的位置执行bootloader。请分析bootloader是如何完成从实模式进入保护模式的。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;asm<span class="number">.</span>h&gt;</span><br><span class="line"></span><br><span class="line"># Start the <span class="meta">CPU</span>: switch to <span class="number">32</span>-bit protected mode, jump <span class="keyword">into</span> C.</span><br><span class="line"># The BIOS loads this code from the first sector of the hard disk <span class="keyword">into</span></span><br><span class="line"># memory <span class="meta">at</span> physical address <span class="number">0x7c00</span> <span class="keyword">and</span> starts executing <span class="keyword">in</span> real mode</span><br><span class="line"># with %cs=<span class="number">0</span> %ip=7c00.</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">.set</span> PROT_MODE_CSEG,        <span class="number">0x8</span>                     # kernel code <span class="meta">segment</span> selector</span><br><span class="line"><span class="meta">.set</span> PROT_MODE_DSEG,        <span class="number">0x10</span>                    # kernel data <span class="meta">segment</span> selector</span><br><span class="line"><span class="meta">.set</span> CR0_PE_ON,             <span class="number">0x1</span>                     # protected mode enable flag</span><br><span class="line"></span><br><span class="line"># start address should be <span class="number">0</span>:7c00, <span class="keyword">in</span> real mode, the beginning address of the running bootloader</span><br><span class="line"><span class="meta">.globl</span> start</span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line"><span class="meta">.code16</span>                                             # Assemble for <span class="number">16</span>-bit mode</span><br><span class="line">    <span class="keyword">cli</span>                                             # Disable interrupts</span><br><span class="line">    <span class="keyword">cld</span>                                             # String operations increment</span><br><span class="line"></span><br><span class="line">    # Set <span class="meta">up</span> the important data <span class="meta">segment</span> registers (<span class="built_in">DS</span>, <span class="built_in">ES</span>, <span class="built_in">SS</span>).</span><br><span class="line">    xorw %ax, %ax                                   # <span class="meta">Segment</span> number <span class="meta">zero</span></span><br><span class="line">    movw %ax, %ds                                   # -&gt; Data <span class="meta">Segment</span></span><br><span class="line">    movw %ax, %es                                   # -&gt; Extra <span class="meta">Segment</span></span><br><span class="line">    movw %ax, %ss                                   # -&gt; Stack <span class="meta">Segment</span></span><br><span class="line"></span><br><span class="line">    # Enable A20:</span><br><span class="line">    #  For backwards compatibility with the earliest PCs, physical</span><br><span class="line">    #  address line <span class="number">20</span> is tied low, so that addresses higher than</span><br><span class="line">    #  1MB wrap around to <span class="meta">zero</span> by <span class="meta">default</span>. This code undoes this.</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">A20 开启方法是 将 <span class="number">0x64</span> 端口读入一个字节 到 <span class="built_in">al</span>中 然后 testb 即做一个 <span class="keyword">and</span> 运算 只不过不保存结果 判断一下 <span class="number">0x64</span>端口的第二位是否为<span class="number">0</span> 即 <span class="number">8042</span> 键盘缓冲区是否为空 若不为空 则循环 直至为空</span><br><span class="line">后 将 0xdl(写入数据到<span class="number">8042</span>的p2端口) 写入到 <span class="number">0x64</span>端口中</span><br><span class="line"></span><br><span class="line">后面的也很类似</span><br><span class="line">还是判断 <span class="number">0x64</span>端口的第二位是不是为<span class="number">0</span> 不是就循环</span><br><span class="line">然后把 <span class="number">0xdf</span>(<span class="number">11011111</span>) 写入到 <span class="number">0x60</span> 设置了 P2的 A20位 即第一位为 <span class="number">1</span> 开启 A20地址线</span><br><span class="line">--------------------------------------------------------</span><br><span class="line"><span class="symbol">seta20.1:</span></span><br><span class="line">    inb <span class="number">$0</span>x64, %al                                  # Wait for <span class="keyword">not</span> busy(<span class="number">8042</span> input buffer empty).</span><br><span class="line">    testb <span class="number">$0</span>x2, %al</span><br><span class="line">    <span class="keyword">jnz</span> seta20<span class="number">.1</span></span><br><span class="line"></span><br><span class="line">    movb <span class="number">$0</span>xd1, %al                                 # <span class="number">0xd1</span> -&gt; port <span class="number">0x64</span></span><br><span class="line">    outb %al, <span class="number">$0</span>x64                                 # <span class="number">0xd1</span> means: write data to <span class="number">8042</span><span class="string">&#x27;s P2 port</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">seta20.2:</span></span><br><span class="line"><span class="string">    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).</span></span><br><span class="line"><span class="string">    testb $0x2, %al</span></span><br><span class="line"><span class="string">    jnz seta20.2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    movb $0xdf, %al                                 # 0xdf -&gt; port 0x60</span></span><br><span class="line"><span class="string">    outb %al, $0x60                                 # 0xdf = 11011111, means set P2&#x27;</span>s A20 bit(the <span class="number">1</span> bit) to <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    # Switch from real to protected mode, using a bootstrap GDT</span><br><span class="line">    # <span class="keyword">and</span> <span class="meta">segment</span> translation that makes virtual addresses</span><br><span class="line">    # identical to physical addresses, so that the</span><br><span class="line">    # effective memory map does <span class="keyword">not</span> change during the switch.</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">加载 GDT 全局描述符表</span><br><span class="line">打开 保护模式 需要将 <span class="built_in">cr0</span> 控制寄存器的 第<span class="number">0</span>位 PE位 置<span class="number">1</span></span><br><span class="line">--------------------------------------------------------</span><br><span class="line">    <span class="keyword">lgdt</span> gdtdesc</span><br><span class="line">    movl %cr0, %eax</span><br><span class="line">    orl $CR0_PE_ON, %eax</span><br><span class="line">    movl %eax, %cr0</span><br><span class="line"></span><br><span class="line">    # Jump to next instruction, but <span class="keyword">in</span> <span class="number">32</span>-bit code <span class="meta">segment</span>.</span><br><span class="line">    # Switches processor <span class="keyword">into</span> <span class="number">32</span>-bit mode.</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">刷新流水线 进入 <span class="number">32</span>位模式</span><br><span class="line">将 PROT_MODE_CSEG = <span class="number">0x8</span> 此时 指向的是 GDT 中的第一个段描述符 加载到 <span class="built_in">CS</span> 后 protcseg 加载到 <span class="built_in">IP</span></span><br><span class="line">--------------------------------------------------------</span><br><span class="line">    ljmp $PROT_MODE_CSEG, $protcseg</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">.code32</span>                                             # Assemble for <span class="number">32</span>-bit mode</span><br><span class="line"><span class="symbol">protcseg:</span></span><br><span class="line">    # Set <span class="meta">up</span> the protected-mode data <span class="meta">segment</span> registers</span><br><span class="line">    movw $PROT_MODE_DSEG, %ax                       # Our data <span class="meta">segment</span> selector</span><br><span class="line">    movw %ax, %ds                                   # -&gt; <span class="built_in">DS</span>: Data <span class="meta">Segment</span></span><br><span class="line">    movw %ax, %es                                   # -&gt; <span class="built_in">ES</span>: Extra <span class="meta">Segment</span></span><br><span class="line">    movw %ax, %fs                                   # -&gt; <span class="built_in">FS</span></span><br><span class="line">    movw %ax, %gs                                   # -&gt; <span class="built_in">GS</span></span><br><span class="line">    movw %ax, %ss                                   # -&gt; <span class="built_in">SS</span>: Stack <span class="meta">Segment</span></span><br><span class="line"></span><br><span class="line">    # Set <span class="meta">up</span> the stack pointer <span class="keyword">and</span> <span class="keyword">call</span> <span class="keyword">into</span> C. The stack region is from <span class="number">0</span>--start(<span class="number">0x7c00</span>)</span><br><span class="line">    movl <span class="number">$0</span>x0, %ebp</span><br><span class="line">    movl $start, %esp</span><br><span class="line">    <span class="keyword">call</span> bootmain</span><br><span class="line"></span><br><span class="line">    # If bootmain returns (it shouldn<span class="string">&#x27;t), loop.</span></span><br><span class="line"><span class="string">spin:</span></span><br><span class="line"><span class="string">    jmp spin</span></span><br><span class="line"><span class="string">--------------------------------------------------------</span></span><br><span class="line"><span class="string">GDT 构建一个代码段描述符 和 一个数据段描述符 使用的平坦模型</span></span><br><span class="line"><span class="string">--------------------------------------------------------</span></span><br><span class="line"><span class="string"># Bootstrap GDT</span></span><br><span class="line"><span class="string">.p2align 2                                          # force 4 byte alignment</span></span><br><span class="line"><span class="string">gdt:</span></span><br><span class="line"><span class="string">第0个描述符项不可用</span></span><br><span class="line"><span class="string">    SEG_NULLASM                                     # null seg</span></span><br><span class="line"><span class="string">    SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)           # code seg for bootloader and kernel</span></span><br><span class="line"><span class="string">    SEG_ASM(STA_W, 0x0, 0xffffffff)                 # data seg for bootloader and kernel</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">gdtdesc:</span></span><br><span class="line"><span class="string">    .word 0x17                                      # sizeof(gdt) - 1</span></span><br><span class="line"><span class="string">    .long gdt                                       # address gdt</span></span><br></pre></td></tr></table></figure><ul><li>为何开启A20，以及如何开启A20</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实模式下内存访问采取的 段基址:段内偏移地址 的形式 段基址要左移4位再加上段内偏移地址来访问 实模式下寄存器都是16位的 如果段基址和段内便宜地址都为16位的最大值 0xFFFF:0xFFFF 即 0x10FFEF 当实模式下的地址总线为20位 最大寻址空间为 2的20次方= 1M 的内存 超出了 1M的内存 若不打开 A20地址线 CPU将采用 8086/8088 的地址回绕</span><br></pre></td></tr></table></figure><ul><li>如何初始化GDT表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">先提前创建好 GDT 里面的 代码段选择子 数据段选择子 然后 通过 调用 lgdt 将 GDT的界限和内存起始地址存入 GDTR 寄存器中</span><br></pre></td></tr></table></figure><ul><li>如何使能和进入保护模式</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将 cr0 控制寄存器的 第0位 PE位 置1</span><br><span class="line">同时 使用长跳转 刷新流水线 进入 32位模式</span><br></pre></td></tr></table></figure><h3 id="练习4：分析bootloader加载ELF格式的OS的过程"><a href="#练习4：分析bootloader加载ELF格式的OS的过程" class="headerlink" title="练习4：分析bootloader加载ELF格式的OS的过程"></a>练习4：分析bootloader加载ELF格式的OS的过程</h3><p>通过阅读bootmain.c，了解bootloader如何加载ELF文件。通过分析源代码和通过qemu来运行并调试bootloader&amp;OS，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SECTSIZE        512</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFHDR          ((struct elfhdr *)0x10000)      <span class="comment">// scratch space</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* waitdisk - wait for disk ready */</span></span><br><span class="line">检查 <span class="number">0x1F7</span> 端口 的 第<span class="number">7</span>位为<span class="number">0</span>则硬盘不忙</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">waitdisk</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> ((inb(<span class="number">0x1F7</span>) &amp; <span class="number">0xC0</span>) != <span class="number">0x40</span>)</span><br><span class="line">        <span class="comment">/* do nothing */</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* readsect - read a single sector at @secno into @dst */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">readsect</span><span class="params">(<span class="type">void</span> *dst, <span class="type">uint32_t</span> secno)</span> &#123;</span><br><span class="line">    <span class="comment">// wait for disk to be ready</span></span><br><span class="line">    waitdisk();</span><br><span class="line">--------------------------------------------------------</span><br><span class="line"><span class="number">0x1F2</span> 写入扇区数</span><br><span class="line"><span class="number">0x1F3</span> LBA <span class="number">0</span>~<span class="number">7</span></span><br><span class="line"><span class="number">0x1F4</span> LBA <span class="number">8</span>~<span class="number">15</span></span><br><span class="line"><span class="number">0x1F5</span> LBA <span class="number">16</span>~<span class="number">23</span></span><br><span class="line"><span class="number">0x1F6</span> LBA <span class="number">7</span>~<span class="number">4</span>位为<span class="number">1110</span> 表示LBA模式 <span class="number">24</span>~<span class="number">27</span> </span><br><span class="line"><span class="number">0x1F7</span> <span class="number">0x20</span> 读命令</span><br><span class="line">一次从 <span class="number">0x1F0</span> 读入 <span class="number">2</span>个字 <span class="number">4</span>个字节 读入<span class="number">512</span>字节 需要 <span class="number">128</span>次</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">    outb(<span class="number">0x1F2</span>, <span class="number">1</span>);                         <span class="comment">// count = 1</span></span><br><span class="line">    outb(<span class="number">0x1F3</span>, secno &amp; <span class="number">0xFF</span>);</span><br><span class="line">    outb(<span class="number">0x1F4</span>, (secno &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    outb(<span class="number">0x1F5</span>, (secno &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    outb(<span class="number">0x1F6</span>, ((secno &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xF</span>) | <span class="number">0xE0</span>);</span><br><span class="line">    outb(<span class="number">0x1F7</span>, <span class="number">0x20</span>);                      <span class="comment">// cmd 0x20 - read sectors</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait for disk to be ready</span></span><br><span class="line">    waitdisk();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read a sector</span></span><br><span class="line">    insl(<span class="number">0x1F0</span>, dst, SECTSIZE / <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * readseg - read @count bytes at @offset from kernel into virtual address @va,</span></span><br><span class="line"><span class="comment"> * might copy more than asked.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"> 包装一下 可以读取任意长度的内容 </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">readseg</span><span class="params">(<span class="type">uintptr_t</span> va, <span class="type">uint32_t</span> count, <span class="type">uint32_t</span> offset)</span> &#123;</span><br><span class="line">    <span class="type">uintptr_t</span> end_va = va + count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// round down to sector boundary</span></span><br><span class="line">    va -= offset % SECTSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// translate from bytes to sectors; kernel starts at sector 1</span></span><br><span class="line">    <span class="type">uint32_t</span> secno = (offset / SECTSIZE) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this is too slow, we could read lots of sectors at a time.</span></span><br><span class="line">    <span class="comment">// We&#x27;d write more to memory than asked, but it doesn&#x27;t matter --</span></span><br><span class="line">    <span class="comment">// we load in increasing order.</span></span><br><span class="line">    <span class="keyword">for</span> (; va &lt; end_va; va += SECTSIZE, secno ++) &#123;</span><br><span class="line">        readsect((<span class="type">void</span> *)va, secno);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* bootmain - the entry of bootloader */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bootmain</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// read the 1st page off disk</span></span><br><span class="line">这里读入了 <span class="number">512</span> * <span class="number">8</span> 个字节 ELF头</span><br><span class="line">    readseg((<span class="type">uintptr_t</span>)ELFHDR, SECTSIZE * <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// is this a valid ELF?</span></span><br><span class="line">根据读进来的文件的头部 魔数 判断是否为合法 ELF文件</span><br><span class="line">    <span class="keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// load each program segment (ignores ph flags)</span></span><br><span class="line">读取每个代码段 到指定的地方</span><br><span class="line">    ph = (<span class="keyword">struct</span> proghdr *)((<span class="type">uintptr_t</span>)ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">    eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line">    <span class="keyword">for</span> (; ph &lt; eph; ph ++) &#123;</span><br><span class="line">        readseg(ph-&gt;p_va &amp; <span class="number">0xFFFFFF</span>, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call the entry point from the ELF header</span></span><br><span class="line">    <span class="comment">// note: does not return</span></span><br><span class="line">进入内核</span><br><span class="line">    ((<span class="type">void</span> (*)(<span class="type">void</span>))(ELFHDR-&gt;e_entry &amp; <span class="number">0xFFFFFF</span>))();</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">真实硬件中 并不会有设备连接到 <span class="number">0x8A00</span> 端口 故相当于啥也没做</span><br><span class="line">    outw(<span class="number">0x8A00</span>, <span class="number">0x8A00</span>);</span><br><span class="line">    outw(<span class="number">0x8A00</span>, <span class="number">0x8E00</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* do nothing */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>bootloader如何读取硬盘扇区的？</li><li>bootloader是如何加载ELF格式的OS？<br>首先 bootloader 调用 bootmain 函数 然后读取第一个扇区的内容 到 0x10000 地址处 读取硬盘扇区的过程<br>0x1F2 写入扇区数<br>0x1F3 LBA 0<del>7<br>0x1F4 LBA 8</del>15<br>0x1F5 LBA 16<del>23<br>0x1F6 LBA 7</del>4位为1110 表示LBA模式 24~27<br>0x1F7 0x20 读命令<br>一次从 0x1F0 读入 2个字 4个字节 读入512字节 需要 128次<br>然后 判断 他的魔数是否为 ELF文件 若不是 则走向死循环 若是 则读 ELF 文件的程序段 到 该段的起始虚拟地址中去</li></ul><h3 id="练习5：实现函数调用堆栈跟踪函数"><a href="#练习5：实现函数调用堆栈跟踪函数" class="headerlink" title="练习5：实现函数调用堆栈跟踪函数"></a>练习5：实现函数调用堆栈跟踪函数</h3><p>我们需要在lab1中完成kdebug.c中函数print_stackframe的实现，可以通过函数print_stackframe来跟踪函数调用堆栈中记录的返回地址。在如果能够正确实现此函数，可在lab1中执行 “make qemu”后，在qemu模拟器中得到类似如下的输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print_stackframe</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> ebp = read_ebp(), eip = read_eip();</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; ebp != <span class="number">0</span> &amp;&amp; i &lt; STACKFRAME_DEPTH; i++) &#123;</span><br><span class="line">        cprintf(<span class="string">&quot;ebp:0x%08x eip:0x%08x args:&quot;</span>, ebp, eip);</span><br><span class="line">        <span class="type">uint32_t</span> *args = (<span class="type">uint32_t</span>*)ebp + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j ++ ) &#123;</span><br><span class="line">            cprintf(<span class="string">&quot;0x%08x &quot;</span>, args[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        cprintf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        print_debuginfo(eip - <span class="number">1</span>);</span><br><span class="line">        eip = ((<span class="type">uint32_t</span>*)ebp)[<span class="number">1</span>];</span><br><span class="line">取得 调用本函数的函数的返回地址</span><br><span class="line">        ebp = ((<span class="type">uint32_t</span>*)ebp)[<span class="number">0</span>];</span><br><span class="line">取得 调用本函数的 之前的 ebp 地址</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">最后一行输出的 ebp为 <span class="number">0x00007bf8</span> 但是 bootloader 起始地址是 <span class="number">0x7c00</span> 说明 压入了 两个东西 其中一个是 返回地址 另一个是 ebp 最后将 esp 赋给 ebp</span><br></pre></td></tr></table></figure><p><img data-src="/images/stack.png"><br>esp 栈顶指针<br>ebp 栈底指针<br>eip 寄存器存放的CPU下一条指令的地址<br>首先读取 ebp 和 eip 的值 然后 在ebp的地址上 + 2 就是第一个参数的位置</p><h3 id="练习6：完善中断初始化和处理"><a href="#练习6：完善中断初始化和处理" class="headerlink" title="练习6：完善中断初始化和处理"></a>练习6：完善中断初始化和处理</h3><p>请完成编码工作和回答如下问题：</p><ol><li>中断描述符表（也可简称为保护模式下的中断向量表）中一个表项占多少字节？其中哪几位代表中断处理代码的入口？</li></ol><p><img data-src="/images/trapgate.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Gate descriptors for interrupts and traps */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gatedesc</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> gd_off_15_0 : <span class="number">16</span>;        <span class="comment">// low 16 bits of offset in segment</span></span><br><span class="line">    <span class="type">unsigned</span> gd_ss : <span class="number">16</span>;            <span class="comment">// segment selector</span></span><br><span class="line">    <span class="type">unsigned</span> gd_args : <span class="number">5</span>;            <span class="comment">// # args, 0 for interrupt/trap gates</span></span><br><span class="line">    <span class="type">unsigned</span> gd_rsv1 : <span class="number">3</span>;            <span class="comment">// reserved(should be zero I guess)</span></span><br><span class="line">    <span class="type">unsigned</span> gd_type : <span class="number">4</span>;            <span class="comment">// type(STS_&#123;TG,IG32,TG32&#125;)</span></span><br><span class="line">    <span class="type">unsigned</span> gd_s : <span class="number">1</span>;                <span class="comment">// must be 0 (system)</span></span><br><span class="line">    <span class="type">unsigned</span> gd_dpl : <span class="number">2</span>;            <span class="comment">// descriptor(meaning new) privilege level</span></span><br><span class="line">    <span class="type">unsigned</span> gd_p : <span class="number">1</span>;                <span class="comment">// Present</span></span><br><span class="line">    <span class="type">unsigned</span> gd_off_31_16 : <span class="number">16</span>;        <span class="comment">// high bits of offset in segment</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">8</span> 个字节  <span class="number">0</span>~<span class="number">15</span> + <span class="number">48</span>~<span class="number">63</span> 组成段偏移 + <span class="number">16</span>~<span class="number">31</span> 组成段描述符选择子 通过段描述符选择子 和 段偏移 找到 中断程序的入口</span><br></pre></td></tr></table></figure><ol start="2"><li>请编程完善kern&#x2F;trap&#x2F;trap.c中对中断向量表进行初始化的函数idt_init。在idt_init函数中，依次对所有中断入口进行初始化。使用mmu.h中的SETGATE宏，填充idt数组内容。每个中断的入口由tools&#x2F;vectors.c生成，使用trap.c中声明的vectors数组即可。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">uintptr_t</span> __vectors[];</span><br><span class="line"><span class="type">void</span> <span class="title function_">idt_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(idt) / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> gatedesc); i++) &#123;</span><br><span class="line">        SETGATE(idt[i], <span class="number">0</span>, GD_KTEXT, __vectors[i], DPL_KERNEL);</span><br><span class="line">    &#125;</span><br><span class="line">	用于系统调用 专门给用户使用的</span><br><span class="line">	SETGATE(idt[T_SWITCH_TOK], <span class="number">0</span>, GD_KTEXT, __vectors[T_SWITCH_TOK], DPL_USER);</span><br><span class="line">	将 中断向量表加载到 ldtr 寄存器中</span><br><span class="line">    lidt(&amp;idt_pd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>请编程完善trap.c中的中断处理函数trap，在对时钟中断进行处理的部分填写trap函数中处理时钟中断的部分，使操作系统每遇到100次时钟中断后，调用print_ticks子程序，向屏幕上打印一行文字”100 ticks”。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kern/trap/trap.c <span class="number">138</span>:</span><br><span class="line">    <span class="keyword">switch</span> (tf-&gt;tf_trapno) &#123;</span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_TIMER:</span><br><span class="line">        <span class="keyword">if</span> (++ticks % TICK_NUM == <span class="number">0</span>) &#123;</span><br><span class="line">            print_ticks();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p><img data-src="/images/lab1.png"></p><h3 id="扩展练习"><a href="#扩展练习" class="headerlink" title="扩展练习"></a>扩展练习</h3><h4 id="扩展练习-Challenge-1"><a href="#扩展练习-Challenge-1" class="headerlink" title="扩展练习 Challenge 1"></a>扩展练习 Challenge 1</h4><p>扩展proj4,增加syscall功能，即增加一用户态函数（可执行一特定系统调用：获得时钟计数值），当内核初始完毕后，可从内核态返回到用户态的函数，而用户态的函数又通过系统调用得到内核态的服务。需写出详细的设计和分析报告。完成出色的可获得适当加分。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">kern/init/init.c</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">lab1_switch_to_user</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">	<span class="string">&quot;sub $0x8, %%esp \n&quot;</span> </span><br><span class="line">	让 SS 和 ESP 这两个寄存器 有机会 POP 出时 更新 SS 和 ESP</span><br><span class="line">	因为 从内核态进入中断 它的特权级没有改变 是不会 push 进 SS 和 ESP的 但是我们又需要通过 POP SS 和 ESP 去修改它们</span><br><span class="line">	进入 T_SWITCH_TOU(<span class="number">120</span>) 中断</span><br><span class="line">	将原来的栈顶指针还给esp栈底指针</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">	    <span class="string">&quot;sub $0x8, %%esp \n&quot;</span></span></span><br><span class="line"><span class="params">	    <span class="string">&quot;int %0 \n&quot;</span></span></span><br><span class="line"><span class="params">	    <span class="string">&quot;movl %%ebp, %%esp&quot;</span></span></span><br><span class="line"><span class="params">	    : </span></span><br><span class="line"><span class="params">	    : <span class="string">&quot;i&quot;</span>(T_SWITCH_TOU)</span></span><br><span class="line"><span class="params">	)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">lab1_switch_to_kernel</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">	进入 T_SWITCH_TOK(<span class="number">121</span>) 中断</span><br><span class="line">	将原来的栈顶指针还给esp栈底指针</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">	    <span class="string">&quot;int %0 \n&quot;</span></span></span><br><span class="line"><span class="params">	    <span class="string">&quot;movl %%ebp, %%esp \n&quot;</span></span></span><br><span class="line"><span class="params">	    : </span></span><br><span class="line"><span class="params">	    : <span class="string">&quot;i&quot;</span>(T_SWITCH_TOK)</span></span><br><span class="line"><span class="params">	)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">kern/trap/trap.c :</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">trap_dispatch</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span></span><br><span class="line">通过&quot;改造&quot;一个中断 来进入我们想进入的用户态或者内核态</span><br><span class="line">    <span class="keyword">case</span> T_SWITCH_TOU:</span><br><span class="line">        <span class="title function_">if</span> <span class="params">(tf-&gt;tf_cs != USER_CS)</span> &#123;</span><br><span class="line">            switchk2u = *tf;</span><br><span class="line">            switchk2u.tf_cs = USER_CS;</span><br><span class="line">            switchk2u.tf_ds = switchk2u.tf_es = switchk2u.tf_ss = USER_DS;</span><br><span class="line">            switchk2u.tf_eflags |= FL_IOPL_MASK; <span class="comment">// IOPL 改为 0</span></span><br><span class="line">            switchk2u.tf_esp = (<span class="type">uint32_t</span>)tf + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe) - <span class="number">8</span>; <span class="comment">// tf-&gt;esp的位置</span></span><br><span class="line">            <span class="comment">// iret 回到用户栈</span></span><br><span class="line">            *((<span class="type">uint32_t</span> *)tf - <span class="number">1</span>) = (<span class="type">uint32_t</span>)&amp;switchk2u;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> T_SWITCH_TOK:</span><br><span class="line">        <span class="keyword">if</span> (tf-&gt;tf_cs != KERNEL_CS) &#123;</span><br><span class="line">            tf-&gt;tf_cs = KERNEL_CS;</span><br><span class="line">            tf-&gt;tf_ds = tf-&gt;tf_es = KERNEL_DS;</span><br><span class="line">            tf-&gt;tf_eflags &amp;= ~FL_IOPL_MASK;</span><br><span class="line">            switchu2k = (<span class="keyword">struct</span> trapframe *)(tf-&gt;tf_esp - (<span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe) - <span class="number">8</span>));</span><br><span class="line">            memmove(switchu2k, tf, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe) - <span class="number">8</span>);</span><br><span class="line">            *((<span class="type">uint32_t</span> *)tf - <span class="number">1</span>) = (<span class="type">uint32_t</span>)switchu2k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>根据这张图 可以看出 内核态和用户态的转换 首先是留下 SS 和 ESP 的位置 然后 调用中断 改中断栈里面的内容 最后退出中断的时候 跳到内核态中 最后将 ebp 赋给 esp 修复 esp 的位置<br><img data-src="/images/pcb.png"></p><h4 id="扩展练习-Challenge-2"><a href="#扩展练习-Challenge-2" class="headerlink" title="扩展练习 Challenge 2"></a>扩展练习 Challenge 2</h4><p>用键盘实现用户模式内核模式切换。具体目标是：“键盘输入3时切换到用户模式，键盘输入0时切换到内核模式”。 基本思路是借鉴软中断(syscall功能)的代码，并且把trap.c中软中断处理的设置语句拿过来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">kern/trap/trap.c</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">switch_to_user</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">	    <span class="string">&quot;sub $0x8, %%esp \n&quot;</span></span></span><br><span class="line"><span class="params">	    <span class="string">&quot;int %0 \n&quot;</span></span></span><br><span class="line"><span class="params">	    <span class="string">&quot;movl %%ebp, %%esp&quot;</span></span></span><br><span class="line"><span class="params">	    : </span></span><br><span class="line"><span class="params">	    : <span class="string">&quot;i&quot;</span>(T_SWITCH_TOU)</span></span><br><span class="line"><span class="params">	)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">switch_to_kernel</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">	    <span class="string">&quot;int %0 \n&quot;</span></span></span><br><span class="line"><span class="params">	    <span class="string">&quot;movl %%ebp, %%esp \n&quot;</span></span></span><br><span class="line"><span class="params">	    : </span></span><br><span class="line"><span class="params">	    : <span class="string">&quot;i&quot;</span>(T_SWITCH_TOK)</span></span><br><span class="line"><span class="params">	)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_KBD:</span><br><span class="line">        c = cons_getc();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;3&#x27;</span>) &#123;</span><br><span class="line">            switch_to_user();</span><br><span class="line">            print_trapframe(tf);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            switch_to_kernel();</span><br><span class="line">            print_trapframe(tf);</span><br><span class="line">        &#125;</span><br><span class="line">        cprintf(<span class="string">&quot;kbd [%03d] %c\n&quot;</span>, c, c);</span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>按键的中断在 IRQ_KBD 处</p></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"># 操作系统</a> <a href="/tags/uCore/" rel="tag"># uCore</a> <a href="/tags/Lab/" rel="tag"># Lab</a></div><div class="post-nav"><div class="post-nav-item"><a href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B-%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E3%80%81%E4%B8%AD%E6%96%AD%E3%80%81%E8%B0%83%E7%94%A8/" rel="prev" title="操作系统之 系统启动、中断、调用"><i class="fa fa-angle-left"></i> 操作系统之 系统启动、中断、调用</a></div><div class="post-nav-item"><a href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/" rel="next" title="操作系统之 物理内存管理 连续内存分配">操作系统之 物理内存管理 连续内存分配 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments" id="waline"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Yuerer</span></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://unpkg.com/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://unpkg.com/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/comments.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/utils.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/motion.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/sidebar.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/hexo-theme-next/8.21.1/next-boot.min.js"></script><script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://yuerer-comment-xufei-0bea01e6f05-1307930306.ap-shanghai.app.tcloudbase.com","cssUrl":"https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.css","commentCount":true,"pageview":true,"libUrl":"https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.js","locale":{"placeholder":"有何高见？"},"emoji":["https://unpkg.com/@waline/emojis@1.0.1/qq"],"meta":["nick","mail"],"requiredMeta":[["nick","mail"]],"wordLimit":0,"login":"disable","pageSize":10,"el":"#waline","comment":true,"path":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-uCore-Lab-1/"}</script><link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.css"><script>document.addEventListener("page:loaded",()=>{NexT.utils.loadComments(CONFIG.waline.el).then(()=>NexT.utils.getScript(CONFIG.waline.libUrl,{condition:window.Waline})).then(()=>Waline.init(Object.assign({},CONFIG.waline,{el:document.querySelector(CONFIG.waline.el)})))})</script></body></html>